[
  {
    "objectID": "index.html#size-based-ecosystem-models-with-the-r-package-mizer-and-applications-for-coastal-and-inland-ecosystems",
    "href": "index.html#size-based-ecosystem-models-with-the-r-package-mizer-and-applications-for-coastal-and-inland-ecosystems",
    "title": "Online mizer course",
    "section": "Size based ecosystem models with the R package mizer and applications for coastal and inland ecosystems",
    "text": "Size based ecosystem models with the R package mizer and applications for coastal and inland ecosystems\nPlease join us for an online course to learn about the principles of size based community and ecosystem modelling, implementation of these principles in the R package mizer, learn about adaptation of mizer for shallow ecosystems with multiple resources, and learn how to build a new model with your own or example data\nThe course consistes of the following tutorials:\n\nIntroduction to the mizer course\nIntroduction to the mizer model\nSize spectra from observations\nSingle-species size-spectrum dynamics\nMulti-species size-spectrum dynamics\nUsing a model to explore the consequences of change\nBuilding a new multi-species model\nFinding species parameters\nSetting up multiple resources\n\nThe course is led by Gustav Delius (University of York, UK) and Asta Audzijonyte (Nature Research Centre, Lithuania & University of Tasmania, Australia). Invited speakers include Ken Haste Andersen, Julia Blanchard and others\nParticipation is free. If you are interested in this course and would like to continue receiving information about it, please register here\nIf you need more information, please contact us at info@fishsizeproject.org or comment below."
  },
  {
    "objectID": "single-species-size-spectrum-dynamics.html#investment-into-reproduction",
    "href": "single-species-size-spectrum-dynamics.html#investment-into-reproduction",
    "title": "Single-species size-spectrum dynamics",
    "section": "Investment into reproduction",
    "text": "Investment into reproduction\nLet us look at a plot of the proportion of the available energy that is invested into reproduction as a function of the size\n\n\n\n\n\nHow was this maturity curve specified? You can find the details in the mizer documentation. There are four species parameters involved:\n\nthe maturity size w_mat at which 50% of the individuals are mature.\nthe size w_mat25 at which 25% of the individuals are mature.\nthe asymptotic size w_inf at which an organism invests 100% of its income into reproduction and thus growth is zero.\nan exponent m that determines how the proportion that an individual invests into reproduction scales with its size.\n\nSuch species parameters are contained in a data frame inside the params object that we can access with the species_params() function.\n\n\n                      species w_min w_inf    w_mat w_min_idx k_vb    gamma\nTarget species Target species 0.001   100 25.11886         1    1 4067.903\n                     ks  f0   fc beta sigma z0 alpha   erepro\nTarget species 5.906914 0.6 0.25  100   1.3  0   0.4 0.899483\n               interaction_resource    n    p   q pred_kernel_type        h k\nTarget species                    1 0.75 0.75 0.8        lognormal 59.06914 0\n                w_mat25 m R_max\nTarget species 22.50546 1   Inf\n\n\nAs you can see, there are a lot of other species parameters, some of which we will talk about later. For now let’s just select the 4 parameters we are interested in.\n\n\n                  w_mat  w_mat25 w_inf m\nTarget species 25.11886 22.50546   100 1"
  },
  {
    "objectID": "single-species-size-spectrum-dynamics.html#effect-of-change-in-maturity-curve",
    "href": "single-species-size-spectrum-dynamics.html#effect-of-change-in-maturity-curve",
    "title": "Single-species size-spectrum dynamics",
    "section": "Effect of change in maturity curve",
    "text": "Effect of change in maturity curve\nLet us investigate what happens when we change the maturity curve. Let’s assume the maturity size is actually 40 grams and the size at which 25% of individuals is mature is 30 grams. Let us change the values in the species_params data frame. But first we make a copy of the params object so that we can keep the old version around unchanged.\n\n\n\nIn this copy we now change the species parameters\n\n\n               w_mat w_mat25 w_inf m\nTarget species    40      30   100 1\n\n\nNow the maturity curve has changed, which we can verify by plotting it\n\n\n\n\n\nAt this point let’s take a little break and learn how to draw two curves in the same graph. How can we see the old maturity curve and the new maturity curve in the same plot? First we add an extra column to each dataframe describing it\n\n\n\nThen we bind the two data frames together\n\n\n\nand send that combined data frame to ggplot()\n\n\n\n\n\nThis change in the maturity curve of course implies a change in the growth rates.\n\nExercise 4\nMake a plot showing the growth rates of the original model and of the model with the changed maturity curve.\n\nNext let us look at how the steady state spectrum has changed. We first need to run the changed model to steady state\n\n\nConvergence was achieved in 6 years.\n\n\nWe use the same technique as above to plot the steady-state spectra of both models on top of each other.\n\n\n\n\n\nAs expected, the bump happens later due to the larger maturity size and it is less pronounced, because the maturity curve is less steep."
  },
  {
    "objectID": "single-species-size-spectrum-dynamics.html#reproductive-efficiency",
    "href": "single-species-size-spectrum-dynamics.html#reproductive-efficiency",
    "title": "Single-species size-spectrum dynamics",
    "section": "Reproductive efficiency",
    "text": "Reproductive efficiency\nSo what happens with the energy that is invested into reproduction? It leads to spawning and thus the influx of new individuals at the egg size. This conversion of energy invested into reproduction into egg biomass is inefficient. Firstly much energy is spent on things like migration to spawning grounds, rather than on production of gonadic mass. Secondly, only a small proportion of eggs that are produced are viable and hatch into larvae.\nIn order for the population to be at steady state, the reproductive efficiency has to have a particular value. If it were higher, the population would increase, if it was lower, the population would decrease with time. The steady() function has set the reproductive efficiency to just the right value to maintain the population level and has stored it in the species parameter called erepro.\n\n\n[1] 0.899483\n\n\nThe model with the changed maturity curve leads to a different rate of investment into reproduction and thus needs a slightly different reproductive efficiency to remain at steady state:\n\n\n[1] 0.8894015\n\n\nThis is the reproductive efficiency at steady state. When the population deviates from the steady state, for example due to a change in fishing, the reproductive efficiency can be set to change according to a Beverton-Holt stock-recruitment curve. We will discuss this again later."
  },
  {
    "objectID": "single-species-size-spectrum-dynamics.html#effect-of-prey-availability",
    "href": "single-species-size-spectrum-dynamics.html#effect-of-prey-availability",
    "title": "Single-species size-spectrum dynamics",
    "section": "Effect of prey availability",
    "text": "Effect of prey availability\nThe energy income for a fish comes from predation on its prey. If there is less prey, the fish consumes less and thus its growth rate will decrease. Let us investigate this by artificially removing some prey.\nBelow we decrease the community spectrum by a factor of 10 in the size range from 1mg to 10mg. We again create a new parameter object to be able to keep the old one around\n\n\n\nThat is of course quite a dramatic intervention, and so should allow us to clearly see its effect on the steady-state size distribution of our species.\n\n\nConvergence was achieved in 6 years.\n\n\nWarning in setBevertonHolt(params, reproduction_level = old_reproduction_level):\nThe following species require an unrealistic reproductive efficiency greater\nthan 1: Target species\n\n\n\n\n\n\n\nAs expected, the lack of food and the resulting slow-down in growth leads to a traffic jam: a peak in the biomass density. This slow-down occurs at a size that is about a factor of 100 larger than the size at which food is reduced. Why this is we will discuss in the next section. But first investigate what happens when the prey abundance is increased instead of decreased.\n\nExercise 5\nPlot the steady state biomass density in our model when the community abundance is increased by a factor of 10 in the size range from 1mg to 10mg."
  },
  {
    "objectID": "single-species-size-spectrum-dynamics.html#how-predation-is-modelled",
    "href": "single-species-size-spectrum-dynamics.html#how-predation-is-modelled",
    "title": "Single-species size-spectrum dynamics",
    "section": "How predation is modelled",
    "text": "How predation is modelled\nThe easiest case in which to understand predation is to imagine a filter feeding fish, swimming around with its mouth open. Clearly the amount of food it takes in is determined by four things:\n\nthe density of prey in the water,\nhow much volume of water the fish is able to filter, which will depend on how fast it swims as well as on its gape size.\nwhat sizes of prey the fish is able to filter out of the water, which will be limited by its gape size and by how fine its gill rakers are,\nhow fast it can digest the food. If it can filter the prey faster than it can digest, it will have to start letting prey go uneaten.\n\nFor a more active hunter the situation will be similar. The rate at which it predates will depend on four things:\n\nthe density of prey in the water\nthe volume of water that the fish patrols and in which it will be able to seek out its prey. This may depend on things like radius of vision.\nwhich of this detected prey the fish is able to catch, which will depend on its mouth size but also on its agility and skill as well as on the defensive mechanisms of the prey.\nhow fast it can digest the food.\n\nOf these four factors, we have of course already been discussing the density of prey. In the next section we will discuss the ability to filter out or catch prey of particular sizes, which we model via the predation kernel. In the section after that we will discuss the search volume and then in the following section the maximum consumption rate."
  },
  {
    "objectID": "single-species-size-spectrum-dynamics.html#the-predation-kernel",
    "href": "single-species-size-spectrum-dynamics.html#the-predation-kernel",
    "title": "Single-species size-spectrum dynamics",
    "section": "The predation kernel",
    "text": "The predation kernel\nFish will be particularly good at catching prey in a specific range of sizes, smaller than themselves. This is encoded in the size-spectrum model by the predation kernel. Let us take a look at the predation kernel in our model. We can obtain it with the function getPredKernel().\n\n\n\nThis is a large three-dimensional array (predator species x predator size x prey size). We extract the kernel of a predator of size 10g (using that we remember that this is in size class 81)\n\n\n\nThe drop = FALSE option is there to prevent R from dropping any of the array dimensions. We can now plot this as usual\n\n\n\n\n\nWe see that the predator of size 10g likes to feed on prey that is about a factor 100 smaller than itself, but also feeds on other sizes, just with reduced preference. The preferred predator/prey size ratio is determined by the species parameter beta and the width of the feeding kernel, i.e., how fussy the predator is regarding their prey size, is determined by the species parameter sigma. In our model these have the values\n\n\n               beta sigma\nTarget species  100   1.3\n\n\nLet us change the preferred predator/prey mass ratio from 100 to 1000. As usual, we first create a copy of the parameter object, then we make the change in that copy.\n\n\n\nLet’s make a plot to see that the predation kernel has indeed changed.\n\n\n\n\n\nIf we now again reduce the prey in the size range from 1mg to 10mg as before, we now expect this to produce a peak in the biomass spectrum somewhere between 1g and 10g. Let’s check.\n\n\nConvergence was achieved in 4.5 years.\n\n\nWarning in setBevertonHolt(params, reproduction_level = old_reproduction_level):\nThe following species require an unrealistic reproductive efficiency greater\nthan 1: Target species\n\n\n\n\n\nYes, as expected.\nFor details of how beta and sigma parametrise the predation kernel, see https://sizespectrum.org/mizer/reference/lognormal_pred_kernel.html#details. For information on how to change the predation kernel, see https://sizespectrum.org/mizer/reference/setPredKernel.html#setting-predation-kernel\nIt is very important not to confuse the prey preference with the diet. Just because a predator might prefer to feed on prey of a particular size if it had free choice does not mean that it actually feeds predominantly on such prey. The actual diet of the fish depends also on the availability of prey. Because smaller prey are more abundant, the realised predator/prey mass ratio in the diet will be smaller than the preferred predator/prey mass ratio. This is particularly important when estimating the predation kernel from stomach data.\n\nExercise 6\nChange the parameters of the predation kernel to beta = 50 and sigma = 2 and plot the predation kernel of a predator of size 1g. You should see that the predation kernel is truncated so that the predator never feeds on prey larger than themselves.\n\n\nNext, plot the steady state arising with this feeding kernel when the prey abundance is artificially reduced by a factor of 10 in the size range between 1mg and 10mg as in previous examples. What do you observe? Are you surprised?"
  },
  {
    "objectID": "single-species-size-spectrum-dynamics.html#search-volume",
    "href": "single-species-size-spectrum-dynamics.html#search-volume",
    "title": "Single-species size-spectrum dynamics",
    "section": "Search volume",
    "text": "Search volume\nNext we consider the factor that models the volume of water a filter feeder is able to filter in a certain amount of time, or the volume of water a forage fish is able to patrol in a certain amount of time. This is difficult to model from first principles, although people have tried to argue in terms of swimming speeds of fish. We assume that this search volume rate is also an allometric rate. Let \\gamma(w) denote this rate for a predator of size w. Thus we assume that \\gamma(w) = \\gamma_0\\ w^q for some exponent q. We know that a fish needs to consume prey at a rate that scales with its body size to the power p, with p about 3/4. We also know that the prey density will be approximately described by the Sheldon power law, i.e., that N(w) = N_0\\ w^{-\\lambda}. A bit of maths then says that q = 2 - \\lambda + n. This explains the message you got when you created the params object with a certain choice of \\lambda: mizer chose the search volume exponent automatically according to this formula. In the real world, evolution will have made sure that the fish will have developed a feeding strategy that allows it to cover its metabolic costs, and thus leads to that search volume exponent of q. Clearly, filter feeders have taken a very different route to this than forage fish, but the result is the same.\nLet us see what effect changing the coefficient \\gamma_0 in the search volume rate has. Its current value in our model is\n\n\n[1] 4067.903\n\n\nWe change that to 2000 and find the new steady state.\n\n\nWarning in setBevertonHolt(params, reproduction_level = old_reproduction_level):\nThe following species require an unrealistic reproductive efficiency greater\nthan 1: Target species\n\n\nWe can see the effect in the growth curve of our species. In the original model it looks as follows:\n\n\n\n\n\nIn the modified model it looks like\n\n\n\n\n\n\nExercise 7\nWhat effect will this change in growth rate have on the slope of the juvenile spectrum? Will it be steeper or shallower? Make the plot of the spectrum to see."
  },
  {
    "objectID": "single-species-size-spectrum-dynamics.html#feeding-level",
    "href": "single-species-size-spectrum-dynamics.html#feeding-level",
    "title": "Single-species size-spectrum dynamics",
    "section": "Feeding level",
    "text": "Feeding level\nA predator will have a maximum intake rate. It will simply not be able to utilise food at a faster rate than its maximum intake rate. Of course in practice it will not feed at the maximum intake rate because of limited availability of prey. We describe this by the feeding level which is the proportion of its maximum intake rate at which the predator is actually taking in prey.\nIn our simple model this feeding level is constant.\n\n\n\n\n\nIn the model with the reduced search volume the feeding level will be lower\n\n\n\n\n\nOur model is taking an allometric form for the maximum intake rate h(w) as a function of predator size w: h(w) = h\\ w^n. The current value of the coefficient h is\n\n\n[1] 59.06914"
  },
  {
    "objectID": "single-species-size-spectrum-dynamics.html#predation-mortality",
    "href": "single-species-size-spectrum-dynamics.html#predation-mortality",
    "title": "Single-species size-spectrum dynamics",
    "section": "Predation mortality",
    "text": "Predation mortality\nOf course growth of the predator is only one aspect of predation. The other is the death of the prey. Growth and mortality are coupled. Increased growth of one class of individuals will necessitate increased death of another. There is no free lunch.\nOnce we have specified the predation parameters, these parameters determine both the growth of predators but also the mortality rate of prey. So we don’t have to introduce new parameters for death from predation."
  },
  {
    "objectID": "single-species-size-spectrum-dynamics.html#external-mortality",
    "href": "single-species-size-spectrum-dynamics.html#external-mortality",
    "title": "Single-species size-spectrum dynamics",
    "section": "External mortality",
    "text": "External mortality\nIn addition to mortality caused by predation from other fish, there will be some mortality from other causes. This could be predation from animals that we have not included in our model, like sea birds or mammals, or it could be death from old age (senescent death) or disease. Mizer allows setting of background death with setExtMort()."
  },
  {
    "objectID": "single-species-size-spectrum-dynamics.html#fishing-mortality",
    "href": "single-species-size-spectrum-dynamics.html#fishing-mortality",
    "title": "Single-species size-spectrum dynamics",
    "section": "Fishing mortality",
    "text": "Fishing mortality\nThe cause of mortality that is most under our control is mortality from fishing. You can see how fishing is set up in mizer at https://sizespectrum.org/mizer/reference/setFishing.html#setting-fishing. Here we only look at a simple example: we introduce fishing on our species only for fish above 30 grams. All fish greater than 30 grams will be exposed to the same fishing mortality. We call this kind of fishing selectivity “knife_edge” selectivity. Mizer can deal with more general selectivity curves, like sigmoidal or doubly sigmoidal.\n\n\n\nWe also need to specify the fishing effort and can then plot the resulting fishing mortality."
  },
  {
    "objectID": "use/simulate-change.html",
    "href": "use/simulate-change.html",
    "title": "Using a model to explore the consequences of change",
    "section": "",
    "text": "Mizer is a tool that can be used to simulate a dynamic size spectrum in an marine ecosystem, subject to changes through time, such as fishing pressure. Multiple interacting species and fishing gears can be defined allowing for a range of fisheries management strategy scenarios, and their ecosystem impacts, to be tested.\nBelow we explore some examples of what can be done using a previously calibrated mizer model. We will use the mizerHowTo package which contains some handy functions for this example.\n\n\n\nIn the previous tutorials we have been focused on the steady state. Now we are ready to make changes through time by forcing the model away from its steady state. For this example, will start with the toothfish model but as always you can you your own model or the curonian lagoon for the exercises.\n\nIn the previous tutorial, we examined a simple longline fishery that consists of targeting a single species (toothfish, here referred to as D.ele). However, all of the parameters for fishing were fixed through time. Mizer can also be used to carry out projections with changes in fishing effort.\nWe will start by reading in a time series of catch and effort.\n\n# read in model sim object\nsim <- readRDS(\"toothfish/params10.RDS\")\nparams <- sim@params\n\n# read in fishing data (note: these are not really correct values, they are only for illustration in this example) \n\ndat<-readRDS(\"toothfish/longline.rds\")\n\nplot_dat <- reshape2::melt(dat, \"Year\")\nggplot(plot_dat, aes(x = Year, y = value)) +\n  geom_point() +\n  facet_wrap(~variable, nrow = 2, scales = \"free\")\n\n\n\n\nWe can see from the data that there have been big changes in effort and catches through time. The first plot shows relative effort per area (note: these data are only for illustration in this example). Catches are in tonnes per square km fished.\nPreviously we assumed effort was 1 and we worked with catchability as the variable. Real effort data can come in all sorts of different units (hours or days fished, kilowatt days, number of vessels all per unit time). The key to using this in our model is that the catchability is the fraction of the available (that is also selected by the gear) stock caught per unit of any effort that is included.\nOften, we have used fishing mortality rates from stock assessment to drive changes in effort through time, assuming Q*E = F at maximally selected sizes (as in this paper and others). But in many cases this information is not available. It also could be misleading as those fishing mortality rates are estimated using very different single-species models (but sometimes that is the best we have to work with, and as with all of the assumptions we make the limitations just need to be clear).\nHow do we incorporate the effort data into the model? First, we have to re-arrange the data so it can be read into the param object.\n\nspecies_params(params)\n\n\n\n  \n\n\neffort_time <-array(c(rep(0,13),dat$EffortPerArea), dim = c(length(1990:2020),1),dimnames = list(\"time\" = 1990:2020, \"gear\" = params@gear_params$gear[1]))\n\nNext we use the effort data to project the model forwards from it’s steady state. But wait - we did not set up the model for the first year of the data, when fishing only just began. It may make more sense to use a steady state without fishing as the initial values for our projection.\n\nsim0 <- projectToSteady(params, effort = 0, return_sim = TRUE, t_max = 200)\n\nConvergence was achieved in 1.5 years.\n\nparams<-setInitialValues(params,sim0)\n\n\nsimf <- project(params, effort = effort_time)\n\nyieldplot<-plotYieldGear(simf)\n\nyieldcompare<-yieldplot+ geom_point(data = dat, shape = 1, size = 1, mapping = aes(x=Year, y= CatchPerArea))\nyieldcompare\n\n\n\n\nHere we can see that the modeled catch time series fall within the scatter of the observed catch data (reassuring), but the trends are different. It seems there is a sharp decline in modeled catches towards the end of the time series. While we should not expect the exact up and down fluctuations to be captured by our model (we don’t have anything forcing the changes through time other than fishing!), we can examine how changing the reproduction parameters affects how well the model captures stock decline (and later, recovery), relative to the trends in the data.\nWe can look at this below by changing the reproduction level and seeing what the levels of sustainable fishing mortality the equilibrium yield vs F curves suggest for different assumptions (where the peak occurs we could consider a proxy for single-species Fmsy) .\n\n\nConvergence was achieved in 1.5 years.\nConvergence was achieved in 1.5 years.\n\n\nSimulation run did not converge after 90 years. Value returned by the distance function was: NA\n\n\nConvergence was achieved in 36 years.\n\n\nSimulation run did not converge after 99 years. Value returned by the distance function was: 10.5521905688198\n\n\nSimulation run did not converge after 99 years. Value returned by the distance function was: 17.2376886919921\n\n\nSimulation run did not converge after 99 years. Value returned by the distance function was: 26.482467838532\n\n\nSimulation run did not converge after 9 years. Value returned by the distance function was: NA\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\n\n\n\nConvergence was achieved in 1.5 years.\n\n\nConvergence was achieved in 25.5 years.\n\n\nConvergence was achieved in 13.5 years.\n\n\nConvergence was achieved in 33 years.\n\n\nConvergence was achieved in 22.5 years.\n\n\nConvergence was achieved in 21 years.\n\n\nConvergence was achieved in 18 years.\n\n\nConvergence was achieved in 10.5 years.\nConvergence was achieved in 10.5 years.\nConvergence was achieved in 10.5 years.\n\n\n\n\n\nNext, let’s compare what happens when when use these new parameter in our dynamical fishing runs.\n\nparams2<-setInitialValues(params2,sim02)\nsimf2 <- project(params2, effort = effort_time)\n\nyieldplot2<-plotYieldGear(simf2)\n\nyieldcompare2<-yieldplot2+ geom_point(data = dat, shape = 1, size = 1, mapping = aes(x=Year, y= CatchPerArea))\nyieldcompare2\n\n\n\n\nThese two plots look almost exactly the same. How do you interpret this? Remember think about the relationship between the fishing parameters in the model (e.g. F = Q*E). We didn’t change these parameters, so they should be the same in both simulations and we can check them below:\n\nplotFMort(simf2)\n\n\n\n\n\nExamine how catch time series changes relative to the data if the reproduction parameters change. Is this consistent with what you expected from the steady state yield curves? How do the biomasses change under these different scenarios?\n\nWhat if there was no effort data only catch ? This is the case for many data-poor fisheries or for fisheries where there is only restricted access to effort data.\nMany fisheries develop through time according to phases: an exponential growth period, following either a peak and subsequent decline and a plateau, if stocks drop below sustainable levels and management kicks in (see here for example). These different types of development can be represented by a function, effort_dynamics(), and can be used to help estimate the fishing parameters given the the model parameters and data you may have. This is the approach used here. Here, we will use this function to explore effort through time.\n\n# should I move to helper_functions or leave it in?\n\neffort_dynamics<-function(effort_array, gear=\"longline\",time=1990:2020,Fmax=1.5,steepness=0.2,midpoint=2005){\n\neffort_array[,gear]<-Fmax/(1+ exp(-steepness*(time - midpoint)))\n\nreturn(effort_array)\n}\n\n# to scale the effort up to the effort we used in our model we divide Fmax by the catchability coefficient we used and set the Fmax to the same levels as abive (0.005)\n\n\nneweffort<-effort_dynamics(effort_time,time=1990:2020,Fmax=0.005,steepness=0.9,midpoint=2005)\n\nneweffort<-neweffort/gear_params(params)$catchability[1]\n\nyear=1990:2020\nplot(year,neweffort,typ=\"l\")\n\n\n\n\nNow you can run the same model above using this effort.\n\nparams3<-setInitialValues(params2,sim02)\nsimf3 <- project(params3, effort = neweffort)\n\nyieldplot3<-plotYieldGear(simf3)\n\nyieldcompare3<-yieldplot3+ geom_point(data = dat, shape = 1, size = 1, mapping = aes(x=Year, y= CatchPerArea)) + xlim(2000,2020) \nyieldcompare3\n\nWarning: Removed 10 row(s) containing missing values (geom_path).\n\n\n\n\nplotBiomass(simf3)\n\n\n\n\n\nWhat level of Fmax causes toothfish catches to decline? Use the code above to change Fmax to determine this. Is this consistent with the knowledge from the equilibrium yield curves (sensitivity to fishing tutorial)?\n\nSet up a bycatch on another the other species in the model. This uses the same effort but with a lower catchability. Hint: you can use the ?gear_params function to modify these values.\n\n[in prep]\nIf you are interested in how to statistically fit models to time series data the mizerHowTo package discusses this (still in preparation).\nNext we will investigate dynamical changes in environment, with a focus on changes in resource abundance and size structure."
  },
  {
    "objectID": "use/index.html",
    "href": "use/index.html",
    "title": "Week 3: Use mizer models",
    "section": "",
    "text": "Lecture\nThis week’s contributor is Julia Blanchard. Her lecture provides a broad overview of the different ways in which mizer is being used to help understand the consequences of change in aquatic ecosystems. There are a lot of ways! The material describes how you can set model simulations to study change, some of which are explored in further detail below.\n\n\n\nTutorials\nUsing examples, the tutorials are designed to help you develop your own model simulation experiments, in the following four stages:\n\nTuning the sensitivity to fishing\nFirst, we will explore how sensitive your model is to the effects of fishing. As usual, we will start with an example system. We will show how the reproduction parameters influence how sensitive the model is to changes in mortality. We can make adjustments and refinements at this step if the model does not produce realistic responses to fishing intensity.\nSimulating and examining changes\nOnce the sensitivity to fishing is examined, we can assess how the model responds to changes in fishing through time. This step involves looking a bot closer at the fishing parameters in mizer and setting up a time-varying fishing effort. In this part we will start with an example that will show you how to run a model through a time series and compare it with data. You will then be able to explore how changes in reproduction, fishing and other parameters affect response to fishing through time.\nRun your own scenarios\nIn this tutorial we will explore how to set up your own fishing experiments and scenarios. These can be scenarios that compare different levels of fishing or a comparison of different future scenario projections, where fishing changes through time.\nChanging resources\nIn this section we will examine whether the effects of fishing are affected by different parameters in the model that are affected by the environment, such as the amount of food available at the base of the food web, which is set by the amount of resources you have added in your model. For those wishing to go further, we will provide you with information on how you could take this example further by forcing the models with climate change scenarios through time.\n\n#To get your worksheet repository for this week, follow this link: #https://classroom.github.com/xxx"
  },
  {
    "objectID": "use/tune-sensitivity.html",
    "href": "use/tune-sensitivity.html",
    "title": "Tune sensitivity",
    "section": "",
    "text": "You might remember from week 1 that the reproduction parameters can influence how species react to dynamical changes in mortality in the system. The goal of this tutorial is to explore how the species in your model respond to fishing, to ensure that the reproduction parameters are reasonable when you incorporate fishing dynamics into your model.\nFirst, we will install the same packages we used last week. Additionally, we will use the mizerHowTo package which contains some handy functions for this week’s workshops.\n\n\nSkipping install of 'mizerExperimental' from a github remote, the SHA1 (aa423f9b) has not changed since last install.\n  Use `force = TRUE` to force installation\n\n\nLoading required package: mizer\n\n\n\nAttaching package: 'mizerExperimental'\n\n\nThe following objects are masked from 'package:mizer':\n\n    calibrateYield, plotDataFrame, scaleModel, steady\n\n\nSkipping install of 'mizerMR' from a github remote, the SHA1 (e36acb94) has not changed since last install.\n  Use `force = TRUE` to force installation\n\n\n\nAttaching package: 'mizerMR'\n\n\nThe following objects are masked from 'package:mizerExperimental':\n\n    plotlyResourcePred, plotResourcePred\n\n\nThe following objects are masked from 'package:mizer':\n\n    animateSpectra, finalNResource, getDiet, initialNResource,\n    initialNResource<-, NResource, plotDiet, plotlySpectra,\n    plotSpectra, resource_capacity, resource_capacity<-,\n    resource_params, resource_params<-, resource_rate, resource_rate<-\n\n\nSkipping install of 'mizerHowTo' from a github remote, the SHA1 (16693771) has not changed since last install.\n  Use `force = TRUE` to force installation\n\n\nLoading required package: ggplot2\n\n\nLoading required package: dplyr\n\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\nLoading required package: parallel\n\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ tibble  3.1.8     ✔ purrr   0.3.4\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\n✔ readr   2.1.2     ✔ forcats 0.5.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\nWe will start with a new example model, a preliminary model for the Heard and McDonald Islands Patagonian toothfish longline fishery. While this is not a coastal or inland fishery, it is relatively data poor.\nThe model has been calibrated using time-averaged data to achieve coexistence and a steady state. This followed a similar approach as the one you used last week. Feel free to use this model, the Curonian Lagoon model, or your own model in the scenarios you develop later on.\nFirst, let’s read in the param object for this model, which contains the steady state information. The file is called params10.rmd, showing there was already an iterative process involved with checking, refining , re-calibrating and re-checking the model, using time-averaged biomass data and the diagnostic plots below.\n\nsim <- readRDS(\"toothfish/params10.RDS\")\nparams <- sim@params\nplotBiomassObservedVsModelCustom(params,ratio = T)\n\n\n\nplotGrowthCurves(sim,species_panel = T)\n\n\n\nplotlySpectra(sim, power = 2, total = TRUE)\n\n\n\n\nplotDiet2(sim)\n\nWarning: Removed 3266 rows containing missing values (position_stack).\n\n\n\n\n\nThis model is focussed on Patagonian toothfish and key prey species in the longline fishery.\nFor this model, we had the following main criteria for our project:\n\nModelled biomasses were within +/- 10-20% of the observed biomasses.\nUnfished normalised biomass size spectrum slope that is negative and close to -1\nGrowth curves approximated the von Bertalanffy growth curves for each species.\nToothfish diet captured dietary changes with body size and became more piscivorous at larger sizes.\nRecruitment parameters ensured single-species yield curves were dome-shaped, as expected by theory.\nThe modeled catches through time captured the trends in the reported catches through time.\n\nWe can see from these plots that we still have more work to do with refining the model. The size at age for some species seem much higher than the empirical parameters, feeding level of near satiation for all species and the biomass of some species is much higher than the data. However size-at-age data are typically highly variable. So, let’s set some of those issues aside for now.\nThe last two of the criteria above require examining how the system reacts to changes in fishing. In the next tutorial we will look at changes though time. Here, we will examine how the reproduction parameters produce reasonable yield curves. How do we do this?\nFirst, let’s take a look at how fishing is set up in this model.\n\ngear_params(params)\n\n\n\n  \n\n\n\nCurrently we can see there is one gear - longline - which has a knife_edge selectivity function that starts fishing at very large sizes of toothfish only (knife_edge_size=2722 g). The size selectivity was derived from the length distribution of catches from the long-line fisheries data. If your model does not yet include fishing, you can set up your own fishing gear using the gear_params() function and by following the example here.\nWe can see that the initial_effort has been set to 1 and the catchability has been set to a very low number: 7e-07. This shows the model has been calibrated with a very low level of fishing mortality.\n\nAs mentioned before the calibrated reproduction parameters affect how species respond to fishing intensity. To get an idea on how the model has been calibrated in terms of reproduction, let’s check the reproduction level.\n\nreproduction_level <- getReproductionLevel(params)\nreproduction_level\n\n    D.ele     C.gun     C.rhi     L.squ     M.cam     B.eat     B.irr     G.acu \n0.9998035 0.9994817 0.9991013 0.9426729 0.8279399 0.9999131 0.9996038 0.9996273 \n    B.mur \n0.9777815 \n\nspecies_params(params)[, c(\"erepro\", \"R_max\")]\n\n\n\n  \n\n\n\nWe can see that the erepro and R_max values have been estimated. Let’s see how close the model catches are form the observed.\n\nplotYieldObservedVsModel(params, ratio=T)\n\nThe following species are not being fished in your model and will not be included in the plot: C.gun, C.rhi, L.squ, M.cam, B.eat, B.irr, G.acu, B.mur.\n\n\n\n\n\nThe modeled yields looks pretty close to the observed.\nNow, let’s take a look at how this combination of parameters influences how toothfish respond to different levels of fishing. These are not temporal dynamics with fishing changing through time yet, each level run at steady state.\n\nplotYieldVsF(params,species=\"D.ele\",no_steps=50,F_max=2)\n\nConvergence was achieved in 1.5 years.\n\n\nConvergence was achieved in 25.5 years.\n\n\nConvergence was achieved in 24 years.\n\n\nConvergence was achieved in 22.5 years.\n\n\nConvergence was achieved in 21 years.\n\n\nConvergence was achieved in 18 years.\n\n\nConvergence was achieved in 15 years.\n\n\nConvergence was achieved in 13.5 years.\n\n\nConvergence was achieved in 12 years.\n\n\nConvergence was achieved in 10.5 years.\nConvergence was achieved in 10.5 years.\nConvergence was achieved in 10.5 years.\nConvergence was achieved in 10.5 years.\n\n\nConvergence was achieved in 9 years.\nConvergence was achieved in 9 years.\nConvergence was achieved in 9 years.\n\n\nConvergence was achieved in 7.5 years.\nConvergence was achieved in 7.5 years.\n\n\nConvergence was achieved in 6 years.\nConvergence was achieved in 6 years.\nConvergence was achieved in 6 years.\nConvergence was achieved in 6 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 6 years.\n\n\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\n\n\n# Fmsy around 0.4 for toothfish\n\nNext let’s see what happens if we adjust the reproduction parameters. If you would like to read further about this step see Gustav’s blogpost here.\n\nparams2 <- setBevertonHolt(params, reproduction_level = 0.85)\n\nplotBevertonHolt2(params, params2, \"D.ele\")\n\nWarning: Removed 94 row(s) containing missing values (geom_path).\n\n\n\n\nsim2 <- project(params2, t_max = 20)\nplotBiomass(sim2)\n\n\n\nplotYieldVsF(params,species=\"D.ele\",no_steps=50,F_max=2)\n\nConvergence was achieved in 1.5 years.\n\n\nConvergence was achieved in 25.5 years.\n\n\nConvergence was achieved in 24 years.\n\n\nConvergence was achieved in 22.5 years.\n\n\nConvergence was achieved in 21 years.\n\n\nConvergence was achieved in 18 years.\n\n\nConvergence was achieved in 15 years.\n\n\nConvergence was achieved in 13.5 years.\n\n\nConvergence was achieved in 12 years.\n\n\nConvergence was achieved in 10.5 years.\nConvergence was achieved in 10.5 years.\nConvergence was achieved in 10.5 years.\nConvergence was achieved in 10.5 years.\n\n\nConvergence was achieved in 9 years.\nConvergence was achieved in 9 years.\nConvergence was achieved in 9 years.\n\n\nConvergence was achieved in 7.5 years.\nConvergence was achieved in 7.5 years.\n\n\nConvergence was achieved in 6 years.\nConvergence was achieved in 6 years.\nConvergence was achieved in 6 years.\nConvergence was achieved in 6 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 6 years.\n\n\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\nConvergence was achieved in 3 years.\n\n\nConvergence was achieved in 4.5 years.\n\n\n\n\nplotYieldVsF(params2,species=\"D.ele\",no_steps=50,F_max=2)\n\nConvergence was achieved in 1.5 years.\n\n\nConvergence was achieved in 25.5 years.\n\n\nConvergence was achieved in 24 years.\n\n\nConvergence was achieved in 22.5 years.\n\n\nConvergence was achieved in 21 years.\n\n\nConvergence was achieved in 15 years.\n\n\nConvergence was achieved in 13.5 years.\n\n\nConvergence was achieved in 12 years.\n\n\nConvergence was achieved in 10.5 years.\n\n\nConvergence was achieved in 12 years.\n\n\nConvergence was achieved in 18 years.\n\n\nSimulation run did not converge after 99 years. Value returned by the distance function was: 0.203198712320825\n\n\nSimulation run did not converge after 99 years. Value returned by the distance function was: 0.738202569327246\n\n\nSimulation run did not converge after 99 years. Value returned by the distance function was: 1.49094836056093\n\n\nSimulation run did not converge after 99 years. Value returned by the distance function was: 2.487705270807\n\n\nSimulation run did not converge after 99 years. Value returned by the distance function was: 3.71837506860701\n\n\nSimulation run did not converge after 99 years. Value returned by the distance function was: 5.17268081594456\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 15 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\nWarning in projectToSteady(params, t_max = 100, return_sim = TRUE, progress_bar\n= FALSE, : D.ele are going extinct.\n\n\nSimulation run did not converge after 1.5 years. Value returned by the distance function was: NA\n\n\n\n\n\nThis shows that altering the level of density-dependence in recruitment affects how sensitive toothfish (D.ele for short) are to fishing. The first model would enable toothfish to sustain (at equilbrium) much higher levels of fishing before it collapses.\n\nExplore changes in reproduction level using your model (or the curonian lagoon model). How does changing the reproduction level affect how closely your modeled biomasses and catches match the observations?"
  },
  {
    "objectID": "use/tune-sensitivity.html#comparing-ecosystem-states-effects-of-fishing-relative-to-an-unfished-state",
    "href": "use/tune-sensitivity.html#comparing-ecosystem-states-effects-of-fishing-relative-to-an-unfished-state",
    "title": "Tune sensitivity",
    "section": "Comparing ecosystem states: effects of fishing relative to an unfished state",
    "text": "Comparing ecosystem states: effects of fishing relative to an unfished state\nTo be able to assess the wider ecosystem impacts of fishing in the community we need to understand how changes compare to an unfished state. We can use the above model unfished steady state with effort = 0 to do this combined with some functions to calculate ecological indicators.\nLet’s compare the current size spectra (with fishing) to the unfished size spectra to assess whether there is any evidence of a size-structured trophic cascade due to fishing.\n\nsim0 <- projectToSteady(params, effort = 0, return_sim = TRUE, t_max = 200)\n\nConvergence was achieved in 1.5 years.\n\nsim <- projectToSteady(params, effort = 1, return_sim = TRUE, t_max = 200)\n\nConvergence was achieved in 1.5 years.\n\nplot_relative_biomass(sim0, sim)\n\n\n\n\nHere we can see the effect of the reduction in large sized individuals of heavily fished species on the other sizes and species in the model, relative to the unfished steady state.\nThe abundance of some (but not all) of the smaller to medium sizes of prey are a lot higher when their larger predators are removed (note the logarithmic scale). Sprat looks to be much lower.\nWe can do the same with Biomass to see when, if any, of the species collapse. For simplicity, we use < 0.1 of B/B_unfished as a proxy for a reference point for population collapse. We can add other reference points to this kind of plot, for example a simple rule of thumb for B_msy could be 0.5*B_unfished.\n\n\n\n\n\nWe can see there is very low impact on the biomass of each group, due to the very small rates of fishing mortality being inflicted on toothfish.\nExercise\nHow do the biomasses change under your scenarios of fishing mortality when the reproduction level is lowered?\nSummary"
  }
]