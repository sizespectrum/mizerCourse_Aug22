[
  {
    "objectID": "use/fishing-scenarios.html",
    "href": "use/fishing-scenarios.html",
    "title": "Using a model to explore fishing scenarios",
    "section": "",
    "text": "Mizer is a tool that can be used to simulate a dynamic size spectrum in a marine ecosystem, subject to changes through time, such as fishing pressure. It is a dynamic multi-species model with emergent growth, reproduction and biomass, so it allows us to better understand how changes in fishing mortality can affect the entire ecosystem.\nIn the previous week we have been focused on the steady state of the model. Now we are ready to make changes through time, which means that the ecosystem will move away from the tuned steady state.\n\n\n\n\n\n\nNote\n\n\n\nThere are two ways how we could explore scenarios:\nThe first way is to use our existing calibrated model as a starting point, impose new conditions, and then run to the new steady state and compare this to the original steady state. This is how many modelling studies are done.\nThe second way is to impose a time series of changes, where change in conditions happens slowly over a certain time. In this second case we would be interested in transient dynamics, or the time series of change. So we would analyse how conditions change through time.\nThe first way is easier and more common in modelling studies, because it is easier to compare steady states than to compare time series, and because the steady state shows properties that can be sustained in the long run. But both types of exploration can be performed in mizer and have been used in various examples, as you have heard in Julia Blanchard’s lecture.\n\n\nFor explorations in this tutorial we will be using our mizer model for the Curonian lagoon. We will load the model from our previous tutorial where we tuned reproduction level of each species.\n\nremotes::install_github(\"sizespectrum/mizerExperimental\", ref = \"tuneMR\")\nlibrary(mizerExperimental)\nremotes::install_github(\"sizespectrum/mizerMR\")\nlibrary(mizerMR)\nlibrary(tidyverse)\n\n# Load tuned model with original selectivity\ncm <- readParams(\"cur_model_resilient.rds\")\n\nMizer allows complicated setups of multiple fishing gears and selectivities, but we will start with a few simple scenarios and give references for further reading to users who want to explore more."
  },
  {
    "objectID": "use/fishing-scenarios.html#scenario-1-change-fishing-effort",
    "href": "use/fishing-scenarios.html#scenario-1-change-fishing-effort",
    "title": "Using a model to explore fishing scenarios",
    "section": "Scenario 1: Change fishing effort",
    "text": "Scenario 1: Change fishing effort\nThe first option most users want to explore is to see what happens if we start fishing more or if we reduce fishing mortality. We will use our Curonian model with tuned reproduction and change the total fishing effort. We will run the simulation with the changed effort until it again settles down to a steady state and then compare the resulting state to the original state.\nWe remind ourselves of the current fishing effort to which we tuned the model in week 2:\n\ninitial_effort(cm)\n\nMain \n 0.3 \n\n\nWe now simulate the result of doubling the fishing effort.\n\nsim_double_effort <- project(cm, effort = 0.6, t_max = 30)\n\nWe assigned the resulting MizerSim object to the variable sim_double_effort. Our convention is to include sim_ in the variable name when we assign a MizerSim object.\nWe can now analyse the time series contained in that MizerSim object. For example we can look at how the species biomasses changed over time:\n\nplotlyBiomass(sim_double_effort)\n\n\n\n\n\nThe changes in biomass can be seen more clearly if we plot the relative change compared to the initial biomass:\n\nplotlyBiomassRelative(sim_double_effort)\n\n\n\n\n\nWe can see that, surprisingly, after doubling fishing effort on all species biomasses of breams, roach, vimba, perch and carassius increased rather than decreased!\nTo understand how that is possible, we have to look at how the spectra have changed. After all mizer is all about changes at size. Looking at overall biomasses does not tell use about size dynamics. We can compare the spectra using the plotSpectra2() function:\n\nplotSpectra2(sim_double_effort, 'double', cm, 'same', power = 2)\n\n\n\n\nAgain, the changes are more visible if we plot relative change with respect to the initial spectra:\n\nplotlySpectraRelative(cm, sim_double_effort)\n\nWarning: `gather_()` was deprecated in tidyr 1.2.0.\nPlease use `gather()` instead.\nThis warning is displayed once every 8 hours.\nCall `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\n\n\n\n\n\n\nFishermen of course are less interested in the total biomass and more in the fisheries yield. The time series of yields over time is:\n\nplotlyYield(sim_double_effort)\n\n\n\n\n\nAnd again we look at the relative change over time. The plotlyYieldRelative() function needs also the original MizerParams object cm to be able to calculate the yield in the original model.\n\nplotlyYieldRelative(sim_double_effort, cm)\n\n\n\n\n\nYields for all but predator_fish species increased when the fishing effort was doubled. The initial increase by 100% is because doubling the fishing mortality will give double the yield until the fish populations are affected by the increased fishing mortality.\nLet’s see what happens if we triple the effort on all species.\n\nsim_tripple_effort <- project(cm, effort = 0.9, t_max = 30)\n\nplotlyYieldRelative(sim_tripple_effort, cm)\n\n\n\n\n\nNow the yield on perch increased 8 times and for roach 12 times! This is both because tripling fishing mortality on all species, doubled perch and roach biomasses, and then by tripling the effort we are catching more of them. Let’s look at the change in the spectra again.\n\nplotlySpectraRelative(cm, sim_tripple_effort)\n\n\n\n\n\nNow the change is even more evident. Large individuals of pikeperch and predator_fish are greatly reduced, but there are a lot more adult perch, burbot and all sizes of roach. As a result ruffe and small fish are slightly reduced."
  },
  {
    "objectID": "use/fishing-scenarios.html#scenario-2-change-fishing-on-one-species-only",
    "href": "use/fishing-scenarios.html#scenario-2-change-fishing-on-one-species-only",
    "title": "Using a model to explore fishing scenarios",
    "section": "Scenario 2: Change fishing on one species only",
    "text": "Scenario 2: Change fishing on one species only\nPreviously we saw that when effort changed on all species it was impossible to know what is driving change in total biomasses and yields - fishing or species interactions. Clearly, it was both, since in a single species model we would not get more biomass with increased fishing mortality. But to separate this effect better, let’s now change fishing on one species only. We will do that on pikeperch. Let’s double its fishing mortality and see how that affects the ecosystems. We will do that by doubling the catchability parameter in the gear_params dataframe.\n\n# Make a copy of the model in a new variable\ncm_fishPikeperch <- cm\n# Change the catchability of pikeperch\ngear_params(cm_fishPikeperch)[\"pikeperch, Main\", \"catchability\"] <- 2\n# Here \"Main\" means the main gear, because mizer can have multiple gears\n\nNow let’s project with same overall effort and see what happens. Because pikeperch catchability has doubled, its fishing mortality has doubled.\n\nsim_Pikeperch <- project(cm_fishPikeperch, t_max = 30)\n\n\nplotlyBiomassRelative(sim_Pikeperch)\n\n\n\n\n\nWe can see that just by changing fishing mortality on one important species, we have triggered a trophic cascade and changed biomasses of all other species. Most other species increased in biomass. Only ruffe and smallfish decreased, since they are now more heavily predated by intermediate sized fish. You can use plotDeath() and plotSpectra2() to explore this further.\nLet us also look at the change in yields:\n\nplotlyYieldRelative(sim_Pikeperch, cm)\n\n\n\n\n\nBy fishing pikeperch more intensively, we decreased the yield of pikeperch, but we increased biomasses and yields on nearly all other species. Now we know that yields of other species really changed due to species interactions, since we are fishing them with same parameters as before.\nWe see that biomasses are still changes after 30 years, so we can run project for a longer time and see how the trajectories continue:\n\nsim_Pikeperch <- project(cm_fishPikeperch, t_max = 100)\nplotlyBiomassRelative(sim_Pikeperch)\n\n\n\n\n\nWe can see that pikeperch and perch took a while to stabilise to a new equilibrium."
  },
  {
    "objectID": "use/fishing-scenarios.html#scenario-3-increase-gear-mesh-size",
    "href": "use/fishing-scenarios.html#scenario-3-increase-gear-mesh-size",
    "title": "Using a model to explore fishing scenarios",
    "section": "Scenario 3: Increase gear mesh size",
    "text": "Scenario 3: Increase gear mesh size\nOne common policy in fisheries management is to increase mesh sizes of commercial gears, with the goal of protecting young fish and decreasing overall impact on the stock. Let’s see how this can work in a multi-species ecosystem. Our fisheries managers are concerned about predator_fish and increased minimum size limit for this species. This we can achieve by changing it’s gear selectivity and projecting with the same effort. Currently the selectivity parameters for predator_fish are\n\ngear_params(cm)[\"predator_fish, Main\", c(\"l50\", \"l25\")]\n\n\n\n  \n\n\n\nWe will increase L50 for this species from 30 to 40 and keep the slope of size selectivity same (3 cm difference between L50 and L25).\n\n# Make a new params object \ncm_sel <- cm\n# change selectivity parameters\ngear_params(cm_sel)[\"predator_fish, Main\", \"l50\"] <- 40\ngear_params(cm_sel)[\"predator_fish, Main\", \"l25\"] <- 37\n\nWe will project with unchanged fishing effort\n\nsim_largerMesh <- project(cm_sel, t_max = 30)\n\nWe again plot the relative change in biomass and in yield\n\nplotlyBiomassRelative(sim_largerMesh)\n\n\n\n\nplotlyYieldRelative(sim_largerMesh, cm)\n\n\n\n\n\nIndeed, increasing the mesh size helped the predator_fish. We can see that by changing gear selectivity but keeping the same effort, we increased predator_fish biomasses and yields. Yield is lower for predator_fish only in the first few years. Both managers and fishers are happy. Effect on other species yield is negligible.\nYou can now also play with changing size selectivities in your model and see which species react strongly, and which don’t. How does it affect other species in the ecosystem?"
  },
  {
    "objectID": "use/fishing-scenarios.html#scenario-4-protecting-large-fish",
    "href": "use/fishing-scenarios.html#scenario-4-protecting-large-fish",
    "title": "Using a model to explore fishing scenarios",
    "section": "Scenario 4: Protecting large fish",
    "text": "Scenario 4: Protecting large fish\nAnother management option that we often hear about is protecting largest fish from fishing. We can implement it in our model by changing selectivity curves from logistic to double_sigmoid (also sometimes called dome-shaped). This will reduce selectivity on largest individuals and will only select intermediate sized fish (if we set selectivity parameters properly). We will do that for all species, but this could also be set for only one species.\n\n# Create new gear parameter dataframe\ngear_double_sigmoid <- gear_params(cm)\n\n# Change all selectivity curves to double sigmoid (changing trawling to gillneting)\ngear_double_sigmoid$sel_func <- \"double_sigmoid_length\"\n\n# Set the right side of selectivity - i.e. the midpoint of the decreasing selectivity part of the curve, to 1.5 of the size at the left side\ngear_double_sigmoid$l50_right <- gear_double_sigmoid$l50 * 1.5\n# and the slope at 2cm difference\ngear_double_sigmoid$l25_right <- gear_double_sigmoid$l50_right + 2\n\n# Create new params object\ncm_gillnet <- cm\n# and set the new gear parameters\ngear_params(cm_gillnet) <- gear_double_sigmoid\n\n#check how the selectivity curves look \nplotlyFMort(cm_gillnet)\n\n\n\n\n\nWe notice how pikeperch selectivity curve is very shallow on the left side. This selection comes from tuneParams() stage, when we were trying to fit observed catch size distributions and overall catches. If we have better data on selectivity, we should use empirical data. But this is just a theoretical example.\nNow we will project with unchanged fishing effort and plot the resulting biomass over time.\n\nsim_gillnet <- project(cm_gillnet, t_max = 30)\n\nplotlyBiomass(sim_gillnet)\n\n\n\n\n\nWe can see that pikeperch does not cope. Even when we protect large pikeperch, its biomass goes down. This is because predator_fish benefited so greatly from this new selectivity and increased a lot and this had a knock down effect on other species.\nThe picture looks quite different for the yield.\n\nplotlyYieldRelative(sim_gillnet, cm)\n\n\n\n\n\nEven though predator_fish biomass increased so much, the yield on predator_fish decreased a lot. This is because we are not catching all the large fish that constitute most biomass.\nFishers would probably try to increase the fishing effort to try and get the same amount of yield. Let’s increase fishing mortality of predator fish and aim to get similar yield. We will need to increase catchability quite a lot to increase yield substantially. Let’s increase it 5 fold from 2 to 10.\n\ngear_params(cm_gillnet)[\"predator_fish, Main\", \"catchability\"] <- 10\n\nNow we run the simulations for 30 years and see if we could increase the yield to what we had previously with logistic selectivity and lower catchability\n\nsim_gillnet <- project(cm_gillnet, t_max = 30)\nplotlyYieldRelative(sim_gillnet, cm)\n\n\n\n\n\nEven after increasing catchability in the selected range 5 times we still only get 10% of the original yield for predator_fish. As a result predator_fish biomass increases and pikeperch biomass decreases, although less drastically:\n\nplotlyBiomassRelative(sim_gillnet)\n\n\n\n\n\nWe definitely want to look at changes in size spectra with this size based fishing example\n\nplotlySpectraRelative(cm, sim_gillnet)\n\n\n\n\n\nPay attention to how abundance of predator_fish in gillnet selectivity case at selected sizes drops sharply but then greatly increases once they are above the selected limit."
  },
  {
    "objectID": "use/fishing-scenarios.html#summary",
    "href": "use/fishing-scenarios.html#summary",
    "title": "Using a model to explore fishing scenarios",
    "section": "Summary",
    "text": "Summary\n\nMizer has lots of options to explore changes in gears, effort and fishing dynamics. In this tutorial we only explored basic options and found that even with very basic changes, the response of the ecosystem can be surprising and hard to fully understand.\nChanges in fishing on one species can have large effects on the biomasses and yields of other species.\nTo understand the trophic cascades that are triggered by changes in fishing one needs to look at the changes in the size spectra, not only at total biomasses.\nEcosystem responses to fishing scenarios will depend on how we set up species resilience to fishing. It is therefore important to interpret results carefully and explore alternative parameter combinations of reproductive level."
  },
  {
    "objectID": "use/tune-resilience.html",
    "href": "use/tune-resilience.html",
    "title": "Tune resilience",
    "section": "",
    "text": "In the previous week we tuned our model parameters so that the steady state of the model agrees with observed growth rates, average observed biomasses and with observed catches. We did not yet tune how sensitively our model reacts to changes away from its steady state. In particular, we did not tune how resilient the species are to fishing. We will do that in this tutorial.\nAs usual, we load the necessary packages\n\nremotes::install_github(\"sizespectrum/mizerExperimental\", ref = \"tuneMR\")\nremotes::install_github(\"sizespectrum/mizerMR\")\nlibrary(mizerExperimental)\nlibrary(mizerMR)\nlibrary(tidyverse)\n\nWe load our Curonian lagoon model that we saved after refining the model in the previous tutorial using the tuneParams() gadget.\n\ncm <- readParams(\"../build/cur_model_refined.rds\")"
  },
  {
    "objectID": "use/tune-resilience.html#reproduction-dynamics",
    "href": "use/tune-resilience.html#reproduction-dynamics",
    "title": "Tune resilience",
    "section": "Reproduction dynamics",
    "text": "Reproduction dynamics\nIn this tutorial we are going to look at an aspect of the model that has a big impact on the resilience of species to perturbations: the reproduction dynamics. In the tutorial on dynamics of size spectra in week 1 we briefly looked at how density dependence of reproduction can influence how species react to changes in mortality, such as from fishing. It might be good if you go back to that tutorial and remind yourself.\nWhen we built our models in week 2 we were not concerned about the parameters that specify the reproduction dynamics. We were only concerned with setting the resulting reproduction rate for each species to the levels that produced the observed species biomass. But because the parameters for the reproduction dynamics will affect how resilient species are, we will choose appropriate values for them in this tutorial.\n\n\n\n\n\n\nStock-recruitment relationships\n\n\n\nIn usual fisheries models, the reproduction dynamics is captured in the stock-recruitment relationship which relates the number of new recruits to the spawning stock biomass. Recruits are the fish that survive up to a size where they enter the fishery, which is the size at which the fisheries model starts modelling them.\nMizer is different in that it tracks individuals from the size at which they hatch (egg size) all the way to adult sizes. So much of the density dependence that is usually encoded in stock-recruitment relationships is modelled explicitly in mizer through the growth and mortality that larvae and juveniles experience until they reach recruitment size. So in mizer we specify the reproduction rate (the rate at which individuals enter the smallest size class) instead of the recruitment rate.\nThere are many density-dependent effects that mizer does not capture explicitly, like for example limits on the available spawning grounds. This additional density dependence is encoded in a non-linear relationship between the energy that a species invests into reproduction and the rate at which new individuals enter the smallest size class in the model, as we will now discuss.\n\n\nThere are several parameters and quantities that were introduced in that earlier tutorial that we would like to recall now:\n\nThe rate E_R at which a species invests energy into reproduction. We discussed how this depends on the species parameters in a section of the tutorial on single species spectra in the first week of the course. In standard fisheries models the energy invested is assumed to be proportional to the spawning stock biomass. In mizer the energy invested also depends on how much food is available for the spawning stock. But nevertheless you won’t go wrong too much if in your head you identify E_R as spawning stock biomass.\nThe parameter erepro describes the efficiency with which the energy that a species invests into reproduction is converted to eggs. Multiplying E_R by erepro and by the conversion factor from biomass to number of eggs gives the quantity that we called R_{di}: the rate of egg production. We also sometimes refer to R_{di} as the “density-independent reproduction rate”. The efficiency erepro can be quite small because a lot of the energy expended on reproduction goes not into the production of eggs but in associated processes, like for example migration to the spawning grounds.\nThe rate R_{dd} at which new individuals can enter the smallest size class in the model (usually this represents the hatching of eggs). This depends in a non-linear way on the rate R_{di} of egg production and therefore also non-linearly on the rate at E_R at which the species invests energy into reproduction. We therefore sometimes refer to this as the “density-dependent reproduction rate”.\nThe parameter R_max that gives the maximum rate at which individuals can join the smallest size class, no matter how much energy the species invests.\n\nThese concepts are nicely illustrated by the following figure that you saw earlier:\n\n\n\n\n\nThe black dot in the diagram is meant to represent the steady-state values for E_R and R_{dd}. The solid curves represents how the density-dependent reproduction rate R_{dd} depends on the rate E_R. Both the solid blue line and the solid black line go through the black dot, which means that they result in the same steady-state reproduction. They differ by the choice of the maximum reproduction rate R_max (the height of the dotted line) and the reproductive efficiency erepro (the slope of the dashed line representing R_{di}).\nWe can see in the diagram how, as E_R is changed, for example through a depletion of spawning stock biomass due to fishing, the resulting change in the reproduction rate R_{dd} is more pronounced along the solid black curve than along the blue curve. This is why an increase in R_{max} will make the species less resilient to fishing.\nNote how both R_max and erepro need to be changed at the same time in order for the resulting curve for the reproduction rate to still go through the black dot, i.e., in order not to change the reproduction rate in the steady state. As we discussed earlier, the function setBevertonHolt() automatically changes both parameters together in the correct manner. In that function we can specify the desired reproduction curve by specifying either R_max or erepro or the ratio between R_{dd} at steady state and R_{max}, which we refer to as the reproduction level.\nWe like to work with the reproduction level because it is a number between 0 and 1, where 0 means that the rate of reproduction increases in proportion to E_R and 1 means that the rate of reproduction is independent of E_R. The higher the value of the reproduction level the less impact a change in E_R will have on the species’ reproduction. Thus higher levels of the reproduction level make the species more resilient for example to fishing.\nAs usual, we load the necessary packages\n\nremotes::install_github(\"sizespectrum/mizerExperimental\", ref = \"tuneMR\")\nremotes::install_github(\"sizespectrum/mizerMR\")\nlibrary(mizerExperimental)\nlibrary(mizerMR)\nlibrary(tidyverse)\n\nWe load our Curonian lagoon model that we saved after refining the model in the previous tutorial using the tuneParams() gadget.\n\ncm <- readParams(\"../build/cur_model_refined.rds\")"
  },
  {
    "objectID": "use/tune-resilience.html#how-resilient-should-species-be",
    "href": "use/tune-resilience.html#how-resilient-should-species-be",
    "title": "Tune resilience",
    "section": "How resilient should species be?",
    "text": "How resilient should species be?\nWe will need to tune the reproduction level of each species to make sure that their response to fishing is reasonable. How do we know what is reasonable? It is not a straightforward question. We can start by consulting general fisheries models. You can read about the principles of basic fisheries surplus production models in this excellent book by Malcolm Haddon “Using R for Modelling and Quantitative Methods in Fisheries”.\nIn the simplest of these models, the population dynamics are specified in terms of a maximum population growth rate r (not to be confused with the maximum hatching rate R_max used in mizer) and a carrying capacity, which represents the unfished biomass level. Under these simplest standard assumptions about density dependence, maximum sustainable yield (MSY) is obtained when the stock is at 50% of the unfished biomass level. MSY is approximately r/4 \\cdot unfished biomass and the fishing mortality which gives this MSY is r/2. This fishing mortality is referred to as F_{MSY}. This means that if for example r = 0.5 then the peak of the yield curve should be at about F_{MSY} = 0.25. If unfished biomass is 1000 tons, MSY will be at 125 tons.\nWe usually do not know population growth rates r for our species, but we can look up estimates in the FishBase life-history tool section. Or we can use generic estimates which suggest r of 0.6-1.5 for high resilience species (Von Bertalanffy growth rate K>0.3, maturation age < 1, high fecundity) and r of 0.2-1 for medium resilience species. We reproduce the table from this reference here:\n\nWe had included the categorisation of our species in the species parameter dataframe in the resilience column.\n\nspecies_params(cm) |> select(resilience, funcgr)\n\n\n\n  \n\n\n\nThus according to the above discussion, we should expect an F_{MSY} between 0.3 and 0.75 for smallfish, between 0.1 and 0.5 for our benthivores and between 0.025 and 0.25 for the ominvores and predators. These values are derived from single species models with very different assumptions to those of ours, so they can only be used as very general guides.\nAlternatively, we can use Ken Andersen’s book and expectations for species with different asymptotic sizes, as estimated from trait-based models (where all species parameters are determined in terms of the asymptotic size) and when all species are fished with 50% selectivity at 5% of their asymptotic size. The panels below represents species with different asymptotic sizes: 333 g (top), 10 g (bottom left), and 10 kg (bottom right). The lines show yield (solid black lines), yield per recruit (dashed lines), spawning stock biomass (dark gray lines), and recruitment (light gray lines), all scaled by their maximum value. We will not deal with yield per recruit, so ignore the dashed lines. This figure shows that highest yields are expected at fishing mortality of about 0.3-0.5/year.\n\nIn this tutorial we will tune our model so that they give the maximum sustainable yield at the fishing mortalities that are in the range suggested by the table above, i.e. so that F_{MSY} = r/2 with r in the range given in the last row of that table. We are not saying that this is the only or best method."
  },
  {
    "objectID": "use/tune-resilience.html#constant-reproductive-efficiency",
    "href": "use/tune-resilience.html#constant-reproductive-efficiency",
    "title": "Tune resilience",
    "section": "Constant reproductive efficiency",
    "text": "Constant reproductive efficiency\nThe reproduction parameters in our model are not yet chosen sensibly, as we can see by looking at the current reproduction levels:\n\ngetReproductionLevel(cm)\n\n    smallfish         ruffe        breams         roach         vimba \n   0.32264652    0.02129403    0.00000000    0.52334987    0.00000000 \n    carassius         perch     pikeperch        burbot predator_fish \n   0.07675473    0.22022985    0.65493089    0.30352817    0.10223259 \n\n\nFor some species these reproduction levels are extremely low.\nWe need to decide what reproduction parameters we should set to start our tuning. We will follow the approach of Jacobsen et al. 2016 and initially set the reproductive efficiency erepro to the same value for all species.\nWe use the setBevertonHolt() function to set the values for erepro. That function automatically also adjusts the values for R_max to keep the steady state reproduction rate R_{dd} the same, as we discussed above.\nIf we try to set the value for erepro very low, the setBevertonHolt() function will issue a warning:\n\ncm <- setBevertonHolt(cm, erepro = 0.0001)\n\nWarning in setBevertonHolt(cm, erepro = 1e-04): For the following species\n`erepro` has been increased to the smallest possible value: erepro[ruffe] =\n0.000321; erepro[roach] = 0.000736; erepro[carassius] = 0.000311; erepro[perch]\n= 0.000177\n\n\nBecause we want all species to have the same value, we choose a value that is larger than those required. So we choose erepro = 0.001.\n\ncm <- setBevertonHolt(cm, erepro = 0.001)\nspecies_params(cm) |> select(erepro, R_max)\n\n\n\n  \n\n\n\nLet’s see what reproduction levels this gives:\n\ngetReproductionLevel(cm)\n\n    smallfish         ruffe        breams         roach         vimba \n    0.9460163     0.6794001     0.9040744     0.2642426     0.9185775 \n    carassius         perch     pikeperch        burbot predator_fish \n    0.6891149     0.8232825     0.9905353     0.9881604     0.9962368 \n\n\nRemember: the reproduction level is the ratio between RDD and R_max and can vary between 0 and 1. It tells us how close the actual reproduction (after applying density dependence) is to the theoretical maximum, set by R_max. So instead of using the getReproductionLevel() function we could also have done the calculation ourselves:\n\ngetRDD(cm) / species_params(cm)$R_max\n\n    smallfish         ruffe        breams         roach         vimba \n    0.9460163     0.6794001     0.9040744     0.2642426     0.9185775 \n    carassius         perch     pikeperch        burbot predator_fish \n    0.6891149     0.8232825     0.9905353     0.9881604     0.9962368 \n\n\nWe can also look how close the density dependent reproduction rate RDD is to the density independent reproduction rate RDI, which is the rate at which eggs are produced.\n\ngetRDI(cm) / getRDD(cm)\n\n    smallfish         ruffe        breams         roach         vimba \n    18.524101      3.119152     10.424749      1.359144     12.281619 \n    carassius         perch     pikeperch        burbot predator_fish \n     3.216623      5.658749    105.655800     84.462397    265.728307 \n\n\nThis tells us that many species can produce large amounts of eggs, but the actual reproduction is strongly capped by the R_max parameter."
  },
  {
    "objectID": "use/tune-resilience.html#tuning-resilience-to-fishing",
    "href": "use/tune-resilience.html#tuning-resilience-to-fishing",
    "title": "Tune resilience",
    "section": "Tuning resilience to fishing",
    "text": "Tuning resilience to fishing\nWe now want to adjust the reproduction levels so that the resilience of the species in our model matches expectations.\nSetting generic gear selectivity\nIf you have system specific data on how changes in fishing under system specific gear parameters change species biomasses, you should use these system specific details. We do not have such data for Curonian Lagoon, so we will explore species responses in general. For that purpose, for this exploration of the resilience of species, we set the gear parameters in such a way that all species are fished similarly.\nOur current gear parameters are set for a specific commercial fishery, which selects some species but does not catch smallfish and almost no ruffe. For smaller fish they target only adults and for largest fish they also target juveniles. Thus the fishing mortality this gear imposes on the different species is not suited to assess resilience equally for all species.\nTo tune the resilience of each species to extra mortality we will set catchability of all species to 1, so that effort values directly reflect fishing mortality. We will also set gear 50% selectivity to half the maturation length of each species and 25% selection to half the 25% maturation length.\nGear selectivity parameters are defined by length, so we will first convert w_mat and w_mat25 to length values.\n\nweight_to_length <- function(w, params) {\n    a <- species_params(params)$a\n    b <- species_params(params)$b\n    (w / a) ^ (1 / b)\n}\n\nl_mat = weight_to_length(species_params(cm)$w_mat, cm)\nl_25mat = weight_to_length(species_params(cm)$w_mat25, cm)\n\nWe now create a new gear parameter data frame with changed selectivity parameters:\n\n# We start with the current gear parameters\ngp <- gear_params(cm)\n# and update values in l50 and l25 columns\ngp$l50 <- l_mat / 2\ngp$l25 <- l_25mat / 2\n# and set all catchability to 1\ngp$catchability <- 1\n\nWe assign the model that uses these new gear parameters in a new variable cm_generic_gear so that we can keep the old model around.\n\ncm_generic_gear <- cm\n# Set new gear parameters for the new model \ngear_params(cm_generic_gear) <- gp\n\nLet’s look at the fishing mortality from the new gear:\n\nplotFMort(cm_generic_gear)\n\n\n\n\nAs always after having changed model parameters, we need to bring the model to steady state again.\n\ncm_generic_gear <- steady(cm_generic_gear)\n\nConvergence was achieved in 16.5 years.\n\n\nExploring yield curves\nTo measure the resilience of our species to fishing, we will change the fishing mortality for one species at a time and check how their yields, spawning-stock biomasses (SSB) and reproduction rate (RDD) change in response. We keep the fishing mortality for the other species fixed. For our selected species we run through a range of fishing mortalities between 0 and a maximum. For each fishing mortality we run the projection until the system has settled down to a new steady state. Then we calculates the yield, the spawning stock biomass SSB and the reproduction rate RDD in that steady state. After doing that for all fishing mortalities we can plot all the results in a graph. The plotYieldCurve() function does all that for us. Here we plot the yield curve for smallfish.\n\nplotYieldCurve(cm_generic_gear, species = \"smallfish\", F_max = 2)\n\n\n\n\nWe refer to the yield achieved in the steady state as the sustainable yield (SY) because because it can be sustained indefinitely. The sustainable yield for this species has a maximum (MSY) at a fishing mortality of about 0.8. We refer to this value as F_{MSY}. The small fish have a high resilience to fishing. This is close enough to expectations, so we judge that it is not necessar to make changes to the resource level of “smallfish”.\nNext we look at ruffe. This is classified as a medium resilience species, so we would like the F_{MSY} to be between 0.1 and 0.5.\n\nplotYieldCurve(cm_generic_gear, species = \"ruffe\", F_max = 1)\n\n\n\n\nWe see that the F_{MSY} is at about 0.4, so again we have no reason to change the reproduction level. We encourage you to investigate the yield curves of the other medium resilience species in a similar way.\n\n\n\n\n\n\nNote\n\n\n\nIf you run the above code yourself in your worksheet, you will notice that for some fishing mortalities, plotYieldCurve() gives a warning that convergence was not reached within the 99 years for which we ran the projection. This means that we stopped the simulation before the species had completely settled into a new stable state for that fishing level and thus the result for this specific fishing level is only approximate. But approximate values are good enough for our purpose. Often we find that it is the more extreme values of F where we do not get convergence.\n\n\nWe jump to the first low resilience species in our model: perch. As a low resilience species it should have an F_{MSY} below 0.25.\n\nplotYieldCurve(cm_generic_gear, species = \"perch\", F_max = 1)\n\n\n\n\nThe graph shows that the F_{MSY} is closer to 0.7. So we have reason to reduce the reproduction level for perch to make it less resilient. Its current reproduction level is\n\ngetReproductionLevel(cm_generic_gear)[\"perch\"]\n\n    perch \n0.8232825 \n\n\nWe do not know how much we need to reduce the reproduction level to get a sufficiently low F_{MSY}. We just try some values. Let’s try 0.3.\n\n# First we save current reproduction level into a vector \nrep_level <- getReproductionLevel(cm_generic_gear)\n# then we replace our species' reproduction level with a new value \nrep_level[\"perch\"] <- 0.3\n# and asign it back to the model \ncm_generic_gear <- setBevertonHolt(cm_generic_gear, \n                                   reproduction_level = rep_level)\n\n# and plot F curves again\nplotYieldCurve(cm_generic_gear, species = \"perch\", F_max = 1)\n\n\n\n\nWith that reproduction level of 0.3 for perch, its F_{MSY} is just below 0.5. So still too high for a low resilience species. But before we try to reduce the reproduction level further, let’s move on to the next species, pikeperch.\n\nplotYieldCurve(cm_generic_gear, species = \"pikeperch\", F_max = 1)\n\n\n\n\nIts F_{MSY} is also too high. So we also reduce the reproduction level of pikeperch.\n\nrep_level[\"pikeperch\"] <- 0.3\ncm_generic_gear <- setBevertonHolt(cm_generic_gear, \n                                   reproduction_level = rep_level)\nplotYieldCurve(cm_generic_gear, species = \"pikeperch\", F_max = 1)\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, :\npikeperch are going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, :\npikeperch are going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, :\npikeperch are going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, :\npikeperch are going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, :\npikeperch are going extinct.\n\n\n\n\n\nThe new F_{MSY} is at the upper end of what we would expect for a low-resilience species, but we judge this to be o.k.\n\n\n\n\n\n\nNote\n\n\n\nNotice that for high values of the fishing mortality plotYieldCurve() issues a warning to let us know that pikeperch will go extinct under this fishing mortality. That is fine.\n\n\nSo let’s return to perch. We previously saw that even with its reduced reproduction level it was still too resilient. Let’s look at its yield curve again:\n\nplotYieldCurve(cm_generic_gear, species = \"perch\", F_max = 1)\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : perch\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : perch\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : perch\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : perch\nare going extinct.\n\n\n\n\n\nAre you surprised? Compare this yield curve for perch with the one we plotted above. The F_{MSY} has dropped from close to 0.5 to closer to 0.15 even though we have not changed the reproduction level of perch. The reduction in the resilience of perch has been caused solely by the reduction in resilience of pikeperch.\n\n\n\n\n\n\nImportant\n\n\n\nWe have discovered above that the resilience of a species is influenced by the resilience of the other species. So resilience is a true multi-species effect.\n\n\nWe decide to increase the reproduction level for perch a bit again to make it slightly more resilient.\n\nrep_level[\"perch\"] <- 0.4\ncm_generic_gear <- setBevertonHolt(cm_generic_gear, reproduction_level = rep_level)\n\nBut we don’t have hard data on the resilience of our species, so these are judgement calls and we will be interested to see what choices you will make.\nYou are encouraged to go through all the species and check that their resilience looks o.k.\nSet new reproduction levels\nAbove we studied the resilience of species to changes in their mortality imposed by an artificial fishing gear. We used guidance from a classification of species into resilience classes and the expected F_{MSY} derived from very simple single-species models to adjust the reproduction levels for our species. Now we will use those reproduction levels in our model with the original gear parameters.\n\ncm <- setBevertonHolt(cm, reproduction_level = rep_level)\n\nLet’s plot the yield curve for one of the species that is caught commercially: breams. On the left we show the yield curve for the commercial yield, on the right the yield curve for our generic gear that we used for tuning the reproduction level.\n\n# Yield curve with the commercial gear\nplotYieldCurve(cm, species = \"breams\", F_max = 1)\n# Yield curve with generic gear\nplotYieldCurve(cm_generic_gear, species = \"breams\", F_max = 1)\n\n\n\n\n\nCommercial\n\n\n\n\n\n\nGeneric\n\n\n\n\n\n\nWhy the difference? Let’s look how the original gear parameters differ from our generic set\n\nc(l_mat = l_mat[3], \n  l50_commercial = gear_params(cm)$l50[3],\n  l50_generic = gear_params(cm_generic_gear)$l50[3])\n\n         l_mat l50_commercial    l50_generic \n      21.98905       35.70000       10.99453 \n\n\nWe can see that with the commercial gear parameters, selectivity starts much later, so we are only catching the largest individuals. Therefore the species can sustain a much higher fishing mortality for those selected individuals, because the population can sustain itself even if these large individuals are fished away.\nYou are encouraged to look at the yield curves for other species when using the commercial gear.\nFinally we save our model with tuned resilience to disk for use in the next tutorial.\n\nsaveParams(cm, \"cur_model_resilient.rds\")"
  },
  {
    "objectID": "use/tune-resilience.html#summary",
    "href": "use/tune-resilience.html#summary",
    "title": "Tune resilience",
    "section": "Summary",
    "text": "Summary\n\nIdentifying an appropriate reproduction level for our model species is very important, because the reproduction level will determine a species’ resilience to fishing.\nTo judge whether a reproduction level is appropriate, we estimate the fishing mortality that will give maximum sustainable yield (F_{MSY}). We use general fisheries and size ecology theory to get expected F_{MSY} values for species with different life history parameters. Naturally, these are just approximate estimates, but they might be good enough for our purposes. Nevertheless, it is important to explore how our study conclusions might be affected by changes in species reproduction level.\nWhen we explore F_{MSY} for a species it is important to think about the gear selectivity that is used to impose fishing. If selectivity is such that small and large individuals are captured, resulting F_{MSY} will be lower.\nSpecies resilience to fishing is a true multi-species phenomenon. If we change the reproduction level of one species it can affect the resilience of other species. So when we have chosen a set of reproduction levels, we need to run again through all species to check that their resilience is as expected."
  },
  {
    "objectID": "use/change-resources.html",
    "href": "use/change-resources.html",
    "title": "Change resources",
    "section": "",
    "text": "Mizer can be used to explore the consequences of climate change on aquatic ecosystems and fisheries. One of the major effects that climate change is having on aquatic ecosystems is a change in plankton and benthos abundance and size structure. However, responses in resources are highly uncertain and variable and predictions are difficult. For plankton we can use satellite observations of chlorophyl A and earth system models to assess past changes and aim to predict the future. Benthos changes also are likely having large impacts on shallow water ecosystems, but in many cases we have almost no empirical data on how much change is happening. Nevertheless we might want to explore the potential effect of these changes on the rest of aquatic food webs and on our fisheries. This is what we are going to do in this tutorial.\nAs usual we install and load libraries and also load the parameter file from the first tutorial, where we tuned the reproduction parameters.\n\nremotes::install_github(\"sizespectrum/mizerExperimental\", ref = \"tuneMR\")\nlibrary(mizerExperimental)\nremotes::install_github(\"sizespectrum/mizerMR\")\nlibrary(mizerMR)\nlibrary(tidyverse)\n\n# Load tuned model with original selectivity\ncm <- readParams(\"cur_model_resilient.rds\")"
  },
  {
    "objectID": "prepare/use-git-and-github.html",
    "href": "prepare/use-git-and-github.html",
    "title": "Use Git and GitHub",
    "section": "",
    "text": "In this course we will collaborate via Git and GitHub. This means that if you have not used these tools before, then you will have to learn some new concepts and get used to a particular workflow. The investment of your time will more than pay off. Developing your research code with Git and GitHub has great advantages, and it’ll be great if this course gets you hooked on these tools. The use we make of Git and GitHub in this course is relatively simple, so it may be the perfect gateway drug.\nWe’ll start by first introducing some of the ideas theoretically, but then we will also show what the workflow looks like in practice. We will only scratch the surface, if you want to go deeper then Happy Git and GitHub for the useR is a useful resource."
  },
  {
    "objectID": "prepare/use-git-and-github.html#theory",
    "href": "prepare/use-git-and-github.html#theory",
    "title": "Use Git and GitHub",
    "section": "Theory",
    "text": "Theory\nGit\nGit is a distributed version control system. So we will start by explaining the “version control” and the “distributed”. We’ll typeset typical Git terminology in bold.\nVersion control means that while you are working on your code or data files you can keep track of all the changes you are making. You can then later review the history of changes and, if necessary, revert to earlier versions. You may say that any cloud storage service like Google Drive or Dropbox does that as well, but there are important differences that we will now discuss.\n\nGit keeps the repository with all your changes on your local computer. The version control does not rely on an internet connection.\nYou explicitly say when you want a batch of changes to be stored in the repository. Saving changes to the files in your local file area does not yet modify the repository. You have to make a so-called commit to commit the changes you want to the repository.\nTypically you will add a commit message that summarises briefly what the changes are about. This makes it much easier to understand the development of your code later on.\n\nSo Git provides you a full control of creating points at which you want to save your code and documents to your repository. The commit messages you add can be very detailed or short. Their goal is for you and your collaborators to know what has been changed between different commit steps.\nDistributed means that the repository typically does not reside only on a single computer. There can be clones of the repository on many other computers. For example, you might want your collaborators to have a copy of the repository for a common project that you are working on jointly. They can make commits to their clone of the repository in the same way you can make commits to yours.\nEven if you only intend to work on your code alone, you may want to have copies of it on all the computers you occasionally work at and you will then want to be able to commit changes from any of those computers and pick up those changes from any other computer. So below when we speak of your “collaborator”, that collaborator could be yourself on another computer.\nFrom time to time you will want to merge the changes from one clone to another to have a new common version that incorporates changes by all collaborators. For that there needs to be some communication via the internet, facilitated by a Git server.\nGitHub\nGitHub is a service that hosts a clone of your repository on your account and runs a Git server, so that you and your collaborators do not have to run your own Git servers. Instead you can push any commits that you made into your local Git repository to the GitHub clone and then your collaborators can pull those changes to their clone.\nSo with Git and GitHub we have a very different workflow than what you get when you collaborate using for example a Google Drive folder. There are more steps before your collaborator sees your changes, namely:\n\nyou save your code changes on your computer to the directory that is associated with the git repository,\nyou select or stage which of your changed code files you want to commit to your local repository,\nyou commit those selected changes to your repository with a commit message,\nyou push your commits to your online GitHub repository,\nyour collaborators pull your commits from GitHub,\nthese commits automatically get merged into their clone,\nthe changed files are checked out from their clone into the corresponding directory on their local computer drive.\n\nThere are circumstances where the standard workflow fails. If you attempt to pull commits from GitHub that change files that you have also modified locally but not yet committed, then the pull will fail with an error message. If you and a collaborator independently made commits to your respective clones that touched the same lines of code then there may be merge conflicts that need to be resolved. If something like this happens to you then congratulations: you have arrived in more advanced Git territory than we will discuss in this tutorial. If at some point during the course something like this happens to you, let us know by posting a comment and we or some git-savy participant will give advice.\nThis more involved workflow takes a bit of getting used to, but is definitely the best way to work on code and data. If you follow the guidelines about committing your code changes regularly you will easily go back to earlier versions of your code if you need to, work with multiple people on the same code development, return to old coding projects that need reviewing, and be a part of open and reproducible science. So next you will get to try this out in practice."
  },
  {
    "objectID": "prepare/use-git-and-github.html#practice",
    "href": "prepare/use-git-and-github.html#practice",
    "title": "Use Git and GitHub",
    "section": "Practice",
    "text": "Practice\nFor each week of this course you will get a Git repository with worksheets for you to complete. This repository will be set up for you on GitHub by GitHub classroom. You will clone that repository to your computer and then commit your work to that repository and push it back to GitHub. This gives the course leaders a chance to see your work and to comment on it. These repositories will be private repositories, visible only to you and the course leaders Asta and Gustav and to Romain who provides technological support for the course. Below you will get a preparatory repository (also private) on which you can practice the workflow.\nIf you do not yet have an account on GitHub, please go there now and sign up. If you do have an account, please also go there and sign in.\nConnect RStudio to GitHub\nWe will be interacting with Git and GitHub via RStudio. This just requires some initial setup but will be very convenient from then on. Of course, if you are already using GitHub from within RStudio, then you can skip the steps below that you have gone through on your computer in the past.\nRStudio needs a personal access token for accessing GitHub. The following command will bring you to the GitHub webpage that creates that personal access token:\n\nusethis::create_github_token()\n\n\n\n\n\nYou can edit the Note to something like “mizer course” or whatever will remind you later what this was for. You can leave the rest of the form as it is and scroll down to the bottom and press the “Generate token” button. That will lead you to a page that displays your new token:\n\n\n\n\nLeave this page open for now and return to RStudio and issue the command\n\ngitcreds::gitcreds_set()\n\nThis will prompt you to enter your token. Go back to the webpage with your token and copy the token to your clipboard. Go back to RStudio and paste in that token and press Enter. That completes the setup. You will not have to do this again on this computer, but if you switch to a new computer, you will repeat the above. It is a good idea to save this token somewhere safe, in case you get prompted to enter it again.\nIf you run into difficulties with the above, please post about it in the comments section at the bottom of this page. If you want to dig in deeper yourself, you can take a look at the troubleshooting section in “Happy Git and GitHub for the useR”. But even if you manage to solve some problem yourself, please let us know about it in the comments.\nCreate repository\nTo create your practice repository, please follow the following link:\nhttps://classroom.github.com/a/Fc-YtAIb\nOnce you are logged into GitHub, this should bring you to a screen asking you to accept an assignment.\n\n\n\n\nPlease click on “Accept the assignment”. This will first tell you that your repository is being prepared and that you should refresh the page in your browser.\n\n\n\n\nWhen you hit the refresh button on your browser after just a short moment, you should see a page with a URL for your new repository on GitHub.\n\n\n\n\nPlease follow that URL to your repository’s home page. This page displays the README at the bottom. There you for example find a points bar where you accumulate points as you complete the exercises in the worksheet. We are now interested in the big green “Code” button which, when clicked, will give a popup with the URL for cloning your repository.\n\n\n\n\nClone repository\nNow we can use RStudio to clone this repository to your computer. For this you create a new RStudio project by clicking on the project drop-down menu at the top-right of the RStudio window and selecting “New Project…”.\n\n\n\n\nThat will open a dialog where you first choose “Version Control” and then choose “Git”.\n\n\n\n\n\n\n\n\n\n\nIn the resulting dialog window you paste in the repository URL that you copied from GitHub. You also specify the directory in your file area where you want the project directory to be saved. To do that click the “Browse…” button and find a location that is convenient for you. You may want to create a dedicated directory for this mizer course and then select that. But avoid creating a directory path that is too long. We have seen problems arise for people who used pathnames longer than 100 characters.\n\n\n\n\nThen click “Create Project”. RStudio now communicates with GitHub to download a clone of the repository and it also checks out all the files contained in the repository to the newly created directory. You can see them in the “Files” tab in RStudio.\n\n\n\n\nContinue in worksheet\nIn the Files tab you will in particular see a file called “worksheet-use-git-and-github.Rmd”. That is the worksheet for this tutorial. Please click on the file name in the Files tab of RStudio to open this worksheet in the RStudio editor. The editor has a “Source” mode and a “Visual” mode. Try out both and see which one you prefer.\n\n\n\n\n\n\n\n\n\n\nNow just follow the instructions in that worksheet. This will guide you through the process of performing your first commits to your repository and pushes to GitHub.\nAs you work through the exercises, you will get some automatic feedback. You can also always ask for personal feedback from us. The details are described in the worksheet. But if you run into a problem that you think might be of interest to others as well, please post in the comments below."
  },
  {
    "objectID": "prepare/index.html",
    "href": "prepare/index.html",
    "title": "Prepare for the mizer course",
    "section": "",
    "text": "While the course only starts on Monday the 8th of August, if you like you can already start preparations:\n1) You can introduce yourself and your interests to your fellow participants.\n2) You can install the tools that we will use in the course.\n3) You can familiarise yourself with how we will be using Git and GitHub in this course for collaboration and feedback on your coursework.\n4) We assume that you are familiar with the basics of R programming. There are plenty of free resources to learn R. You can look through R studio resources, go through R for Data Science or explore multiple other tools. You can also share your favourite tutorials or resources in the comments below.\nThat will allow for a flying start to the course. You won’t believe how much we are looking forward to meeting you all on the 8th of August"
  },
  {
    "objectID": "prepare/install-tools.html",
    "href": "prepare/install-tools.html",
    "title": "Install tools",
    "section": "",
    "text": "For this course you will need access to a machine with an installation of R, Git, RStudio and some important R packages, including, of course, mizer itself and mizerExperimental. Below we give the necessary information to allow you to install these tools.\nIf you run into difficulties, please make a post in the Comments section below. It is quite likely that someone else on the course has encountered similar difficulties and that someone has ideas on how to solve them.\nIf you already have some of these tools installed, please make sure that the version you have is recent."
  },
  {
    "objectID": "prepare/install-tools.html#r",
    "href": "prepare/install-tools.html#r",
    "title": "Install tools",
    "section": "R",
    "text": "R\nMizer is compatible with R versions 3.1 and later. However in this course we will assume that you have a version newer than 4.0. So if you are still using 3.x, now is the time to upgrade. You can install or upgrade R on your computer by following the instructions at https://cran.r-project.org/ for your particular platform. In fact, upgrading follows the same procedure as installing from scratch.\nAlternatively, if you can not or do not want to install R on your computer, you can also work with R and RStudio in your internet browser by creating yourself a free account at https://rstudio.cloud. There you can then install mizer as described above. Running mizer in the RStudio Cloud may be slightly slower than running it locally on your machine, but the speed is usually quite acceptable."
  },
  {
    "objectID": "prepare/install-tools.html#rstudio",
    "href": "prepare/install-tools.html#rstudio",
    "title": "Install tools",
    "section": "RStudio",
    "text": "RStudio\nThis course assumes that you will be using RStudio to work with R. There is really no reason not to use RStudio and it makes a lot of things much easier.\nRStudio develops rapidly and adds useful features all the time and so it is best if you install the latest version. This course was written with version 2022.07.0+548. If you already have RStudio installed but it is an older version, the way to upgrade is to just install the newest version. The old version will automatically be replaced by the new.\nIf you are new to RStudio, the video on the RStudio IDE homepage is well worth watching."
  },
  {
    "objectID": "prepare/install-tools.html#r-packages",
    "href": "prepare/install-tools.html#r-packages",
    "title": "Install tools",
    "section": "R Packages",
    "text": "R Packages\nR packages extend the functionality of R. mizer itself is such an R package. There is a central repository for R packages called CRAN which hosts all of the packages needed for this course, except for the mizerExperimental and mizerMR packages. To install them on your computer just start RStudio and then in the console issue the command\n\ninstall.packages(c(\"mizer\", \"tidyverse\", \"plotly\", \"remotes\", \"usethis\",\n                   \"rmarkdown\", \"rstudioapi\"))\n\nThe mizerExperimental package is for code that is still experimental and thus changes frequently. Therefore it is hosted in a GitHub repository. You install it with\n\nremotes::install_github(\"sizespectrum/mizerExperimental\")\n\nThe mizerMR package that extends mizer to work with multiple resources has not been released to CRAN because the plan is to incorporate it into core mizer in the future, so this too you need to install directly from GitHub.\n\nremotes::install_github(\"sizespectrum/mizerMR\")"
  },
  {
    "objectID": "prepare/install-tools.html#git",
    "href": "prepare/install-tools.html#git",
    "title": "Install tools",
    "section": "Git",
    "text": "Git\nGit is a distributed version control system that we will use in this course. We will discuss that more on the page Use Git and GitHub.\nGit may already be installed on your system. If you are in RStudio, then you can issue the following command in the “Terminal” tab:\ngit --version\nIf that comes back with a version number, then git is already installed. The current Git version is 2.25.1. If you have an older version then keep this in mind and if you should at some point notice that Git is not behaving the same for you as for others, then you might want to install the latest version. Or simply install the latest version now to be on the safe side.\nTo install Git follow the links at https://git-scm.com/downloads for your operating system. You do not need a GUI client for Git because you will be using Git from within RStudio. After you have installed Git, you may want to restart RStudio.\nFinally, you should tell Git about yourself by running the following command in the RStudio Console, where of course you change the name and email address to your own:\n\nusethis::use_git_config(user.name = \"Jane Doe\", \n                        user.email = \"jane@example.org\")"
  },
  {
    "objectID": "prepare/install-tools.html#issues",
    "href": "prepare/install-tools.html#issues",
    "title": "Install tools",
    "section": "Issues",
    "text": "Issues\nAs with all computer-related things, unexpected problems are likely to crop up. Be sure to post about them below. Alternatively you can also report issues by clicking on the “Report an issue” link that you find at the bottom of the right side-bar. That will create an entry in the GitHub issue tracker.\nIf you have a correction to this page or want to suggest an edit, use the “Edit this page” link. Don’t worry: we will need to approve your edits before they go live, so you can feel free to edit as much as you like.\nThis course should be a collaborative experience. You will find the “Edit this page” and “Report an issue” links on every tutorial page and you will find a comments section on every page of the course website. Never hesitate to use them."
  },
  {
    "objectID": "prepare/introduce-yourself.html",
    "href": "prepare/introduce-yourself.html",
    "title": "Introduce yourself",
    "section": "",
    "text": "When you post a comment you will be asked to log in to GitHub. You will probably already have an account on GitHub. If not, please create one for yourself. You will need it to participate in this course. The page Use Git and GitHub explains how we will use GitHub in this course.\nYou can use Markdown syntax in your post. For example to see how to include a link to your homepage, see the section on Links.\nThe comments you post on this course website will also appear in the Comments section of the GitHub discussions for the course repository. Even after posting a comment you can go and edit the post on GitHub and it will be updated on this website as well.\nThe comments are threaded discussions. Please post your introduction as a new comment rather than as a reply to someone else’s introduction. You can use the replies if you want to respond to someone’s introduction for follow-ups."
  },
  {
    "objectID": "prepare/watch-introduction.html",
    "href": "prepare/watch-introduction.html",
    "title": "Introduction to the mizer model",
    "section": "",
    "text": "Ken Andersen talks about the basic ideas underlying dynamic size-spectrum modelling with mizer."
  },
  {
    "objectID": "prepare/watch-introduction.html#in-preparation",
    "href": "prepare/watch-introduction.html#in-preparation",
    "title": "Introduction to the mizer model",
    "section": "In preparation",
    "text": "In preparation"
  },
  {
    "objectID": "use/index.html",
    "href": "use/index.html",
    "title": "Week 3: Use mizer models",
    "section": "",
    "text": "Lecture\nThis week’s contributor is Julia Blanchard. Her lecture provides a broad overview of the different ways in which mizer is being used to help understand the consequences of change in aquatic ecosystems. There are a lot of ways! The material describes how you can set model simulations to study change, some of which are explored in this week’s tutorials.\n\n\n\n\n\n\n\n\n\nTutorials\nUsing examples, the tutorials are designed to help you develop your own model simulation experiments:\n\nTune the resilience to fishing First, we will explore how sensitive your model is to the effects of fishing. We will show how the reproduction parameters influence the resilience of the species. We make adjustments to the reproduction levels to produce realistic responses to fishing intensity.\nSimulate fishing scenarios\nOnce the resilience to fishing is tuned, we can assess how the model responds to changes in fishing through time. This step involves looking closer at the fishing parameters in mizer and setting up different fishing scenarios.\nChange resources\nNext we will look at the resource spectrum and how changes in three main resource parameters can affect our ecosystem. With three main parameters for each resource, this can quickly get complicated. We will also show an example of how to use external data on resource time series to force the mizer model."
  },
  {
    "objectID": "use/change-resources.html#resource-dynamics",
    "href": "use/change-resources.html#resource-dynamics",
    "title": "Change resources",
    "section": "Resource dynamics",
    "text": "Resource dynamics\nLet’s look at the resource parameters once again\n\nresource_params(cm)\n\n\n\n  \n\n\n\nWe see four main resource parameters that we already met in the tutorial on multiple resources: we already know kappa, which defines the overall abundance of the resource, and lambda, which is the slope of the resource spectrum. We also know w_min and w_max, which set minimum and maximum resource sizes.\n\n\n\n\n\n\nBreaking change\n\n\n\nFor people who have already been using mizer to build or tune models in the past we need to draw attention to a change in the meaning of these resource parameters.\nIn the past, the parameters were used to set the resource carrying capacity, i.e., the hypothetical resource abundance that would be realised if there was no consumption by fish. In the new version, the parameters are used to set the actual observed resource abundance, in the presence of consumption by fish.\nIn the old version of steady(), the resource abundance would change during the tuning of the model. This made tuning of the model more difficult, especially if one wanted to reproduce observed resource abundances. The new version of the steady() that we used while tuning the model is keeping the resource abundance fixed and then adjusts the resource carrying capacity. So now the hypothetical carrying capacity is the emergent quantity and the observed abundance is specified by the resource parameters.\nSheldon’s spectra in natural ecosystems reflect abundances in natural systems and not a hypothetical carrying capacity that would emerge if there was no feeding on the resource. It makes sense to use the resource parameters to specify an observable quantity rather than a hypothetical one.\nThis is not really a breaking change, because all existing mizer models will continue to work in the same way as in the past. The change only affects the tuning of a model with the steady() function.\n\n\nWe will now explain the parameters r_pp and n.\nNote that the resource dynamics are very different from the size-spectrum dynamics for fish because there is no growth between sizes classes. There is only birth and death, independently in each size class. The abundance in a size class is the result of the balance between the birth and death rates in that size class. So we can understand the dynamics for each size class separately. We just have to understand how the birth and death rates are determined.\nSemi-chemostat resource dynamics means that the total birth rate decreases as the resource number density N_R(w) gets closer to its carrying capacity c_R(w), in such a way that the total birth rate at size w is given as (c_R(w) - N_R(w))r_R(w). We refer to r_R(w) as the intrinsic replenishment rate or just the resource rate. Stated the other way around: as the resource abundance drops, its birth rate increases. This is essential for the resilience of the system to perturbations as we will explain below.\nThe parameters r_pp and n are used to set the intrinsic replenishment rate r_R(w) of the resource to an allometric power law\nr_R(w) = r_{pp}w^{n-1}.\nThe default choice for the exponent n is 3/4, so that the replenishment rate decreases with size. Smaller resource size classes can replenish faster than larger size classes.\nThe resource is consumed by fish in proportion to its abundance. So the total death rate at size w is \\mu_R(w)N_R(w) where \\mu_R(w) is the per-capita mortality rate. This mortality rate on resource is determined by predation by fish in the same way as the mortality rate on other fish. So a higher abundance of fish leads to a higher mortality of resource.\nIn the steady state, the birth and death rates are in perfect balance. But if the fish abundance increases and thus the resource mortality rate increases, the resource abundance goes down. However, because the resource birth rate increases as the resource abundance goes down, a new steady state is soon established. The semichemostat dynamics are stable.\nBy definition, the steady state resource number density N_R will always be below the resource carrying capacity c_R. We refer to the ratio N_R / c_R as the the resource level. This has to be a number between 0 and 1. This is similar to the feeding level and the reproduction level.\nHow much the steady state resource abundance N_R changes when the predation mortality from fish increases depends on the resource level. This is best illustrated by a diagram.\n\n\n\n\n\nThe black dot represents the steady state situation, the one we have tuned our model to. The solid lines show how the resource abundance on the y axis will change as the resource mortality on the x axis changes away from the steady state value. The blue line gives the relationship for a higher carrying capacity, the black line gives it for a lower carrying capacity. We see that for a given change in the resource mortality, the change in resource abundance is larger along the blue curve than along the black curve. So the blue curve corresponds to more sensitivity of the resource to changes in the fish abundance and the black curve corresponds to more resilience of the resource. The blue curve is for a resource level of 1/3 and the black line for a resource level of 1/2. The closer the resource level is to 1 the shallower the curve and the more resilient the resource.\nJust like with reproduction level, we did not need to worry about resource level while we were tuning the steady state because the steady state does not change as the resource level changes. But the resource level becomes important when we investigate perturbations away from the steady state.\nWe do not set the resource level directly. We set the replenishment rate r_R and this determines the resource level:\n{\\tt resource\\ level}(w) = \\frac{r_R(w)}{r_R(w) + \\mu_R(w)}.\nSo the resource level depends both on the replenishment rate and on the predation mortality that the fish exert on the resource.\nLet’s look at the resource level in our model.\n\nplotResourceLevel(cm)\n\n\n\n\nThe resource level is close to one for the smaller resource because almost no fish consume it, but the resource level drops for larger resource."
  },
  {
    "objectID": "use/change-resources.html#scenario-1-changing-resource-replenishment-rate",
    "href": "use/change-resources.html#scenario-1-changing-resource-replenishment-rate",
    "title": "Change resources",
    "section": "Scenario 1: Changing resource replenishment rate",
    "text": "Scenario 1: Changing resource replenishment rate\nWe will now change the resource replenishment rate to see how it affects the resource level.\n\n# Create new data frame for high and low plankton\nrp <- resource_params(cm)\nrp_Pl_high <- rp\nrp_Pl_high[\"pl\", \"r_pp\"] <- 10\n\nrp_Pl_low <- rp\nrp_Pl_low[\"pl\", \"r_pp\"] <- 1\n\nWe will use a new function setResourceSemichemostat() to update resource parameters.\n\ncm_Pl_high <- setResourceSemichemostat(cm, rp_Pl_high)\n\ncm_Pl_low <- setResourceSemichemostat(cm, rp_Pl_low)\n\n\n\n\n\n\n\nPreserving the steady state\n\n\n\nThe setResourceSemichemostat sets the resource carrying capacity so that the resource abundance is at steady state with the given replenishment rate and the mortality rate exerted by the current fish abundances. This means that if we start with a steady state of the whole system and only change the replenishment rate by changing the r_pp and n parameters, then the steady state is preserved. However, if we change the resource abundance by changing the kappa, lambda, min_w or max_w parameters, this changes the food available for the fish and thus their growth rates. This means that the fish spectra will change over time and thus the resource mortality rate will change and the resource will no longer be at steady state.\n\n\nLet us look at the changed reproduction levels:\n\nplotResourceLevel(cm_Pl_low)\nplotResourceLevel(cm_Pl_high)\n\n\n\n\n\nlow plankton\n\n\n\n\n\n\nhigh plankton\n\n\n\n\n\n\nThe changed resource level should lead to differences when we perturb the system away from its steady state. We will run three simulations with the same, reduced and increased regeneration rate, and with higher fishing effort. Now that fish biomasses change due to fishing, resource consumption will change and the resource level will determine how sensitive the resource is to that change.\n\n# Lower regeneration, higher effort \nsim_lower <- project(cm_Pl_low, effort = 0.7, t_max = 50)\nplotBiomassRelative(sim_lower)\n# Higher regeneration, higher effort \nsim_higher <- project(cm_Pl_high, effort = 0.7, t_max = 50)\nplotBiomassRelative(sim_higher)\n\n\n\n\n\nlow plankton\n\n\n\n\n\n\nhigh plankton\n\n\n\n\n\n\nThe differences in the response of the system to the higher fishing effort are not very different for the two different resource replenishment rates. To see the differences better we plot their relative difference.\n\nplotBiomassRelative(sim_lower, sim_higher)\n\n\n\n\nWe can see that in this case the differences are never much more than 4%, which is very little considering all the uncertainties in the model. We conclude that for our model, when we want to explore increases in fishing effort, the choice of value for r_pp may not be so important, as the system is not sensitive to it. However, that may be an artifact of how we set up our model. In our model, mortalities on small individuals are very low and we didn’t bother to fix them with additional mortality to get the allometric mortality rates observed in nature. Had we done that, even small changes in the resource and hence in the larval feeding levels might be important. This is because lower feeding by larvae will make them grow slower, they will spend more time in smallest size classes with very high mortality, and this will affect the entire ecosystem. You can read about it, in this study. And if you want to explore it further and implement it to your model, the mizer code is here."
  },
  {
    "objectID": "use/change-resources.html#scenario-2-changes-in-total-plankton-abundance",
    "href": "use/change-resources.html#scenario-2-changes-in-total-plankton-abundance",
    "title": "Change resources",
    "section": "Scenario 2: Changes in total plankton abundance",
    "text": "Scenario 2: Changes in total plankton abundance\nNow we want to explore how our ecosystem might respond to the overall changes in resource abundance. Perhaps due to climate change the overall resource abundance will increase or decrease. We can explore this in a simple way by changing the kappa parameter.\nNow we will change plankton kappa in the same way as we changed r_pp in the previous scenario. Just to make sure we see some impact, let’s increase or decrease kappa by 50% and project to a new state.\n\n# Create new resource parameter data frames for more and less plankton \nrp_more_be <- rp\nrp_less_be <- rp\n\n# Increase kappa by 50%\nrp_more_be[\"pl\", \"kappa\"] <- rp_more_be[\"pl\", \"kappa\"] * 1.5\n\n# Decrease kappa by 50% \nrp_less_be[\"pl\", \"kappa\"] <- rp_less_be[\"pl\", \"kappa\"] / 1.5\n\n# Put new the resource parameters into the models \ncm_more_be <- setResourceSemichemostat(cm, rp_more_be)\n\ncm_less_be <- setResourceSemichemostat(cm, rp_less_be)\n\nLet’s check that resource abundances really changed by plotting the spectra\n\nplotSpectra2(cm_more_be, \"More\", cm_less_be, \"Less\", power = 2)\n\n\n\n\nAs we discussed before, while the setResourceSemichemostat() has set the resource carrying capacity so that initially the new resource abundance is steady, the fish abundances will change over time in response to the changed resource abundance and as a result also the resource abundance will start to change. Let us investigate that by projecting for 50 years with the new level and compare to the unchanged conditions.\n\nsim_more_plankton <- project(cm_more_be, t_max = 50)\nplotlyBiomassRelative(sim_more_plankton)\nsim_less_plankton <- project(cm_less_be, t_max = 50)\nplotlyBiomassRelative(sim_less_plankton)\n\n\n\n\n\n\n\nmore plankton\n\n\n\n\n\n\n\n\nless plankton\n\n\n\n\nThese results are quite expected. As plankton abundance increased, biomasses and yields for all species also increased. Roach benefited most, but pikeperch was also affected positively. Predator_fish also increased. The effect of decreasing plankton abundance is strongest on roach, pikeperch and predator_fish. So the overall effects of 50% increase and decrease in plankton kappa are rather symmetrical and expected.\nLet us also look at the feeding levels in the new steady states\n\nplotlyFeedingLevel(sim_more_plankton)\nplotlyFeedingLevel(sim_less_plankton)\n\n\n\n\n\n\n\nmore plankton\n\n\n\n\n\n\n\n\nless plankton\n\n\n\n\nAs expected, the feeding level for small individuals, which rely most on plankton for their food, are lower for lower plankton abundance."
  },
  {
    "objectID": "use/change-resources.html#scenario-3-changes-in-total-benthos-abundance",
    "href": "use/change-resources.html#scenario-3-changes-in-total-benthos-abundance",
    "title": "Change resources",
    "section": "Scenario 3: Changes in total benthos abundance",
    "text": "Scenario 3: Changes in total benthos abundance\nFrom the plankton exercise we might expect that changing benthos will lead to similar ecosystem change. But this is not necessarily the case, because all species feed on plankton, yet only some species feed on benthos. Without exploring this question in a multi-species context, we cannot really predict. We will follow exactly the same steps as in the previous scenario.\n\n# Create new resource parameter data frames for more and less plankton \nrp_more_be <- rp\nrp_less_be <- rp\n\n# Increase kappa by 50%\nrp_more_be[\"bb\", \"kappa\"] <- rp_more_be[\"bb\", \"kappa\"] * 1.5\n\n# Decrease kappa by 50% \nrp_less_be[\"bb\", \"kappa\"] <- rp_less_be[\"bb\", \"kappa\"] / 1.5\n\n# Put the new resource parameters into the models\ncm_more_be <- setResourceSemichemostat(cm, rp_more_be)\n\ncm_less_be <- setResourceSemichemostat(cm, rp_less_be)\n\n# Check on the spectra plot that the changes have taken place\nplotSpectra2(cm_more_be, \"More\", cm_less_be, \"Less\", power = 2)\n\n\n\n\nNow we will project for 50 years with the new level and see how the biomasses are changed\n\nsim_more_be <- project(cm_more_be, t_max = 50)\nplotlyBiomassRelative(sim_more_be)\nsim_less_be <- project(cm_less_be, t_max = 50)\nplotlyBiomassRelative(sim_less_be)\n\n\n\n\n\n\n\nmore benthos\n\n\n\n\n\n\n\n\nless benthos\n\n\n\n\nSurprisingly, the effects of decreasing benthos are far less pronounced on benthivorous fish, like roach, carrasius and breams. And it is perch and pikeperch that increased most, when benthos increased. It appears that benthivorous species were affected by changes in their predators and this counteracted the changes in their growth rate that are caused by the changes in their benthic resource.\nThis is just a simple exploration, but it demonstrates that in a multi-species system that consists of different trophic groups (planktivores, benthivores, predators), changes in plankton and benthos resource levels can have different and sometimes unexpected effects on species and yields. Also, different resources are likely to respond to climate change differently, and mizerMR provides an opportunity to explore it. Remember, you can set more than two resources in mizerMR. In fact, every species could have its own resource, although this would be a pretty boring model. But if you have a good reason to set 3 or 4 separate resources, this can be easily done."
  },
  {
    "objectID": "use/change-resources.html#scenario-4-changes-in-resource-size-structure-and-replenishment-rate",
    "href": "use/change-resources.html#scenario-4-changes-in-resource-size-structure-and-replenishment-rate",
    "title": "Change resources",
    "section": "Scenario 4: changes in resource size structure and replenishment rate",
    "text": "Scenario 4: changes in resource size structure and replenishment rate\nIt has also been suggested that climate change is changing the size structure of aquatic organisms, from plankton to fishes. We can attempt to model such changes in resource size structure by changing the lambda parameter. Mostly, it is expected that organisms will get smaller, so we expect lambda to become steeper (larger values). But at the same time benthic organisms might have faster growth rates, so their sizes might increase. These are just entirely hypothetical scenarios, but we can explore how potentially different responses in plankton and benthos will affect the ecosystem. But unlike with kappa we change lambda just by a small amount, because even small changes in allometric exponents will have large effects on the size spectrum.\nWe will repeat the steps from above - save the dataframe, update it with new parameters, check, put it back into params objects:\n\n# Create new resource parameter data frames for more and less plankton \nrp_steeperPl <- rp\nrp_shallowBe <- rp\nrp_Both <- rp\n\n# Increase plankton lambda by 0.1, setting it to 2.15 instead of 2.05\nrp_steeperPl[\"pl\", \"lambda\"] <- 2.15\n# Decrease benthos slope by 0.1, setting it to 1.8\nrp_shallowBe[\"bb\", \"lambda\"] <- 1.8\n# And now make both changes\nrp_Both[\"pl\", \"lambda\"] <- 2.15\nrp_Both[\"bb\", \"lambda\"] <- 1.8\n\n# Put the new resource parameters into the models\ncm_steeperPl <- setResourceSemichemostat(cm, rp_steeperPl)\ncm_shallowBe <- setResourceSemichemostat(cm, rp_shallowBe)\ncm_Both <- setResourceSemichemostat(cm, rp_Both)\n\nNow we project with steeper plankton slope for 50 years and look at the relative changes in the biomasses.\n\nsim_steeperPl <- project(cm_steeperPl, t_max = 50)\nplotlyBiomassRelative(sim_steeperPl)\n\n\n\n\n\nHere changes are more dramatic, with all species increasing their biomases with steeper plankton slopes. This might sound strange and counter intuitive, but we must realise that slope only affects the steepness of the resource, keeping abundance at 1g constant. So steeper slopes mean less plankton larger than 1 g, but more plankton small than 1 g. And since our maximum plankton size is only 1g, we only increased its abundance!\nNow let’s look at the effect of changes in the benthos slope.\n\nsim_shallowBe <- project(cm_shallowBe, t_max = 50)\nplotlyBiomassRelative(sim_shallowBe)\n\n\n\n\n\nWith more shallow benthos slopes, roach and pikeperch are affected badly and other benthivores decrease slighly, but are probably benefiting from reduced predation due to reduced predator biomass. We can compare feeding level changes and see that large predators have largest decreases in feeding level.\n\nplotlyFeedingLevel(sim_steeperPl)\nplotlyFeedingLevel(sim_shallowBe)\n\n\n\n\n\n\n\nsteeper plankton\n\n\n\n\n\n\n\n\nshallower benthos\n\n\n\n\nAnd what happens if both plankton and benthos slopes change?\n\nsim_Both <- project(cm_Both, t_max = 50)\nplotlyBiomassRelative(sim_Both)\n\n\n\n\n\nNow effects partly balance each other out, but to understand this better we will compare to simulations where, for example, only plankton slope changed. This can help isolate the interacting effects.\n\nplotlyBiomassRelative(sim_Both, sim_steeperPl)\nplotlyYieldRelative(sim_Both, sim_steeperPl)\n\n\n\n\n\n\n\nBiomass\n\n\n\n\n\n\n\n\nYield\n\n\n\n\nYou can also try to combine these changes in lambda with changes in the resource replenishment rate (which can either go up or down due to climate change) and see how many options we already have. And then these lambda changes will probably also interact with changes in kappa, and feed back into the ecosystem through species interactions. Moreover, our system response to these changes will depend on reproduction level and resource resilience parameters (replenishment rate), and it will depend on other parameters for our species. This gets complicated very quickly. On top of that we probably want to explore how fishing might interact with changes in the resource abundance, so that gets even more complicated. This is not to discourage you, but to show that there are plenty of opportunities for exploration and interesting publications. We are still very uncertain on how resources will respond to changes in climate and will probably learn a lot more in the future."
  },
  {
    "objectID": "use/change-resources.html#scenario-5-changes-through-time",
    "href": "use/change-resources.html#scenario-5-changes-through-time",
    "title": "Change resources",
    "section": "Scenario 5: Changes through time",
    "text": "Scenario 5: Changes through time\nThe scenario explorations above were very simple, because we changed one or several of resource parameters and projected the system to a new steady state. While the mechanics of setting such scenarios is straightforward, examples above show that understanding all the complex ways how simple changes can affect the ecosystem may be harder.\nHowever, many researchers do not want to explore such hypothetical resource changes, but instead use independently derived time series of resource abundance provided by e.g. satellite observations and earth system models. This is important and useful, although we do encourage you to play with simple changes first to gain understanding about your system and its sensitivity to resource changes. Just like with fishing mortality scenarios, ecosystem response will depend strongly on our model calibration. This means that before we go into complex scenarios we need to be satisfied with the parameters we provided and know limitations of our simulations. For example, alternative, equally possible model calibrations may provide different quantitative change (i.e. how much the biomasses or yields change), but similar qualitative response in the ecosystem. If quantitative differences are very large, perhaps it would be best to focus on more general qualitative responses.\nBut let’s look at how we can implement multiple drivers under climate change by coupling mizer to outputs of earth system models such as temperature, abundance of different size classes of plankton or detrital “marine snow” that reaches the sea floor through time. This example is provided by Julia Blanchard and it demonstrates how to implement changes in resource abundance and size structure through time, by working with pre-made resource size spectra files that were estimated from two climate change scenarios from earth system model output.\nThese resource spectra files were derived from small and large phytoplankton biomasses predicted by the Fisheries and Marine Ecosystems Model Intercomparison Project (FishMIP). There are a lot of steps in processing these data, but we won’t go in to that here. The main goal is to demonstrate how to use these scenario forcings to create changes in your mizer resources through time. This example will use another model - Patagonian toothfish fishery ecosystem. We will explore how the marine demersal fish community changes under this forcing through time. The two model scenarios are ssp585 (highest emissions or “worst”) and ssp126 (mitigation to cut emissions or “best”). Note: this new model does NOT use multiple resources\nRead in the model and the resource abundances provided by the earth system model.\n\nparams <- readParams(\"toothfish_model.rds\")\nresource_best <- readRDS(\"resource_scenario_126.rds\")\nresource_worst <- readRDS(\"resource_scenario_585.rds\")\n\nThe data files provide arrays with dimensions time x size with the resource number density in the years from 2021 to 2070 for all size classes in the model, as predicted by the earth system model.\n\nstr(resource_best)\n\n num [1:50, 1:209] 7.34e+31 7.98e+31 7.90e+31 7.53e+31 7.65e+31 ...\n - attr(*, \"dimnames\")=List of 2\n  ..$ : chr [1:50] \"2021\" \"2022\" \"2023\" \"2024\" ...\n  ..$ : chr [1:209] \"9.42976673097891e-13\" \"1.14104741933864e-12\" \"1.38072260992634e-12\" \"1.67074119204156e-12\" ...\n\n\nWe now create new mizer models that contain this information about the plankton abundance. Mizer allows us to add an arbitrary number of other parameters to the model. We decide to call our new parameter resource_array.\n\n#create new params files\nparams_worst <- params\nparams_best <- params\n\n# Add extra `resource_array` parameter to these model\nother_params(params_best)$resource_array <- resource_best\nother_params(params_worst)$resource_array <- resource_worst\n\nInstead of running mizer’s standard resource dynamics we want the resource abundance to be taken from these arrays. To achieve this we can use that mizer allows us to provide our own resource dynamics function. That function just needs to return the value for the resource at the next time step. So in our case it just needs to look up the correct value in an array.\n\nplankton_forcing <- function(params, t, ...) {\n    # The time `t` will run from 2021 to 2070 whereas the time index in the\n    # array runs from 1 to 50. Hence we need to index by t - 2020.\n    # In fact `t` will take on fractional values like 2021.1 after the first\n    # time step, but R conveniently rounds them down automatically.\n    other_params(params)$resource_array[t - 2020, ]\n}\n\nNow we just have to register this new function as the resource dynamics function in the models:\n\nparams_best <- setResource(params_best, resource_dynamics = \"plankton_forcing\")\nparams_worst <- setResource(params_worst, resource_dynamics = \"plankton_forcing\")\n\nThis means that in each time step the resource abundance (only plankton in this case, as this is the only resource in this model) will be determined the semichemostat dynamics, but by the externally provided values.\nNow we will project these new models forward for 50 years from 2021 to 2070 without fishing.\n\nsim_best <- project(params_best, effort = 0, t_start = 2021, t_max = 50)\n\nsim_worst <- project(params_worst, effort = 0, t_start = 2021, t_max = 50)\n\nLet’s look at how the biomasses evolve in these models:\n\nplotlyBiomassRelative(sim_best)\nplotlyBiomassRelative(sim_worst)\n\n\n\n\n\n\n\nBest\n\n\n\n\n\n\n\n\nWorst\n\n\n\n\nThis shows how the effects of plankton changing alone can have a big effects on the model.\n\nanimateSpectra(sim_worst, power = 2)\n\n\n\n\n\nThis example has shown how you can directly use outputs of earth system models for projections (GFDL inputs - FishMIP)."
  },
  {
    "objectID": "use/change-resources.html#summary",
    "href": "use/change-resources.html#summary",
    "title": "Change resources",
    "section": "Summary",
    "text": "Summary\n\nThe resource replenishment rate coefficient r_pp will determine the resilience of the resource spectrum to mortality imposed by fish. In many scenarios, the choice of replenishment rate may not make a big impact, but in others it will be important. Therefore we should explore how this parameter might affect our model dynamics (together with other parameters, of course).\nClimate change is likely to impact resource abundance, size structure and productivity. Mizer allows you to explore how these changes might impact aquatic ecosystems and yields.\nBy separating plankton and benthos resource mizerMR allows us to model separate resource responses to climate, which are likely to lead to different responses in different trophic groups of fish. There are many potential ways how these resources can change, so one needs to carefully consider how best to select scenarios.\nWe can change resource dynamics to functions other than semi-chemostat. Mizer allows you to force models with externally obtained resource time series. This way we can explore gradual ecosystem changes through time."
  },
  {
    "objectID": "use/change-resources.html#further-explorations-and-climate-change-effects",
    "href": "use/change-resources.html#further-explorations-and-climate-change-effects",
    "title": "Change resources",
    "section": "Further explorations and climate change effects",
    "text": "Further explorations and climate change effects\nIf you want to explore how changes in the resource due to climate change can affect ecosystems with multiple resources you can look at two recent model applications. One example is a recently published Baltic Sea mizer model where authors explored how changes in resource total abundance (kappa) and replenishment rate (r_pp) might affect the ecosystem.\nAnother example in the Tasmanian rocky reef model (a preprint can be found here), where authors used multiple parameter combinations to assess how changes in kappa and lambda for plankton and benthos might affect the ecosystem. The Tasmanian model has a supporting R Shiny application that allows you explore your own resource change scenarios, using one parameterisation. Here you can change kappa and lambda of either resource and combine it with physiological responses to temperature change, by also changing temperatures. This will display changes in biomass, yields and mean sizes for the modeled fish species.\nDespite all the complexities above, we barely scratched the surface about the possible ways how climate change might affect our ecosystems. For example, so far we did not include any direct temperature effects. Even though we modeled resource change, this was imposed externally and did not combine with possible effects of temperature on physiology. If you want to also include temperature effects on fish physiological rates, take a look at the excellent blog post by Phoebe Woodworth-Jefcoats in the mizer blog. She describes how you can replace rate functions in mizer with your own set functions and she uses this to account for dome-shaped species responses to temperature - increased rates up to a certain temperature and decreases after that.\nOf course climate change will also affect the composition of species, because with warming new species will enter the ecosystem. This is an important aspect to address, but has not been thoroughly explored yet. Mizer allows you to add new species into ecosystem with the addSpecies() function. However, it is not necessarily clear how we tune parameters of new species for which we don’t yet have data (in that ecosystem at least), so exploring climate heating driven species composition change is not straightforward."
  },
  {
    "objectID": "use/run-your-own-scenarios.html",
    "href": "use/run-your-own-scenarios.html",
    "title": "Run other scenarios",
    "section": "",
    "text": "This final tutorial gives some examples from another mizer model, tuned to a different system and used to explore different questions. It is always useful to see alternative ways of using mizer and get examples of code to setup different analyses. This tutorial is contributed by Julia Blanchard. Here we will explore an example model of longline fishery that consists of targeting a single species, Patagonian toothfish.\nAs usual, we need to have some packages installed.\n\nremotes::install_github(\"sizespectrum/mizerExperimental\", ref = \"tuneMR\")\nlibrary(mizerExperimental)\nlibrary(tidyverse)\n\nThen we load the model and explore its various properties.\n\nparams <- readParams(\"toothfish_model.rds\")\n\nWe look at the growth curves\n\nplotGrowthCurves(params, species_panel = TRUE)\n\n\n\n\nthe spectra\n\nplotlySpectra(params, power = 2, total = TRUE)\n\n\n\n\n\nthe feeding levels\n\nplotFeedingLevel(params)\n\n\n\n\nand diets\n\nplotDiet(params)\n\n\n\n\nFor this model, we had the following main criteria for our project:\n\nModelled biomasses were within +/- 10-20% of the observed biomasses.\nUnfished normalised biomass size spectrum slope that is negative and close to -1\nGrowth curves approximated the von Bertalanffy growth curves for each species.\nToothfish diet captured dietary changes with body size and became more piscivorous at larger sizes.\nRecruitment parameters ensured single-species yield curves were dome-shaped, as expected by theory.\nThe modeled catches through time captured the trends in the reported catches through time.\n\nWe can see from these plots that we still have more work to do with refining the model. The size at age for some species seem much higher than the empirical parameters, feeding level of near satiation for all species and the biomass of some species is much higher than the data. However size-at-age data are typically highly variable. So, let’s set some of those issues aside for now.\nLet’s take a look at how fishing is set up in this model.\n\ngear_params(params)\n\n\n\n  \n\n\n\nCurrently we can see there is one gear - longline - which has a knife_edge selectivity function that starts fishing at very large sizes of toothfish only (knife_edge_size=2722 g). The size selectivity was derived from the length distribution of catches from the long-line fisheries data. To explore further how to setup your fishing parameters and use gear_params() function you can look at the example here.\nWe can see that the initial_effort has been set to 1 and the catchability has been set to a very low number: 7e-07. This shows the model has been calibrated with a very low level of fishing mortality.\n\nreproduction_level <- getReproductionLevel(params)\nreproduction_level\n\n    D.ele     C.gun     C.rhi     L.squ     M.cam     B.eat     B.irr     G.acu \n0.9998035 0.9994817 0.9991013 0.9426729 0.8279399 0.9999131 0.9996038 0.9996273 \n    B.mur \n0.9777815 \n\nplotYieldCurve(params, species = \"D.ele\", no_steps = 30, F_max = 2)\n\n\n\n\nWe get F_{MSY} of about 0.4. Let’s see what happens if reproduction level is reduced\n\nparams2 <- setBevertonHolt(params, reproduction_level = 0.85)\n\nsim2 <- project(params2, t_max = 20)\nplotBiomass(sim2)\n\n\n\nplotYieldCurve(params2, species=\"D.ele\", F_max = 2)\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : D.ele\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : D.ele\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : D.ele\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : D.ele\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : D.ele\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : D.ele\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : D.ele\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : D.ele\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : D.ele\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : D.ele\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : D.ele\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : D.ele\nare going extinct.\n\n\n\n\n\nThis shows that altering the level of density-dependence in recruitment affects how sensitive toothfish (D.ele for short) is to fishing. By reducing the reproduction level just a bit, we make its biomass collapse completely at fishing mortality of about 0.5. We will use the previous reproduction level in further examples."
  },
  {
    "objectID": "use/run-your-own-scenarios.html#set-up-your-own-fishing-scenario-simpler-comparison-of-steady-states",
    "href": "use/run-your-own-scenarios.html#set-up-your-own-fishing-scenario-simpler-comparison-of-steady-states",
    "title": "Run other scenarios",
    "section": "Set up your own fishing scenario: simpler comparison of steady states",
    "text": "Set up your own fishing scenario: simpler comparison of steady states\nRather than an entire time-series, we can also simply examine differences between two time-averaged states under different fishing regimes.\nWe can alter the fishing parameters using a function called gear_params() and by changing the effort input.\nLet’s take a look at the fishing parameters.\nWe can group species together according to the gears they are caught by. Initially let’s just add another gear - a trawler targeting icefish (C.gun).\n\n# allocate species to gear types\ngear_params(params) <- data.frame(\n    gear = c(\"longline\", \"trawler\"),\n    species = c(\"D.ele\", \"C.gun\"),\n    catchability = c(1, 1),\n    sel_fun = c(\"knife_edge\", \"knife_edge\"),\n    knife_edge_size = c(2722, 52)\n    )\n#check it\ngear_params(params)\n\n\n\n  \n\n\n\nNote that catchability is set to 1. This is because the fishing “effort” was here assumed to be the fishing mortality rate of fully selected sizes (see here setFishing).\n\nparams <- setFishing(params, initial_effort = 0.1)\n\nNow let’s run two simulations, one with light fishing mortality (F = 0.2) and one heavy fishing (F = 1.5).\n\nsim_unfished <- projectToSteady(params, effort = 0, t_max = 500)\n\nConvergence was achieved in 1.5 years.\n\nplot(sim_unfished)\n\n\n\nparams_longline_trawl<-params\nsim_longline_trawl <- projectToSteady(params_longline_trawl, effort = 0.1, t_max = 500)\n\nConvergence was achieved in 31.5 years.\n\nparams_longline<-params\ngear_params(params_longline)$catchability[2]=0\nsim_longline <- projectToSteady(params_longline, effort = 0.1, t_max = 500)\n\nConvergence was achieved in 31.5 years.\n\n\n\n# plot change in biomass under each scenario relative to unfished values\n# get the unfished biomasses\nB_unfished <- getBiomass(sim_unfished)\n#scen 1\nBrel_longline <- getBiomass(sim_longline)/B_unfished\n\n#scen 2\nBrel_longline_trawl <- getBiomass(sim_longline_trawl)/B_unfished\n\nBrel_scens <- rbind(data.frame(species=names(Brel_longline),value=Brel_longline,scen=\"longline\"),data.frame(species=names(Brel_longline_trawl),value=Brel_longline_trawl,scen=\"longline_trawl\"))\n\n# barplot comparing the 2 scenarios by 2050\nggplot(Brel_scens, aes(fill=scen, y=value, x=species)) + \n    geom_bar(position=\"dodge\", stat=\"identity\") + \n    geom_hline(yintercept = 0.1, linetype = 2, colour = \"red\", size = 0.5)  + \n    scale_y_log10(name = \"log10(Biomass/Biomass Unfished)\")\n\n\n\n\nThe impact of the combined trawl and longline appears to have more of an effect on C.gun and the biomass of D.ele is slightly more depleted relative to the unfished state.\nFurther Exploration The above plots provide you with a way to compare different modelling scenarios. You may wish to explore different levels of fishing mortality in the above example or add completely different gears to the fishery."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Online mizer course",
    "section": "",
    "text": "2022 August 8-26"
  },
  {
    "objectID": "index.html#size-based-ecosystem-models-with-the-r-package-mizer-and-applications-for-coastal-and-inland-ecosystems",
    "href": "index.html#size-based-ecosystem-models-with-the-r-package-mizer-and-applications-for-coastal-and-inland-ecosystems",
    "title": "Online mizer course",
    "section": "Size based ecosystem models with the R package mizer and applications for coastal and inland ecosystems",
    "text": "Size based ecosystem models with the R package mizer and applications for coastal and inland ecosystems\nIn this online course you will learn about the principles of size based community and ecosystem modelling, implementation of these principles in the R package mizer, learn about adaptation of mizer for shallow ecosystems with multiple resources, and learn how to build a new model with your own or example data and use it to investigate the ecosystem effect of changes in fishing or other stressors.\nThe course is led by Gustav Delius (University of York, UK) and Asta Audzijonyte (Nature Research Centre, Lithuania & University of Tasmania, Australia), with technical support by Romain Forestier (University of Tasmania). Invited speakers include Ken Haste Andersen and Julia Blanchard.\nParticipation is free. If you would like to participate in this course, please register."
  },
  {
    "objectID": "index.html#tutorials-and-worksheets",
    "href": "index.html#tutorials-and-worksheets",
    "title": "Online mizer course",
    "section": "Tutorials and worksheets",
    "text": "Tutorials and worksheets\nThe course has three week-long sections:\n\nWeek 1: Understand\nYou will gain an understanding of size spectra and their dynamics by exploring simple example systems hands-on with mizer.\nWeek 2: Build\nFollowing our example, you will build your own multi-species mizer model for the Curonian sea. We will collect the models from all participants to create an ensemble of models.\nWeek 3: Use\nWe will use this new ensemble of mizer models to explore the effects of changes in fishing and changes in resource dynamics. You will run your own model scenarios.\n\nThe course is organised into several tutorials each week. Each tutorial is associated with a worksheet in which you perform the exercises that are dotted throughout the tutorials. You will work through these tutorials and worksheets at times that are convenient for you."
  },
  {
    "objectID": "index.html#on-line-meetings",
    "href": "index.html#on-line-meetings",
    "title": "Online mizer course",
    "section": "On-line meetings",
    "text": "On-line meetings\nThere will be several optional online meeting scheduled throughout the course, see the list of meetings in the table below. The purpose of the meetings is to add a social dimension to the course. You only have to join when you can. For each day we organise two meetings to accommodate different time zones:\n\n7am UK summer time (BST) most suitable for Asia and Australasia:\nhttps://live.remo.co/e/mizer-course-meetings\n3pm UK summer time (BST) most suitable for Europe and America:\nhttps://live.remo.co/e/mizer-course-meetings-2\n\nPlease follow one of these links now. You will be asked to create yourself an account. Please use the email address that you used for registering for this mizer course. If you need to use another email address, please send an email from that email address to gustav.delius@gmail.com and he will add that email to the list of accepted emails.\nOnce you have logged into Remo, you will be introduced to its main features and then Remo will check whether your browser and operating system is on their list of supported configurations.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nDo not worry if you get the message that your configuration is not supported. It will most likely work anyway.\n\n\n\nWhen you get to the landings page for the meeting, click on “Register for Event”. You will only need to do this once. All future meetings will use the same meeting space.\nOn Monday 8th of August we will have an introductory and welcome meeting with all course participants. On Tuesdays and Thursdays of each week course participants are encouraged to join the meetings with other course participants to discuss their progress, challenges and ideas (course tutors will not attend all these meetings). On Fridays we will have meetings with tutors to recap the experience from that week and discuss remaining questions.\n\n\n\nDate\nTime 1\nTime 2\nNotes\n\n\n\n\nAug 8, Monday\n7.00\n15.00\nIntroductory meeting for all course participants and tutors\n\n\nAug 9, Tuesday\n7.00\n15.00\nCourse participants are encouraged to join and form group discussions\n\n\nAug 11, Thursday\n7.00\n15.00\nCourse participants are encouraged to join and form group discussions\n\n\nAug 12, Friday\n7.00\n15.00\nMeetings with course participants and tutors\n\n\nAug 16, Tuesday\n7.00\n15.00\nCourse participants are encouraged to join and form group discussions\n\n\nAug 18, Thursday\n7.00\n15.00\nCourse participants are encouraged to join and form group discussions\n\n\nAug 19, Friday\n7.00\n15.00\nMeetings with course participants and tutors\n\n\nAug 23, Tuesday\n7.00\n15.00\nCourse participants are encouraged to join and form group discussions\n\n\nAug 25, Thursday\n7.00\n15.00\nCourse participants are encouraged to join and form group discussions\n\n\nAug 26, Friday\n7.00\n15.00\nFinal days of meetings with course participants and tutors\n\n\n\n\nThis course is organised as a part of the “Sustainable inland fisheries” project, funded by the European Regional Development Fund (project No 01.2.2-LMT-K-718-02-0006) under grant agreement with the Research Council of Lithuania (LMTLT) and the Pyramids of Life, funded by UK Research and Innovation via the Sustainable Management of Marine Resources fund."
  },
  {
    "objectID": "use/change-resources.html#scenario-1-changes-in-resource-replenishment-rate",
    "href": "use/change-resources.html#scenario-1-changes-in-resource-replenishment-rate",
    "title": "Change resources",
    "section": "Scenario 1: Changes in resource replenishment rate",
    "text": "Scenario 1: Changes in resource replenishment rate\nWe will now change the resource replenishment rate for plankton to see how that affects the resource level for plankton and how that affects the system’s response to changes in fishing. So we change the value of the r_pp for the plankton resource. We choose the two values 10 and 1 for the high and the low replenishment rate.\n\n# Create new data frame for high and low plankton replenishment\nrp <- resource_params(cm)\nrp_Pl_high <- rp\nrp_Pl_high[\"pl\", \"r_pp\"] <- 10\n\nrp_Pl_low <- rp\nrp_Pl_low[\"pl\", \"r_pp\"] <- 1\n\nWe will use a new function setResourceSemichemostat() to update resource parameters.\n\ncm_Pl_high <- setResourceSemichemostat(cm, rp_Pl_high)\n\ncm_Pl_low <- setResourceSemichemostat(cm, rp_Pl_low)\n\n\n\n\n\n\n\nPreserving the steady state\n\n\n\nThe setResourceSemichemostat sets the resource carrying capacity so that the resource abundance is at steady state with the given replenishment rate and the mortality rate exerted by the current fish abundances. This means that if we start with a steady state of the whole system and only change the replenishment rate by changing the r_pp and/or n parameters, then the steady state is preserved. However, if we change the resource abundance by changing the kappa, lambda, min_w or max_w parameters, this changes the food available for the fish and thus their growth rates. This means that the fish spectra will change over time and thus the resource mortality rate will change and the resource will no longer be at steady state. We’ll see an example of that in the next scenario.\n\n\nLet us look at the changed reproduction levels:\n\nplotResourceLevel(cm_Pl_low)\nplotResourceLevel(cm_Pl_high)\n\n\n\n\n\nlow plankton replenishment\n\n\n\n\n\n\nhigh plankton replenishment\n\n\n\n\n\n\nThe changed resource level should lead to differences when we perturb the system away from its steady state. We will perturb the system by imposing a higher fishing effort.We will run simulations with the reduced and the increased replenishment rate with a fishing effort of 0.7. As a result of that higher fishing effort, the fish biomasses will change and hence resource consumption will change. The resource level will determine how sensitive the system is to that change.\n\n# Lower replenishment, higher effort \nsim_lower <- project(cm_Pl_low, effort = 0.7, t_max = 50)\nplotlyBiomassRelative(sim_lower)\n# Higher replenishment, higher effort \nsim_higher <- project(cm_Pl_high, effort = 0.7, t_max = 50)\nplotlyBiomassRelative(sim_higher)\n\n\n\n\n\n\n\nlow plankton replenishment\n\n\n\n\n\n\n\n\nhigh plankton replenishment\n\n\n\n\nThe differences in the response of the system to the higher fishing effort are not very different for the two different resource replenishment rates. To see the differences better we plot their relative difference.\n\nplotlyBiomassRelative(sim_lower, sim_higher)\n\n\n\n\n\nWe can see that in this case the differences are never much more than 4%, which is very little considering all the uncertainties in the model. We conclude that for our model, when we want to explore increases in fishing effort, the choice of value for r_pp may not be so important, as the model is not very sensitive to it. However, that may be an artefact of how we have set up external mortality in our model. In our model, mortalities on small individuals are very low and we didn’t bother to fix them with additional mortality to get the allometric mortality rates observed in nature. Had we done that, even small changes in the resource and hence in the larval feeding levels might be important. This is because lower feeding by larvae will make them grow slower, they will spend more time in smallest size classes with very high mortality, and this will affect the entire ecosystem. You can read about it, in this study. And if you want to explore it further and implement it to your model, the mizer code is here."
  },
  {
    "objectID": "use/run-your-own-scenarios.html#comparing-ecosystem-states-effects-of-fishing-relative-to-an-unfished-state",
    "href": "use/run-your-own-scenarios.html#comparing-ecosystem-states-effects-of-fishing-relative-to-an-unfished-state",
    "title": "Run other scenarios",
    "section": "Comparing ecosystem states: effects of fishing relative to an unfished state",
    "text": "Comparing ecosystem states: effects of fishing relative to an unfished state\nTo be able to assess the wider ecosystem impacts of fishing in the community we need to understand how changes compare to an unfished state. We can use the above model unfished steady state with effort = 0 to do this combined with some functions to calculate ecological indicators.\nLet’s compare the current size spectra (with fishing) to the unfished size spectra to assess whether there is any evidence of a size-structured trophic cascade due to fishing.\n\nsim0 <- project(params2, effort = 0, t_max = 20)\nsim <- project(params2, effort = 1, t_max = 20)\nplotSpectraRelative(sim0, sim)\n\n\n\n\nHere we can see the effect of the reduction in large sized individuals of heavily fished species on the other sizes and species in the model, relative to the unfished steady state.\nThe abundance of some (but not all) of the smaller to medium sizes of prey are a lot higher when their larger predators are removed (note the logarithmic scale). This is because when toothfish are removed via fishing, they have less predation mortality and no fishing inflicted upon them."
  },
  {
    "objectID": "use/run-your-own-scenarios.html#fishing-through-time-past-time-series",
    "href": "use/run-your-own-scenarios.html#fishing-through-time-past-time-series",
    "title": "Run other scenarios",
    "section": "Fishing through time: past time series",
    "text": "Fishing through time: past time series\nMizer can also be used to carry out projections with changes in fishing effort. We will start by reading in a time series of catch and effort. We will read in the effort data for this fishery. Note: these are not the correct effort values, they are only for illustration in this example. Then we plot effort and catch through time.\n\ndat <- readRDS(\"toothfish/longline.rds\")\nplot_dat <- melt(dat, \"Year\")\n\nggplot(plot_dat, aes(x = Year, y = value)) +\n    geom_point() +\n    facet_wrap(~variable, nrow = 2, scales = \"free\")\n\n\n\n\nWe can see from the data that there have been big changes in effort and catches through time. The first plot shows relative effort per area (please note that these data are not correct and are only being used for illustration in this example). Catches are in tonnes per square km fished. They have changed a lot over the years.\nPreviously we assumed effort was 1 and we worked with catchability as the variable. Real effort data can come in all sorts of different units (hours or days fished, kilowatt days, number of vessels all per unit time). The key to using this in our model is that the catchability is the fraction of the available (that is also selected by the gear) stock caught per unit of any effort that is included.\nOften, we have used fishing mortality rates from stock assessment to drive changes in effort through time, assuming Q*E = F at maximally selected sizes (as in this paper and others). But in many cases this information is not available. It also could be misleading as those fishing mortality rates are estimated using very different single-species models (but sometimes that is the best we have to work with, and as with all of the assumptions we make the limitations just need to be clear).\nHow do we incorporate the effort data into the model? First, we have to re-arrange the data so it can be read into the params object.\n\neffort_time <- array(c(rep(0,13), dat$EffortPerArea), \n                     dim = c(length(1990:2020), 1),\n                     dimnames = list(\"time\" = 1990:2020, \n                                     \"gear\" = params@gear_params$gear[1]))\n\nNext we use the effort data to project the model forwards from it’s steady state. But wait - we did not set up the model for the first year of the data, when fishing only just began. It may make more sense to use a steady state without fishing as the initial values for our projection.\n\n#project to zero fishing rate \nparams <- projectToSteady(params, effort = 0)\n\nConvergence was achieved in 1.5 years.\n\n#project with fishing effort\nsimf <- project(params, effort = effort_time)\n\nplotYieldGear(simf) + \n    geom_point(data = dat, shape = 1, size = 1, \n               mapping = aes(x = Year, y = CatchPerArea))\n\n\n\n\nHere we can see that the modeled catch time series fall within the scatter of the observed catch data (reassuring), but the trends are different. It seems there is a sharp decline in modeled catches towards the end of the time series. While we should not expect the exact up and down fluctuations to be captured by our model (we don’t have anything forcing the changes through time other than fishing!), we could examine further how changing the reproduction parameters affects how well the model captures stock decline (and later, recovery), relative to the trends in the data. It may also be that our estimates of catchability and effort are way off (they are). And that other factors could be influencing observed changes not accounted for by our model."
  },
  {
    "objectID": "use/run-your-own-scenarios.html#what-if-we-only-have-catch-data",
    "href": "use/run-your-own-scenarios.html#what-if-we-only-have-catch-data",
    "title": "Run other scenarios",
    "section": "What if we only have catch data?",
    "text": "What if we only have catch data?\nWhat if there was no effort data only catch? This is the case for many data-poor fisheries or for fisheries where there is only restricted access to effort data.\nMany fisheries develop through time according to phases: an exponential growth period, following either a peak and subsequent decline and a plateau, if stocks drop below sustainable levels and management kicks in (see here for example). These different types of development can be represented by a function, logistic_effort(), and can be used to help estimate the fishing parameters given the the model parameters and data you may have. This is the approach used here. Here, we will use this function to explore effort through time.\n\nlogistic_effort <- function(effort_array,\n                            gear = \"longline\",\n                            time = 1990:2020,\n                            Fmax = 1.5,\n                            steepness = 0.2,\n                            midpoint = 2005) {\n    effort_array[, gear] <- Fmax / (1 + exp(-steepness*(time - midpoint)))\n    return(effort_array)\n}\n\nAfter using the above function we can scale the effort up to the effort units we used in our base model. We do this by setting the Fmax in the logistic equation to the desired level of fishing mortality rate (e.g. 0.005 was used above but for this example we will plug in a different value to explore heavier fishing). We then divide Fmax by our estimated catchability coefficient (which was estimated to be a very small number) to get effort in the correct ballpark and units as the data we used above. If you want to run the model directly with fishing mortality rate as the “effort” driver, you would need to set the catchability coefficient to 1 in this example. If no effort exists for your system, we would need to estimate the catchability coefficient (either by hand tuning or statistical time-series fitting).\n\nneweffort <- logistic_effort(effort_time, time = 1990:2020, Fmax = 0.5,\n                             steepness = 0.9, midpoint = 2005)\n\n#rescale to get effort in same units as our example\nneweffort <- neweffort / gear_params(params)$catchability[1]\n\n# or if you want to just use fishing mortality only in your model, \n# overwrite the catchability to 1:\n# gear_params(params)$catchability[1] <- 1\n\nyear = 1990:2020\nqplot(year, neweffort, ylab = \"effort\", xlab = \"\")\n\n\n\n\nNow you can run the same model above using this effort and then plot effort and biomass dynamics through time.\n\nparams3 <- setInitialValues(params2, sim0)\nsimf3 <- project(params3, effort = neweffort)\n\nplotYieldGear(simf3) + \n    geom_point(data = dat, shape = 1, size = 1, \n               mapping = aes(x = Year, y = CatchPerArea)) + \n    xlim(2000, 2020)\n\nWarning: Removed 10 row(s) containing missing values (geom_path).\n\n\n\n\nplotBiomass(simf3)\n\n\n\n# If you like you can save the output for further analyses \n#saveRDS(simf3,\"simf3.rds\")\n\nWe can see here as effort develops towards a plateau of Fmax = 0.5 through time, catches initially increase, reach a peak around 2006, and then decline. The biomass trajectories also show that toothfish starts declining slightly before this."
  },
  {
    "objectID": "use/run-your-own-scenarios.html#fishing-through-time-projecting-into-the-future",
    "href": "use/run-your-own-scenarios.html#fishing-through-time-projecting-into-the-future",
    "title": "Run other scenarios",
    "section": "Fishing through time: projecting into the future",
    "text": "Fishing through time: projecting into the future\nNow let’s see what happens if we change fishing in the future. To do this we set up two scenarios, one where the model starts with the last time step of the fished scenario and continues into the future (the “status quo”). The other will be designed to explore a “more sustainable” scenario.\n\n# Use the parameters from the last simulation\nparams <- getParams(simf3)\nparams <- setInitialValues(params, simf3)\n\nThe setInitialValues() function has set the intitial spectra and the intial effort in the params object to the final values from simf3, i.e., to the values from 2020. The effort was\n\n\nlongline \n714284.7 \n\n\nLet’s start a new simulation that begins with the effort from 2020 and projects forward for 50 years. We will apply a linear decrease in effort for toothfish to a target value (here assumed for simplicity to be F = 0.2). To do this we need to work the effort array again (time x gear) to enable changes in effort through time.\n\nsim_scen1 <- project(params, t_max = 50)\nplot(sim_scen1)\n\n\n\nproj_effort_scen1 <- matrix(initial_effort(params), \n                            nrow = 50, ncol = 1, byrow = TRUE)\n\ndimnames(proj_effort_scen1) <- \n    list(time = 2021:2070, gear = unique(gear_params(params)$gear))\n# check it\nqplot(x = 2021:2070, y = proj_effort_scen1, ylab = \"effort\", xlab = \"\")\n\n\n\n\nThat was Scenario 1 (“status quo”), now let’s set up Scenario 2, the “more sustainable” option we wish to explore. Again, if we are working in the same units as the effort above we can change the F below to scale effort to be consistent with a value of F=0.2. So we need to set effort= catchability/targetF Otherwise if you assume targetF= catchability*E, and set catchability to 1, you can just use targetF=0.2 directly for Scenario 2.\n\nproj_effort_scen2 <- proj_effort_scen1\ntargetF <- 0.2 / gear_params(params)$catchability[1]\nselect_gear = \"longline\"\n# reach target by 10 years\nproj_effort_scen2[1:10,select_gear] <- \n    seq(from = proj_effort_scen2[1], to = targetF, length = 10)\n# then hold at target\nproj_effort_scen2[11:50, select_gear] <- targetF\n# check it\nqplot(x = 2021:2070, y = proj_effort_scen2, ylab = \"effort\", xlab = \"\")\n\n\n\n\nNow we want to run the simulation forward using the project() function.\n\n# run the simulations forward, both using the 2020 abundances as initial values\nparams <- setInitialValues(params, sim)\nsim_scen1 <- project(params, effort = proj_effort_scen1, t_max = 50)\nsim_scen2 <- project(params, effort = proj_effort_scen2, t_max = 50)\n\nHow has this affected the catches and the biomass of other species in the system relative to fishing levels in 2020?\n\n#set the scenario to examine relative to 2020 levels\nscen<-sim_scen2\nplotYield(scen)\n\n\n\n# plot change in biomass under each scenario relative to current values\nB_current <- getBiomass(scen)[1, ]\nBrel_scen <- melt(sweep(getBiomass(scen), 2, B_current, \"/\"))\ncolnames(Brel_scen)[2] <- \"Species\"\nlegend_levels <- intersect(names(scen@params@linecolour), Brel_scen$Species)\nggplot(Brel_scen) + \n  geom_line(aes(x = time,y = value,color = Species), size = 1) + \n  geom_hline(yintercept = 1, linetype = 1, colour = \"grey\", size = 0.75) +\n  scale_y_continuous(name = \"Relative biomass\") +\n  scale_color_manual(values = sim@params@linecolour[legend_levels]) +\n  theme(legend.key = element_rect(fill = \"white\")) \n\n\n\n\nRelative to 2020 values, reducing Fmsy to 0.2 has increased toothfish biomass and has affected the other species in the system too.\nTo compare the status of the stock across the two scenarios we need to express the changes relative to the unfished state according to the model. This will provide us with a rough indicator of the level of depletion. Generally, we would consider a stock to be collapsed if biomass was < 0.1 of the unfished levels. Some data-poor single species fisheries management strategies seek for depletion to be around or above 0.5 of unfished levels.\nLet’s take a look at the relative exploitation status of the stocks using the projected values for 2050. We will put the y-axis scale is log10 to better visualise the differences across species.\n\n# plot change in biomass under each scenario relative to unfished values\n# get saved values from steady state without fishing that we generated earlier \nsim0<-readRDS(\"sim0.rds\")\n# get the unfished biomasses\nB_unfished <- getBiomass(sim0)[1, ]\n#scen 1\nBrel_scen1_2050 <- getBiomass(sim_scen1)[\"2050\",]/B_unfished\n\n#scen 2\nBrel_scen2_2050 <- getBiomass(sim_scen2)[\"2050\",]/B_unfished\n\nBrel_scens <- rbind(data.frame(species=names(Brel_scen1_2050),value=Brel_scen1_2050,scen=\"scen1\"),data.frame(species=names(Brel_scen2_2050),value=Brel_scen2_2050,scen=\"scen2\"))\n\n# barplot comparing the 2 scenarios by 2050\nggplot(Brel_scens, aes(fill=scen, y=value, x=species)) + \n    geom_bar(position=\"dodge\", stat=\"identity\") + \n     geom_hline(yintercept = 0.1, linetype = 2, colour = \"red\", size = 0.5)  + scale_y_log10(name = \"log10(Biomass/Biomass Unfished)\")\n\n\n\n# to save:\n#saveRDS(sim_scen2,\"sim_scen2.rds\")\n\nSpecies with B/B_unfished values that are below the red dashed line imply the stock is still collapsed.\nWe can see that when we decrease fishing to the targetF under scenario 2 this greatly improves the relative biomass compared to the status quo. This is consistent with our expectations from the equilibrium Fmsy that we tuned. Another thing to note is that, relative to the unfished community, there are several species that increase less under this fishing scenario - this is what happens when account for food web interactions in models!"
  },
  {
    "objectID": "use/further-scenarios.html",
    "href": "use/further-scenarios.html",
    "title": "Explore further scenarios",
    "section": "",
    "text": "This final tutorial gives some examples from another mizer model, tuned to a different system and used to explore different questions. It is always useful to see alternative ways of using mizer and get examples of code to setup different analyses. This tutorial is contributed by Julia Blanchard. Here we will explore an example model of longline fishery that consists of targeting a single species, Patagonian toothfish."
  },
  {
    "objectID": "use/further-scenarios.html#comparing-ecosystem-states-effects-of-fishing-relative-to-an-unfished-state",
    "href": "use/further-scenarios.html#comparing-ecosystem-states-effects-of-fishing-relative-to-an-unfished-state",
    "title": "Explore further scenarios",
    "section": "Comparing ecosystem states: effects of fishing relative to an unfished state",
    "text": "Comparing ecosystem states: effects of fishing relative to an unfished state\nTo be able to assess the wider ecosystem impacts of fishing in the community we need to understand how changes compare to an unfished state. We can use the above model to simulate an unfished steady state with effort = 0 and then explore this state using some ecological indicators.\nLet’s compare the current size spectra (with fishing) to the unfished size spectra to assess whether there is any evidence of a size-structured trophic cascade due to fishing.\n\nsim0 <- project(params, effort = 0, t_max = 20)\nplotSpectraRelative(sim0, params)\n\n\n\n\nHere we can see the effect of the reduction in large sized individuals of heavily fished species on the other sizes and species in the model, relative to the unfished steady state.\nThe abundance of some (but not all) of the smaller to medium sizes of prey are a lot higher when their larger predators are removed (note the logarithmic scale). This is because when toothfish are removed via fishing, they have less predation mortality and no fishing inflicted upon them."
  },
  {
    "objectID": "use/further-scenarios.html#fishing-through-time-past-time-series",
    "href": "use/further-scenarios.html#fishing-through-time-past-time-series",
    "title": "Explore further scenarios",
    "section": "Fishing through time: past time series",
    "text": "Fishing through time: past time series\nMizer can also be used to carry out projections with changes in fishing effort. We will start by reading in a time series of catch and effort. We will read in the effort data for this fishery. Note: these are not the correct effort values, they are only for illustration in this example. Then we plot effort and catch through time.\n\ndat <- readRDS(\"toothfish/longline.rds\")\nplot_dat <- melt(dat, \"Year\")\n\nggplot(plot_dat, aes(x = Year, y = value)) +\n    geom_point() +\n    facet_wrap(~variable, nrow = 2, scales = \"free\")\n\n\n\n\nWe can see from the data that there have been big changes in effort and catches through time. The first plot shows relative effort per area (please note that these data are not correct and are only being used for illustration in this example). Catches are in tonnes per square km fished. They have changed a lot over the years.\nPreviously we assumed effort was 1 and we worked with catchability as the variable. Real effort data can come in all sorts of different units (hours or days fished, kilowatt days, number of vessels all per unit time). The key to using this in our model is that the catchability is the fraction of the available (that is also selected by the gear) stock caught per unit of any effort that is included.\nOften, we have used fishing mortality rates from stock assessment to drive changes in effort through time, assuming Q*E = F at maximally selected sizes (as in this paper and others). But in many cases this information is not available. It also could be misleading as those fishing mortality rates are estimated using very different single-species models (but sometimes that is the best we have to work with, and as with all of the assumptions we make the limitations just need to be clear).\nHow do we incorporate the effort data into the model? First, we have to re-arrange the data so it can be read into the params object.\n\neffort_time <- array(c(rep(0,13), dat$EffortPerArea), \n                     dim = c(length(1990:2020), 1),\n                     dimnames = list(\"time\" = 1990:2020, \n                                     \"gear\" = params@gear_params$gear[1]))\n\nNext we use the effort data to project the model forwards from it’s steady state. But wait - we did not set up the model for the first year of the data, when fishing only just began. It may make more sense to use a steady state without fishing as the initial values for our projection.\n\n#project to zero fishing rate \nparams <- projectToSteady(params, effort = 0)\n\nConvergence was achieved in 1.5 years.\n\n#project with fishing effort\nsimf <- project(params, effort = effort_time)\n\nplotYieldGear(simf) + \n    geom_point(data = dat, shape = 1, size = 1, \n               mapping = aes(x = Year, y = CatchPerArea))\n\n\n\n\nHere we can see that the modeled catch time series fall within the scatter of the observed catch data (reassuring), but the trends are different. It seems there is a sharp decline in modeled catches towards the end of the time series. While we should not expect the exact up and down fluctuations to be captured by our model (we don’t have anything forcing the changes through time other than fishing!), we could examine further how changing the reproduction parameters affects how well the model captures stock decline (and later, recovery), relative to the trends in the data. It may also be that our estimates of catchability and effort are way off (they are). And that other factors could be influencing observed changes not accounted for by our model."
  },
  {
    "objectID": "use/further-scenarios.html#what-if-we-only-have-catch-data",
    "href": "use/further-scenarios.html#what-if-we-only-have-catch-data",
    "title": "Explore further scenarios",
    "section": "What if we only have catch data?",
    "text": "What if we only have catch data?\nWhat if there was no effort data and only catch data? This is the case for many data-poor fisheries or for fisheries where there is only restricted access to effort data.\nMany fisheries develop through time according to phases: an exponential growth period, following either a peak and subsequent decline and a plateau, if stocks drop below sustainable levels and management kicks in (see here for example). These different types of development can be represented by a function, logistic_effort(), and can be used to help estimate the fishing parameters given the the model parameters and data you may have. This is the approach used here. Here, we will use this function to explore effort through time.\n\nlogistic_effort <- function(effort_array,\n                            gear = \"longline\",\n                            time = 1990:2020,\n                            Fmax = 1.5,\n                            steepness = 0.2,\n                            midpoint = 2005) {\n    effort_array[, gear] <- Fmax / (1 + exp(-steepness*(time - midpoint)))\n    return(effort_array)\n}\n\nAfter using the above function we can scale the effort up to the effort units we used in our base model. We do this by setting the Fmax in the logistic equation to the desired level of fishing mortality rate (e.g. 0.005 was used above but for this example we will plug in a different value to explore heavier fishing). We then divide Fmax by our estimated catchability coefficient (which was estimated to be a very small number) to get effort in the correct ballpark and units as the data we used above. If you want to run the model directly with fishing mortality rate as the “effort” driver, you would need to set the catchability coefficient to 1 in this example. If no effort exists for your system, we would need to estimate the catchability coefficient (either by hand tuning or statistical time-series fitting).\n\nneweffort <- logistic_effort(effort_time, time = 1990:2020, Fmax = 0.5,\n                             steepness = 0.9, midpoint = 2005)\n\n#rescale to get effort in same units as our example\nneweffort <- neweffort / gear_params(params)$catchability[1]\n\n# or if you want to just use fishing mortality only in your model, \n# overwrite the catchability to 1:\n# gear_params(params)$catchability[1] <- 1\n\nyear = 1990:2020\nqplot(year, neweffort, ylab = \"effort\", xlab = \"\")\n\n\n\n\nNow you can run the same model above using this effort and then plot effort and biomass dynamics through time.\n\nparams3 <- setInitialValues(params, sim0)\nsimf3 <- project(params3, effort = neweffort)\n\nplotYieldGear(simf3) + \n    geom_point(data = dat, shape = 1, size = 1, \n               mapping = aes(x = Year, y = CatchPerArea)) + \n    xlim(2000, 2020)\n\nWarning: Removed 10 row(s) containing missing values (geom_path).\n\n\n\n\nplotBiomass(simf3)\n\n\n\n# If you like you can save the output for further analyses \n#saveRDS(simf3,\"simf3.rds\")\n\nWe can see here as effort develops towards a plateau of Fmax = 0.5 through time, catches initially increase, reach a peak around 2006, and then decline. The biomass trajectories also show that toothfish starts declining slightly before this."
  },
  {
    "objectID": "use/further-scenarios.html#fishing-through-time-projecting-into-the-future",
    "href": "use/further-scenarios.html#fishing-through-time-projecting-into-the-future",
    "title": "Explore further scenarios",
    "section": "Fishing through time: projecting into the future",
    "text": "Fishing through time: projecting into the future\nNow let’s see what happens if we change fishing in the future. To do this we set up two scenarios, one where the model starts with the last time step of the fished scenario and continues into the future (the “status quo”). The other will be designed to explore a “more sustainable” scenario.\n\n# Use the parameters from the last simulation\nparams <- getParams(simf3)\nparams <- setInitialValues(params, simf3)\n\nThe setInitialValues() function has set the initial spectra and the initial effort in the params object to the final values from simf3, i.e., to the values from 2020. The effort was\n\ninitial_effort(params)\n\nlongline \n714284.7 \n\n\nLet’s start a new simulation that begins with the effort from 2020 and projects forward for 50 years. We will apply a linear decrease in effort for toothfish to a target value (here assumed for simplicity to be F = 0.2). To do this we need to work the effort array again (time x gear) to enable changes in effort through time.\n\nproj_effort_scen1 <- matrix(initial_effort(params), nrow = 50, ncol = 1, byrow = TRUE)\ndimnames(proj_effort_scen1) <- \n    list(time = 2021:2070, gear = unique(gear_params(params)$gear))\n# check it\nqplot(x = 2021:2070, y = proj_effort_scen1, ylab = \"effort\", xlab = \"\")\n\n\n\n\nThat was Scenario 1 (“status quo”), now let’s set up Scenario 2, the “more sustainable” option we wish to explore. Again, if we are working in the same units as the effort above we can change the F below to scale effort to be consistent with a value of F=0.2. So we need to set effort= catchability/targetF. Otherwise if you assume targetF= catchability*E, and set catchability to 1, you can just use targetF=0.2 directly for Scenario 2.\n\nproj_effort_scen2 <- proj_effort_scen1\ntargetF <- 0.2 / gear_params(params)$catchability[1]\nselect_gear = \"longline\"\n# reach target by 10 years\nproj_effort_scen2[1:10,select_gear] <- \n    seq(from = proj_effort_scen2[1], to = targetF, length = 10)\n# then hold at target\nproj_effort_scen2[11:50, select_gear] <- targetF\n# check it\nqplot(x = 2021:2070, y = proj_effort_scen2, ylab = \"effort\", xlab = \"\")\n\n\n\n\nNow we want to run the simulation forward using the project() function.\n\n# run the simulations forward, both using the 2020 abundances as initial values\nsim_scen1 <- project(params, effort = proj_effort_scen1, t_max = 50)\nsim_scen2 <- project(params, effort = proj_effort_scen2, t_max = 50)\n\nHow has this affected the catches and the biomass of other species in the system relative to fishing levels in 2020?\n\n#set the scenario to examine relative to 2020 levels\nscen <- sim_scen2\nplotYield(scen)\n\n\n\n# plot change in biomass under each scenario relative to current values\nB_current <- getBiomass(scen)[1, ]\nBrel_scen <- melt(sweep(getBiomass(scen), 2, B_current, \"/\"))\ncolnames(Brel_scen)[2] <- \"Species\"\nlegend_levels <- intersect(names(scen@params@linecolour), Brel_scen$Species)\nggplot(Brel_scen) + \n  geom_line(aes(x = time,y = value,color = Species), size = 1) + \n  geom_hline(yintercept = 1, linetype = 1, colour = \"grey\", size = 0.75) +\n  scale_y_continuous(name = \"Relative biomass\") +\n  scale_color_manual(values = params@linecolour[legend_levels]) +\n  theme(legend.key = element_rect(fill = \"white\")) \n\n\n\n\nRelative to 2020 values, reducing Fmsy to 0.2 has increased toothfish biomass and has affected the other species in the system too.\nTo compare the status of the stock across the two scenarios we need to express the changes relative to the unfished state according to the model. This will provide us with a rough indicator of the level of depletion. Generally, we would consider a stock to be collapsed if biomass was <0.1 of the unfished levels. Some data-poor single species fisheries management strategies seek for depletion to be around or above 0.5 of unfished levels.\nLet’s take a look at the relative exploitation status of the stocks using the projected values for 2050. We will put the y-axis scale is log10 to better visualise the differences across species.\n\n# plot change in biomass under each scenario relative to unfished values\n# get saved values from steady state without fishing that we generated earlier \nsim0<-readRDS(\"sim0.rds\")\n# get the unfished biomasses\nB_unfished <- getBiomass(sim0)[1, ]\n#scen 1\nBrel_scen1_2050 <- getBiomass(sim_scen1)[\"2050\",]/B_unfished\n\n#scen 2\nBrel_scen2_2050 <- getBiomass(sim_scen2)[\"2050\",]/B_unfished\n\nBrel_scens <- rbind(data.frame(species=names(Brel_scen1_2050),value=Brel_scen1_2050,scen=\"scen1\"),data.frame(species=names(Brel_scen2_2050),value=Brel_scen2_2050,scen=\"scen2\"))\n\n# barplot comparing the 2 scenarios by 2050\nggplot(Brel_scens, aes(fill=scen, y=value, x=species)) + \n    geom_bar(position=\"dodge\", stat=\"identity\") + \n     geom_hline(yintercept = 0.1, linetype = 2, colour = \"red\", size = 0.5)  + scale_y_log10(name = \"log10(Biomass/Biomass Unfished)\")\n\n\n\n# to save:\n#saveRDS(sim_scen2,\"sim_scen2.rds\")\n\nSpecies with B/B_unfished values that are below the red dashed line imply the stock is still collapsed.\nWe can see that when we decrease fishing to the targetF under scenario 2 this greatly improves the relative biomass compared to the status quo. This is consistent with our expectations from the equilibrium Fmsy that we tuned. Another thing to note is that, relative to the unfished community, there are several species that increase less under this fishing scenario - this is what happens when account for food web interactions in models!"
  },
  {
    "objectID": "use/further-scenarios.html#set-up-your-own-fishing-scenario-simpler-comparison-of-steady-states",
    "href": "use/further-scenarios.html#set-up-your-own-fishing-scenario-simpler-comparison-of-steady-states",
    "title": "Explore further scenarios",
    "section": "Set up your own fishing scenario: simpler comparison of steady states",
    "text": "Set up your own fishing scenario: simpler comparison of steady states\nRather than an entire time-series, we can also simply examine differences between two time-averaged states under different fishing regimes.\nWe can alter the fishing parameters using a function called gear_params() and by changing the effort input.\nLet’s take a look at the fishing parameters.\nWe can group species together according to the gears they are caught by. Initially let’s just add another gear - a trawler targeting icefish (C.gun).\n\n# allocate species to gear types\ngear_params(params) <- data.frame(\n    gear = c(\"longline\", \"trawler\"),\n    species = c(\"D.ele\", \"C.gun\"),\n    catchability = c(1, 1),\n    sel_fun = c(\"knife_edge\", \"knife_edge\"),\n    knife_edge_size = c(2722, 52)\n    )\n#check it\ngear_params(params)\n\n\n\n  \n\n\n\nNote that catchability is set to 1. This is because the fishing “effort” was here assumed to be the fishing mortality rate of fully selected sizes (see here setFishing).\n\nparams <- setFishing(params, initial_effort = 0.1)\n\nNow let’s run two simulations, one with light fishing mortality (F = 0.2) and one heavy fishing (F = 1.5).\n\nsim_unfished <- projectToSteady(params, effort = 0, t_max = 500)\n\nConvergence was achieved in 69 years.\n\nplot(sim_unfished)\n\n\n\nparams_longline_trawl<-params\nsim_longline_trawl <- projectToSteady(params_longline_trawl, effort = 0.1, t_max = 500)\n\nConvergence was achieved in 34.5 years.\n\nparams_longline<-params\ngear_params(params_longline)$catchability[2]=0\nsim_longline <- projectToSteady(params_longline, effort = 0.1, t_max = 500)\n\nConvergence was achieved in 34.5 years.\n\n\n\n# plot change in biomass under each scenario relative to unfished values\n# get the unfished biomasses\nB_unfished <- getBiomass(sim_unfished)\n#scen 1\nBrel_longline <- getBiomass(sim_longline)/B_unfished\n\n#scen 2\nBrel_longline_trawl <- getBiomass(sim_longline_trawl)/B_unfished\n\nBrel_scens <- rbind(data.frame(species=names(Brel_longline),value=Brel_longline,scen=\"longline\"),data.frame(species=names(Brel_longline_trawl),value=Brel_longline_trawl,scen=\"longline_trawl\"))\n\n# barplot comparing the 2 scenarios by 2050\nggplot(Brel_scens, aes(fill=scen, y=value, x=species)) + \n    geom_bar(position=\"dodge\", stat=\"identity\") + \n    geom_hline(yintercept = 0.1, linetype = 2, colour = \"red\", size = 0.5)  + \n    scale_y_log10(name = \"log10(Biomass/Biomass Unfished)\")\n\n\n\n\nThe impact of the combined trawl and longline appears to have more of an effect on C.gun and the biomass of D.ele is slightly more depleted relative to the unfished state."
  },
  {
    "objectID": "use/further-scenarios.html#a-look-at-the-model",
    "href": "use/further-scenarios.html#a-look-at-the-model",
    "title": "Explore further scenarios",
    "section": "A look at the model",
    "text": "A look at the model\nAs usual, we need to have some packages installed.\n\nremotes::install_github(\"sizespectrum/mizerExperimental\", ref = \"tuneMR\")\nlibrary(mizerExperimental)\nlibrary(tidyverse)\n\nThen we load the model and explore its various properties.\n\nparams <- readParams(\"toothfish_model.rds\")\n\nWe look at the growth curves,\n\nplotGrowthCurves(params, species_panel = TRUE)\n\n\n\n\nthe spectra,\n\nplotlySpectra(params, power = 2, total = TRUE)\n\n\n\n\n\nthe feeding levels,\n\nplotFeedingLevel(params)\n\n\n\n\nand toothfish diet.\n\nplotDiet(params, species = \"D.ele\")\n\n\n\n\nFor this model, we had the following main criteria for our project:\n\nModelled biomasses were within +/- 10-20% of the observed biomasses.\nUnfished normalised biomass size spectrum slope that is negative and close to -1.\nGrowth curves approximated the von Bertalanffy growth curves for each species.\nToothfish diet captured dietary changes with body size and became more piscivorous at larger sizes.\nRecruitment parameters ensured single-species yield curves were dome-shaped, as expected by theory.\nThe modeled catches through time captured the trends in the reported catches through time.\n\nWe can see from these plots that we still have more work to do with refining the model. The size at age for some species seem much higher than the empirical parameters, feeding level of near satiation for all species and the biomass of some species is much higher than the data. However size-at-age data are typically highly variable. So, let’s set some of those issues aside for now.\nLet’s take a look at how fishing is set up in this model.\n\ngear_params(params)\n\n\n\n  \n\n\n\nCurrently we can see there is one gear - longline - which has a knife_edge selectivity function that starts fishing at very large sizes of toothfish only (knife_edge_size = 2722 g). The size selectivity was derived from the length distribution of catches from the long-line fisheries data. To explore further how to setup your fishing parameters and use gear_params() function you can look at the example here. The catchability has been set to a very low number: 7e-07. The initial effort is:\n\ninitial_effort(params)\n\nlongline \n6787.953 \n\n\nThis shows that the model has been calibrated with a very low level of fishing mortality (multiply effort by catchability).\nLet’s look at the reproduction levels and the yield curve for toothfish:\n\ngetReproductionLevel(params)\n\n    D.ele     C.gun     C.rhi     L.squ     M.cam     B.eat     B.irr     G.acu \n0.9998035 0.9994817 0.9991013 0.9426729 0.8279399 0.9999131 0.9996038 0.9996273 \n    B.mur \n0.9777815 \n\nplotYieldCurve(params, species = \"D.ele\", no_steps = 30, F_max = 2)\n\n\n\n\nThey generally look good and the curve is dome-shaped."
  },
  {
    "objectID": "use/further-scenarios.html#further-exploration",
    "href": "use/further-scenarios.html#further-exploration",
    "title": "Explore further scenarios",
    "section": "Further Exploration",
    "text": "Further Exploration\nThe above plots provide you with a way to compare different modelling scenarios. You may wish to explore different levels of fishing mortality in the above example or add completely different gears to the fishery."
  }
]