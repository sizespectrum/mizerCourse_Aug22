[
  {
    "objectID": "build/index.html",
    "href": "build/index.html",
    "title": "Week 2: Build mizer models",
    "section": "",
    "text": "You are welcome to use your own model system during this week, assuming you have the data. Alternatively, we will focus on a Curonian Lagoon ecosystem. It is a productive brackishwater lagoon in the Baltic Sea. It has a relatively simple species composition and it is also a shallow water system where both plankton and benthos energy pathways are important. For those participants who will focus on the Curonian lagoon model, our goal at the end of the week is for each participant to develop their own model parameterisation. We will then collect these alternative parameter sets and use them as a model ensemble next week.\nThe material is split into 4 tutorials:\n\nFinding species parameters\nHere we will explore the main species parameters that should be provided by the user to start building a multi-species model. We will also look at assumptions and defaults that mizer uses to fill non-essential parameter values. Your task will be to collect essential parameters from FishBase or other sources.\nCreate your model with one resource\nNow that we have species parameters we can build the first model. In this part we will focus on achieving reasonable species abundances and growth rates.\nAdd multiple resources to your model\nIn this tutorial we will use the mizerMR extension to add a benthic resource spectrum to the model. We will explore how to adjust resource availability to achieve realistic ontogenetic changes in diets.\nRefine your model\nIn this section we will use an R shiny application to explore how changes in parameters will affect model behaviour and to refine the model given our observations and knowledge about the species.\n\nTo get your worksheet repository for this week, follow this link:\nhttps://classroom.github.com/a/0wH7LDgR"
  },
  {
    "objectID": "build/find-species-parameters.html",
    "href": "build/find-species-parameters.html",
    "title": "Finding species parameters",
    "section": "",
    "text": "How do we decide which species to include in the model? There are many ways to approach it and no clearly set rules. Of course you want to include species that you are interested in, but then also perhaps some other important species in the ecosystem. Mizer actually has a powerful framework that allows you to explicitly model only your focus species and represent the rest of the ecosystem with some ‘background’ species. The sizes and abundances of these ‘background’ species are assumed to follow the power law, so that the total community biomass approximately represents the Sheldon spectrum. This is only mentioned here for your information, as we will not go into these details during this week.\nIf you have your own ecosystem that you want to model during this week, then you also have your own list of species. Ideally you may want to have somewhere around 4 to 20 species, as this allows for interesting but also tractable dynamics (although tracking processes in all 20 species might be quite challenging). For the Curonian Lagoon model we selected key ecosystem fish species that are commonly observed in scientific monitoring surveys, and which live and reproduce in the ecosystem (as compared to several migratory species, which can be abundant briefly don’t have a big role in the ecosystem in the long term).\nThe list of species and their general feeding habits or trophic group are listed below. We include scientific and model name, the latter representing a short name that we can conveniently use and display in plots.\n\n\nScientific name\nModel name\nTrophic group\n\n\n\nPungitius pungitius, Alburnus alburnus\nsmallfish\nplanktivore\n\n\nGymnocephalus cernua\nruffe\nbenthivore\n\n\nAbramis brama, Blicca bjoerkna\nbreams\nbenthivore\n\n\nRutillus rutillus\nroach\nbenthivore\n\n\nVimba vimba\nvimba\nbenthivore\n\n\nCarassius carassius\ncarassius\nbenthivore\n\n\nPerca fluviatilis\nperch\nomnivore\n\n\nSander lucioperca\npikeperch\npredator\n\n\nLota lota\nburbot\npredator\n\n\nEsox lucius, Aspius aspius\npredators\npredator"
  },
  {
    "objectID": "build/find-species-parameters.html#essential-parameters",
    "href": "build/find-species-parameters.html#essential-parameters",
    "title": "Finding species parameters",
    "section": "Essential parameters",
    "text": "Essential parameters\nAt this point it might be useful to go back and rewatch the second half of Ken Andersen’s introductory lecture, which explains species parameters used in mizer. It is great how mizer can start building a model with only very few species parameters! For most other parameters, if values are not supplied by the user, mizer will fill them with default values using size-based theory or species averages.\nThere are really only four parameters that the user should provide:\n\nSpecies names\nAsymptotic body size w_inf\nVon Bertalanffy growth rate k_vb or species maximum intake rate coefficient h You learned about it in the introductory lecture by Ken Andersen. Even if you provide h values, you might still want to include k_vb in your species parameter file, because it can be used to plot modelled versus expected growth rates.\n\n\n\n\n\n\n\nDanger\n\n\n\n\n\nVon Bertalanffy growth function\nThe growth curve of a fish is commonly reported as a von Bertalanffy growth curve. The von Bertalanffy curve describes the length of a fish as a function of two parameters; the asymptotic length L_\\infty and the von Bertalanffy growth coefficient K (k_vb in mizer):\nL_{(t)} = L_\\infty (1-e^{-Kt})\nwhere t is the age. L_\\infty represents the asymptotic length and K is an intantaneous annual growth rate. This value shows how quickly a species will approach its asymptotic length. In many species 1/K gives an approximat age at maturation, although this can vary.\nMizer, however, uses two other parameters, W_\\infty (w_inf in Mizer) and h, where W_\\infty represents the asymptotic weight and h the size-scaled maximum consumption rate. Ken Andersen discusses K and h in his introductory lecture. Fortunately, the two sets of parameters are related, and one can derive h and W_\\infty from von Bertalanffy K and L_\\infty.\nThe parameter h represents the maximum consumption rate of a fish, scaled by size. The value of h varies between 4 – 400, with a geometric mean around 22 g^{-0.25}/year across all fish species (Andersen 2019, chap. 2 and 11). If we have reliable von Bertalanffy growth curve values, we can derive a more precise estimate of h as: h \\approx 4.75 K\\cdot L_\\infty^{0.75} (with K given in 1/years and L_\\infty in cm).\nVon Bertalanffy growth function is widely used in fisheries and ecology. However, it should be treated with some caution. To estimate the growth function coefficients reliably we need sufficient amounts of data from young and old individuals. The latter is often not the case for intensively fished species, because old fish are simply not present in the ecosystem. If we do not have old fish in the sample the asymptotic length L_\\infty cannot be properly estimated. As a result, estimates of K will also vary extensively across samples. You can see that for yourself in our exercise below.\n\n\n\n\nA vector of species biomasses to be provided in the biomass_observed column. This data are not essential and mizer will run without it, but you won’t be able to calibrate your model to a realistic system without some information on relative species abundances and biomasses. Note, the biomass_observed reflects the average species biomasses in your model system for the period that you want to calibrate your system to.\n\n\n\n\n\n\n\nImportant\n\n\n\n\n\nHow to get observed biomasses?\nTo calibrate the rate of reproduction (the rate at which eggs are entering the first size class in each species), mizer needs some information about species abundance or biomasses. Multi-species models are often calibrated using average observed biomases or average spawning stock biomasses of species. The units of the area or volume over which these biomasses were observed depend on your choice, mizer does not care about it (see section Units in mizer in this reference page). Sometimes we can use relative biomasses, which scale the relative abundances of species in the model. Remember, these are just average values, not time series of observations.\nObserved biomasses could be derived from scientific surveys, underwater surveys or other observations or knowledge about relative biomasses of species. In well studied systems you might have data about biomass estimates, catches and fishing mortality from stock assessments. These type of data are often used to calibrate mizer models, although we need to be aware of the fact that stock assessment estimates are also model estimates and come with their own assumptions (e.g. they are single species estimates)."
  },
  {
    "objectID": "build/find-species-parameters.html#other-species-parameters",
    "href": "build/find-species-parameters.html#other-species-parameters",
    "title": "Finding species parameters",
    "section": "Other species parameters",
    "text": "Other species parameters\nThere are many other parameters that are used to describe species properties, but mizer has default ways to calculate them based on the size theory expectations. You can read about the theory in various publications or in the excellent Ken H Andersen book “Fish Ecology, Evolution, and Exploitation” (2019). So you don’t need to provide them, but you do need to understand the defaults and think whether you are happy with them. Mizer help pages provide a good summary of species parameters and links to functions that use these parameters.\nPredation kernel parameters\n\n\nPredator-prey mass ratio beta and width of predation kernel sigma The default values in mizer are beta = 30 and sigma = 2. However, higher beta values are usually in most mizer models for predatory fish and for fish that feed on plankton or benthic invertebrates these values are often in the range of 10000 or more. For example in the Curonian lagoon, bream and roach are benthivorous species. A 500g bream will feed on small invertebrates, like amphipods. If we use the generic length-weight conversion then a 0.5cm amphipod will weigh about 0.01*0.5^3 = 0.00125 grams. This gives the beta value at 2500000. However, beta represents a preferred predator prey size ratio, not the realised one. Most species prefer to eat larger prey, but their diets are dominated by small prey, since smaller individuals are more common. So beta values should generally be smaller than based on diet observations. For sigma many models used a value smaller than 2, but note that small sigma values make the steady state less stable (because predation is centered on a smaller range of prey sizes, exerting higher predation pressure on a small range of prey sizes. Again planktivores and benthivores would normally have large sigma values and predators smaller values. Let’s look at the beta and sigma values in the example North Sea model that comes with mizer\n\nremotes::install_github(\"sizespectrum/mizerExperimental\")\nlibrary(mizerExperimental)\nlibrary(tidyverse)\n\n\nspecies_params(NS_params) \n\n\n\n  \n\n\n\n\n\nFor the Curonian lagoon model we set the following beta values: we assume 100 for predatory fish, 10000 for large benthivores, 8000 and 600 for smaller benthivores and 5000 for planktivorous fish. Similarly we assume large sigma for planktivores and benthivores, and smaller values for predators.\n\ncuronian_species_params <-  read_csv(\"curonian_species_params_noRoach.csv\")\n\nRows: 9 Columns: 16\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (4): species, resilience, latinName, funcgr\ndbl (12): w_inf, w_mat, k_vb, beta, sigma, biomass_cutoff, biomass_observed,...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ncuronian_species_params[,c(1:6)]\n\n\n\n  \n\n\n\nMore advanced users may also want to change the shape of predation kernel\nParameters setting size dependent intake, maintenance and mortality rates\n\nSpecies search volume is set from the search rate constant gamma and its body size scaling exponent q If no values are provided gamma and q are set so that when prey abundance is described by the power law with the exponent lambda, food search rate will lead to the juvenile feeding level f0.\nSpecies maximum intake is set using constant h and body size scaling exponent n If no value is provided the coefficient h is set so as to achieve Von-Bertalanffy growth rate based estimate of maturity size at a given maturity age (given the feeding level f0). In multi-species models the exponent n is by default set to 2/3.\nSpecies metabolic rate is set from the constants ks and body size scaling exponent p If no values are provided the coefficient ks is set so that at maturation size metabolic expenditure requires fc (critical feeding) level of maximum intake. In multi-species models the exponent p is by default set to 0.7. Maintenance expenditure can also include activity related energetic costs, using species activity coefficient k which scales linearly with body size (exponent of 1). By default this value is set to 0 and most mizer models do not include it.\nSpecies external (also called background or baseline) size-independent mortality rate constant z0 This parameter determines the background mortality that affects all species size classes in the same way (it is a flat rate across sizes). If no values are provided mizer assumes that species with small maximum body sizes have much higher baseline mortality rate. For example, a species with w_inf = 35 g will have z0 = 0.18, a species with w_inf = 150g will have z0 = 0.11 and a species with w_inf = 14kg will have z0 = 0.025.\n\nFor the Curonian lagoon model we will let mizer set default values of size based rates and will assume that, as for mizer defaults, larval feeding level f0 = 0.6 and critical feeding level fc = 0.2.\nLet’s have a look at how mizer will set them up. For that we will need to call newMultispeciesParams() function and provide species parameter and species interaction dataframes. We will talk about about the interaction data late, so ignore it for now.\n\ncuronian_interaction <- read.csv(\"curonian_interaction_noRoach.csv\")\ncuron <- newMultispeciesParams(curonian_species_params, curonian_interaction)\n\nNote: Dimnames of interaction matrix do not match the order of species names in the species data.frame. I am now ignoring your dimnames so your interaction matrix may be in the wrong order.\n\n\nNo h provided for some species, so using f0 and k_vb to calculate it.\nNo ks column so calculating from critical feeding level.\nUsing z0 = z0pre * w_inf ^ z0exp for missing z0 values.\n\nspecies_params(curon) |> select(species, w_inf, funcgr, k_vb, ks, h, gamma, p, q, n, z0) \n\n\n\n  \n\n\n## ASTA - why is there no f0 in the species params file? \n## ASTA - I seem to be getting different q values when i run this code \n\nWe can see that mizer set default value of f0 to 0.6 and calculated other parameters. Have a look at how the instantaenous external (background) mortality z0 varies across species.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nBody size scaling exponents\nYou can also see that, unlike with the idealised trait-based model, the maximum intake, search rate and metabolism exponents are not set at 3/4 . There is a lot of debate about the correct values for these exponents. Some schools of thought argue that energy intake should scale with individual’s surface area (exponent of 2/3 ) whereas energy expenditure should scale with body volume (exponent of 1 ). Others suggest that food intake and metabolism exponents should both scale with 3/4 . There are no clear rules and these exponents in reality are likely to vary across species. But in most cases mizer users just go with defaults.\n\n\n\nReproduction related parameters\n\nSpecies maturation body weight is set with w_mat. Usually you would want to set them up yourself from life-history data, but if no data is available mizer will use 0.25 * w_inf For the Curonian lagoon model we selected maturation size from available biological data. The reproduction investment parameter m determines the scaling of the investment into reproduction for mature individuals. By default m = 1 which means that after maturation the rate at which individual fish invests energy into reproduction scales linearly with size (if you want more information, you can find it here). This default can be changed to another value if different scaling is preferred (e.g. in case you might want to explore hyper-allometric reproduction investment options). The steepness of population level energy allocation to reproduction is determined by w_mat25 and w_mat as you have learned in the previous tutorial on single species spectra.\nSpecies minimum body size in the model w_min If no value is provided mizer assumes 0.001\nSpecies reproduction parameters R_max and erepro. Mizer will set them to infinity and 1 respectively, but clearly these values are not good and will have to be tuned to achieved required numbers of larvae born into first size class and density dependence level (reproduction level). We will learn about these parameters and their tuning in the next tutorials.\n\n\nspecies_params(curon) |> select(species, w_inf, w_mat, w_min, m, R_max, erepro) \n\n\n\n  \n\n\n\nOther parameters\n\nYou can also modify availability of the resource to each of your species, as we have learned during week 1. This is set by the parameter interaction_resource and this value is set to 1 by default.\nSpecies feeding or satiation level at larval stage f0 If no value is provided mizer assumes 0.6.\nSpecies food assimilation efficiency alpha If no value is provided mizer assumes 0.6\nSpecies length-weight conversion coefficients a and b These coefficients are needed if maximum or maturation body size are provided in length or if we estimate h from Von Bertalanffy v_bk. If no values are provided mizer will assume 0.01 and 3, but for the Curonian lagoon model we collect these data from FishBase.\n\n\nspecies_params(curon) |> select(species, w_inf, a, b, alpha) \n\n\n\n  \n\n\n\n\n\n\n\n\n\nDanger\n\n\n\n\n\nLength-weight regression\nThe asymptotic length and weight are related as: W_\\infty = a \\cdot L_\\infty^b For many species length-weight conversion coefficients a and b are available on FishBase. Reasonable general values are: a = 0.01\\ \\mathrm{g/cm}^{-3} and b = 3."
  },
  {
    "objectID": "build/find-species-parameters.html#summary-of-key-parameters",
    "href": "build/find-species-parameters.html#summary-of-key-parameters",
    "title": "Finding species parameters",
    "section": "Summary of key parameters",
    "text": "Summary of key parameters\nIt is good to remember that, even though there are many parameters in mizer, you can start your model with just a few! However, if you don’t like defaults you can change them all. Advanced users can even overwrite mizer functions that calculate parameters. If you feel you need more advanced reading you can explore it here"
  },
  {
    "objectID": "build/find-species-parameters.html#parameters-defining-fishing",
    "href": "build/find-species-parameters.html#parameters-defining-fishing",
    "title": "Finding species parameters",
    "section": "Parameters defining fishing",
    "text": "Parameters defining fishing\nBecause most ecosystems are fished and we are calibrating to biomasses observed under some fishing level, we usually also need to include information on fishing intensity and fishing gear.\nIn mizer, fishing mortality rates at size for each gear are calculated as\nF = catchability\\cdot selectivity \\cdot effort\nIn complicated models we can have different gears, each with its own effort, fishing different species with different selectivity and catchability. Gear selectivity curve can have different shapes (logistic, knife-edge and others). You can read more about this here. For the simple Curonian lagoon model we will assume only one gear fishing with knife-edge selectivity at maturation size and average fishing mortality rate of 0.3. We will use one effort value because we only have one gear, but by adjusting species-specific catchability we can adjust fishing mortality for each species. For example, smallfish and ruffe in our model are not fished, so we will set their catchability to 0. Some species live close to the shore or are otherwise less vulnerable to commercial fishing, so we will set their cathability to 0.5. So the final list of\n\nspecies_params(curon) |> select(species, w_inf, catchability) \n\n\n\n  \n\n\n\nTO DO : Two minute video on how to use FishBase\n\n\n\n\n\n\nExercise 1: collecting species parameters from FishBase\n\n\n\n\n\nYou might have noticed that our species parameter file is missing one species that was listed in the initial table - roach (Rutillus rutillus). This is actually the most abundant species in the ecosystem. But we are missing its parameter values.\nYou goal in this exercise is to find parameter for roach. We will use FishBase, where many modellers get their species parameters.\nIn this exercise please open the curonian_species_params_exercise.csv file, go to FishBase, use the knowledge you gained so far and:\n1) Fill the NA values for roach\n2) Look up values for breams and see if you agree with our selection of parameter values.\nImportant! Make sure you check all the different sources of information that FishBase has. Scroll all the way down to “More information” section and explore Length-weight, Fecundity, Age/size, Food items, Diet and especially Growth sections.\nPlease commit this .csv file and push it to GitHub (just select the file as you selected other modified files). You will use the parameters that you found in the next tutorial."
  },
  {
    "objectID": "build/find-species-parameters.html#species-interaction-matrix",
    "href": "build/find-species-parameters.html#species-interaction-matrix",
    "title": "Finding species parameters",
    "section": "Species interaction matrix",
    "text": "Species interaction matrix\nThe next thing we will need to provide to mizer is a species interaction matrix. This matrix can include three different aspects (or a combination of all of them):\n\n\nSpatial and temporal overlap of species in a large ecosystem. This way the interaction matrix is set based on e.g. species occurrences in various fisheries surveys or observations and reflect the frequency of how often same species are found in same surveys. This is how species interactions are set up in the example North Sea model, which comes with mizer installation. Let’s check it (we will round the values to two decimal points). The North Sea interaction matrix file is called NS_interaction and comes with mizer installation.\n\nround(NS_interaction,2)\n\n        Sprat Sandeel N.pout Herring  Dab Whiting Sole Gurnard Plaice Haddock\nSprat    0.73    0.03   0.06    0.27 0.36    0.27 0.30    0.18   0.37    0.08\nSandeel  0.03    0.68   0.05    0.06 0.10    0.08 0.06    0.06   0.08    0.09\nN.pout   0.06    0.05   0.80    0.30 0.09    0.30 0.02    0.31   0.08    0.55\nHerring  0.27    0.06   0.30    0.66 0.29    0.37 0.20    0.28   0.28    0.35\nDab      0.36    0.10   0.09    0.29 0.81    0.33 0.38    0.22   0.56    0.13\nWhiting  0.27    0.08   0.30    0.37 0.33    0.71 0.19    0.37   0.30    0.39\nSole     0.30    0.06   0.02    0.20 0.38    0.19 0.72    0.11   0.39    0.03\nGurnard  0.18    0.06   0.31    0.28 0.22    0.37 0.11    0.88   0.16    0.36\nPlaice   0.37    0.08   0.08    0.28 0.56    0.30 0.39    0.16   0.72    0.11\nHaddock  0.08    0.09   0.55    0.35 0.13    0.39 0.03    0.36   0.11    0.86\nCod      0.34    0.10   0.33    0.40 0.42    0.44 0.26    0.35   0.35    0.40\nSaithe   0.02    0.02   0.29    0.13 0.03    0.10 0.01    0.12   0.03    0.26\n         Cod Saithe\nSprat   0.34   0.02\nSandeel 0.10   0.02\nN.pout  0.33   0.29\nHerring 0.40   0.13\nDab     0.42   0.03\nWhiting 0.44   0.10\nSole    0.26   0.01\nGurnard 0.35   0.12\nPlaice  0.35   0.03\nHaddock 0.40   0.26\nCod     0.79   0.21\nSaithe  0.21   0.66\n\n\n\nSpecies diet preferences or trophic groups. Sometimes we know that certain species do not eat other species. For example, some species are strictly bentivorous or herbivorous and they never eat any other fish, not even their larvae. In other cases we might have good evidence for specific diet preferences, although ideally such evidence should come from food selection experiments and these are very rare and maybe too specific to certain conditions. It is important to know that diet contents do not necessarily reflect preferences, but realised feeding. A species might prefer to eat bananas, but if nothing else is available it will eat other fish. The species interaction matrix, if reflecting diet preferences, should reflect preferred diets, not realised diets.\n\nSpecies predator avoidance behaviour or vulnerability. Some species may be less available to other species because they are good at hiding, have spikes, or live in large schools which reduces their vulnerability to predation compared to solitary species. This could also be included in the species interaction matrix, but in the prey column.\nFor our Curonian lagoon example model we used existing ecological knowledge and set up species interaction matrix as follows:\n\n\n\ncuron_interaction <-  read_csv(\"curonian_interaction.csv\")\n\nNew names:\nRows: 10 Columns: 11\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(1): ...1 dbl (10): smallfish, ruffe, breams, roach, vimba, carassius, perch,\npikeperc...\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -> `...1`\n\ncuron_interaction\n\n\n\n  \n\n\n\nIn our simple case the interaction matrix has two main components:\n\nWe either assume that prey (in columns) is available to a predator (in rows), hence the interaction matrix value for that predator row is set to 1.\nWe assume that strictly benthivorous fish species (breams, roach, vimba, carassius) cannot eat any other fish. This is based on the available knowledge about feeding habits. For these four species interaction matrix values are set to 0 for all fish."
  },
  {
    "objectID": "build/set-multiple-resources.html",
    "href": "build/set-multiple-resources.html",
    "title": "Setting up multiple resources",
    "section": "",
    "text": "Most mizer models simulate multiple size structured species and one background resource. But what if you want to account for different types of ‘resources’ with different dynamics? The most obvious case is the separation of pelagic and benthic resource. Benthic resource may not be important for offshore or pelagic ecosystems, but if you want to model coastal or freshwater ecosystems this may become essential.\nAdding benthic resource into multi-species and size based models is not new. Some researchers incorporate benthic food sources by explicitly modelling key benthic species as size-structured groups. This is fine if you have data on their biomases for calibration and if you are interested in their dynamics, but modelling many benthic species separately might be overwhelming. Instead, just like with plankton species, we might want to model all benthic organisms as a separate resource spectrum. That is what the mizerMR extension does.\nThe origin of mizerMR is a model for Tasmanian coastal rocky reef ecosystem, where most large fish are not predators (like in a classical size based marine ecosystem), but feed on benthic invertebrates. In such reefs, benthic production pathway is likely to be a major source of energy. The mizerMR framework has also been used in a Baltic Sea mizer model and a south-east Australian mizer model. There are other ways to incorporate benthic resources, and you can find some examples here, here and here, but none of these approaches are currently implemented in the main mizer code.\nThe Curonian Lagoon is a shallow water productive ecosystem, where benthic production constitutes an important source of energy. Like in many other coastal ecosystems, the most common species are benthivores.\nIn this tutorial we will modify our basic mizer model by adding an explicit benthic size structured resource."
  },
  {
    "objectID": "build/set-multiple-resources.html#step-1-get-mizermr",
    "href": "build/set-multiple-resources.html#step-1-get-mizermr",
    "title": "Setting up multiple resources",
    "section": "Step 1: Get mizerMR",
    "text": "Step 1: Get mizerMR\nmizerMR is an extension to the mizer package and it demonstrates a flexible way of adding new features, contributed by the mizer modeller community. If you modify mizer to add new features, please consider making an extension package and making it available for all mizer users.\nFirst, we will install mizerMR from GitHub.\n\nremotes::install_github(\"sizespectrum/mizerMR\")\nlibrary(mizerMR)\n\n# Also update and load mizerExperimental and tidyverse\nremotes::install_github(\"sizespectrum/mizerExperimental\")\n\n\n* checking for file ‘/tmp/Rtmpkg0Rkx/remotesfa761c9de2aa/sizespectrum-mizerExperimental-aa423f9/DESCRIPTION’ ... OK\n* preparing ‘mizerExperimental’:\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\n* building ‘mizerExperimental_2.3.1.tar.gz’\n\nlibrary(mizerExperimental)\nlibrary(tidyverse)"
  },
  {
    "objectID": "build/set-multiple-resources.html#step-2-set-new-resource-parameters",
    "href": "build/set-multiple-resources.html#step-2-set-new-resource-parameters",
    "title": "Setting up multiple resources",
    "section": "Step 2: Set new resource parameters",
    "text": "Step 2: Set new resource parameters\nNow we load the model parameter file that we saved in the previous tutorial (you will use the file with your parameters from the exercise in the previous tutorial).\n\n# Start with existing single species params\ncur_model <- readRDS(\"cur_model_single.rds\")\n\nNext, we need to add resource parameters for the benthic resource. We will go into the details of resource dynamics and its parameters in week 3 of this course. For now we just need to know that the steady state abundance of each resource is defined by four resource parameters. Like the species parameters, these resource parameters need to be provided in the form of a data frame, with one row for each resource and one column for each resource parameter. You could put the parameters into a spreadsheet, save it as a .csv file, and then import it into R, as we did for the species parameters. Here instead we will create the data frame directly in R. The columns we need are:\n\n\nresource - name for the resource\n\nkappa - resource overall abundance. It sets the ‘height’ of the resource spectrum. Strictly speaking this is resource abundance (g per unit area of your study) of resource at the size of 1g.\n\nlambda - slope of the resource spectrum.\n\nw_max - largest size of the resource.\n\nw_min - smallest size of the resource.\n\nPlanktonic paramters\nFor our plankton resource we use similar parameters to those for our existing single resource. Let us look at those first. Because our model is currently set up only with a single resource, the resource parameters are not in a data frame with one row for each resource but are simply a list:\n\nresource_params(cur_model)\n\n$kappa\n[1] 0.3831571\n\n$lambda\n[1] 2.05\n\n$r_pp\n[1] 10\n\n$n\n[1] 0.75\n\n$w_pp_cutoff\n[1] 10\n\n\nWe see that this list contains also parameters that we ignore for now because they are about the dynamics rather than the steady state abundance. Also, for historical reasons, the maximum size w_max is called w_pp_cutoff in the above list. We will keep the lambda and kappa parameters for the plankton spectrum.\n\nkappa <-  resource_params(cur_model)$kappa\nlambda <- resource_params(cur_model)$lambda\n\nWe will reduce the maximum size of the plankton spectrum from the current value of 10 grams (which corresponds to about 10cm long fish!) to 1 gram.\n\nw_max <- 1 \n\nTo choose a minimum size we look at the current minimum size which we can find in the first entry in the vector of size bins:\n\nw_full(cur_model)[[1]]\n\n[1] 9.533877e-13\n\n\nWe round this to 10^{-12}. (There is currently a problem if you try to use exactly the floating point value above, because due to rounding errors R will think that it is actually smaller than the existing smallest size and will issue an error message.)\n\nw_min <- 1e-12\n\nBenthic parameters\nNow we need to make decisions about the parameters for the benthic spectrum. We are aiming to reproduce ontogenetic diet shifts, where species start feeding on plankton and then may transition into the benthic spectrum. This means that, as plankton abundance decreases, benthos abundance should become relatively higher. To achieve that, we will start the benthos spectrum from a larger minimum size, extend it to much larger size than plankton spectrum, and have shallower slope for the benthos spectrum.\nIdeally, you would have size based benthos abundance or biomass data and fit a linear model to get the slope. This was done for the Tasmanian model (see supplementary materials in this preprint). For the Curonian lagoon we do not have such data, so we will just assume a slope of 1.9 instead of 2.05, but keep kappa equal for now. The benthic spectrum will extend to 10 grams to represent largest benthic invertebrates and some cryptic small benthic fish not explicitly included in the model.\nWe will save all resource parameters in separate variables, so we can use them later.\n\n# Set benthos kappa same as plankton kappa \nkappa_ben <- kappa\n# Assume more shallow slope for benthos \nlambda_ben <- 1.9\n# Set maximum benthos size \nw_max_ben <- 10\n# Benthos starts at larger sizes, corresponding to about 1-2mm\nw_min_ben <- 0.0001\n\nNow we put all these resource parameters into a data frame.\n\ncuronian_resource_params <- data.frame(\n    resource = c(\"pl\", \"bb\"),\n    lambda = c(lambda, lambda_ben),\n    kappa = c(kappa, kappa_ben),\n    w_min = c(w_min, w_min_ben),\n    w_max = c(w_max, w_max_ben)\n)\n\ncuronian_resource_params\n\n\n\n  \n\n\n\nWe can now update our Curonian model to use these resource parameters with\n\nresource_params(cur_model) <- curonian_resource_params"
  },
  {
    "objectID": "build/set-multiple-resources.html#step-3-set-resource-interactions",
    "href": "build/set-multiple-resources.html#step-3-set-resource-interactions",
    "title": "Setting up multiple resources",
    "section": "Step 3: Set resource interactions",
    "text": "Step 3: Set resource interactions\nThe next and most interesting step is to define the availability of each resource to our model species. This is where our biological and ecological knowledge comes in, but we may need to adjust these values to ensure we get the expected ontogenetic diet shifts.\nBy default all resource interactions are set to 1.\n\nresource_interaction(cur_model)\n\n               resource\nsp              pl bb\n  smallfish      1  1\n  ruffe          1  1\n  breams         1  1\n  roach          1  1\n  vimba          1  1\n  carassius      1  1\n  perch          1  1\n  pikeperch      1  1\n  burbot         1  1\n  predator_fish  1  1\n\n\nIn this simple model we will assume that largely planktivorous small fish have full access to the plankton resource, and can only access a small fraction (0.2) of the benthic resource. For benthivorous fish, like vimba, carassius, breams, roach and ruffe we give full access to the benthic resource and reduce availability of plankton to 0.5. Remember, all fish start by feeding on plankton, so they all should have enough access to the plankton resource. We might need to increase this value if it seems that small fish don’t grow fast enough. For a small sized ruffe we increase plankton availability to 0.8. For predatory fish we set both plankton and benthos availability to 0.5. This is to ‘encourage’ them to start feeding on other fish.\n\n#set vectors of plankton and benthos availability for the model species \nplankton_avail <- c(1, 0.8, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)\nbenthos_avail <- c(0.2, 1, 1, 1, 1, 1, 0.5, 0.5, 0.5, 0.5)\n\n#put them into corresponding columns of resource_interaction matrix\nresource_interaction(cur_model)[, 1] <- plankton_avail\nresource_interaction(cur_model)[, 2] <- benthos_avail\n\nAgain, like with the species interaction matrix, you could also have set up the resource interaction matrix in an external spreadsheet program and then imported it from a .csv file."
  },
  {
    "objectID": "build/set-multiple-resources.html#step-4-find-new-steady-state",
    "href": "build/set-multiple-resources.html#step-4-find-new-steady-state",
    "title": "Setting up multiple resources",
    "section": "Step 4: find new steady state",
    "text": "Step 4: find new steady state\nWe have now changed resource availability quite a bit. This has changed the growth rates and hence we need to recalculate the steady state. We will use the same set of functions as in the single resource model in the previous tutorial.\n\ncur_model <- steady(cur_model)\n\nConvergence was achieved in 18 years.\n\nplotSpectra(cur_model, power = 2)\n\n\n\n\nNote how the plot now displays both resources. The change in resource will of course also have had an effect on the species abundances, so the model biomasses will no longer match the observed biomasses:\n\nplotBiomassVsSpecies(cur_model)\n\n\n\n\nLuckily we already know from the previous tutorial what to do: repeatedly match the biomasses with matchBiomasses() and run back to steady state with steady() until we converge to a steady state with the correct biomasses.\n\n# repeat a few more times (in case your parameters take longer to converge)\ncur_model <- cur_model |> \n    matchBiomasses() |> steady() |>\n    matchBiomasses() |> steady() |>\n    matchBiomasses() |> steady() |>\n    matchBiomasses() |> steady() |>\n    matchBiomasses() |> steady() |>\n    matchBiomasses() |> steady()\n\nConvergence was achieved in 16.5 years.\n\n\nConvergence was achieved in 15 years.\nConvergence was achieved in 15 years.\n\n\nConvergence was achieved in 10.5 years.\n\n\nConvergence was achieved in 6 years.\n\n\nConvergence was achieved in 1.5 years.\n\nplotBiomassVsSpecies(cur_model)\n\n\n\n\n\nplotSpectra(cur_model, power = 2)\n\n\n\n\nLet us save the model. We choose the file name to reflect that the model is still not finely tuned. We will improve it in the next tutorial.\n\nsaveParams(cur_model, \"cur_model_coarse.rds\")"
  },
  {
    "objectID": "build/set-multiple-resources.html#step-5-explore-model-properties",
    "href": "build/set-multiple-resources.html#step-5-explore-model-properties",
    "title": "Setting up multiple resources",
    "section": "Step 5: explore model properties",
    "text": "Step 5: explore model properties\nLet’s check the diets and see if we can now observed ontogenetic diet shifts.\n\nplotDiet(cur_model)\n\n\n\n\nThis is looking reasonably good. Benthivores, such as ruffe, breams, roach, vimba and carrasius start in the plankton spectrum and then transition to feeding on benthos. They don’t transition fully, which we need to work on. Adult benthivores should really only eat benthos and no plankton. We can probably fix that by increasing abundance kappa for the benthic resource or making its slope lambda even more shallow. Predators nicely start on plankton, transition to benthos and then to fish. For the largest predators, such as predator_fish and pikeperch we want adult diets to consist almost entirely of fish. So we might need to reduce benthic resource availability to these species. You can do that now and explore the outcomes, or we will do it in the next tutorial.\nNext, let’s have a look at the sources of death. We will plot them as proportional and as absolute rates.\n\nplotDeath(cur_model, proportion = T)\n\n\n\nplotDeath(cur_model, proportion = F)\n\n\n\n\nNote that unlike in the trait based model, where mortality was decreasing as a power law, the absolute mortality rate curves now look like bell-shaped curves. Mortality rates on smallest fish are actually very small. This is for three reasons. First, at these sizes we have A LOT of resource, so predators in the model do not eat small fish which are relatively less abundant. Second, we do not have all that many predators in this ecosystem, so they don’t exert extensive mortality (although mortality at about 1 g size is pretty high). Third, in real ecosystems, resource (plankton and small organisms) would be feeding on fish eggs and larvae, but our resources do not feed. Such belled shaped natural mortality curves seem to be common in multi-species models, and we don’t yet have a good solution to address them. We could, like in trait-based models impose external mortality to make sure that mortality scales with a power law. However, unlike in the idealised trait-based models we do not know how much natural mortality will actually occur in a multi-species model. So deciding the extra mortality level to add is difficult. During the week 3 we will be refining this model and mortality curves might change. But this aspect illustrates the fact that multi-species modelling is a rapidly developing field, and we don’t yet know how best to represent complex ecosystems in a simplified model.\nWe also want to know about the predation on both resources, so we will plot that too\n\nplotResourcePred(cur_model, proportion = T)\n\n\n\nplotResourcePred(cur_model, proportion = F)\n\n\n\n\nIt is interesting to see how the highest absolute mortality (plots with proportion = F) is at resource size of about 0.1g (1e-1) and this applies to both benthos and plankton. Smallest sizes of plankton are not eaten at all, as no fish feed in that size range. Also the absolute mortality is higher on benthos (> 0.8/year) than on plankton (0.5/year). Still this mortality is low and we should probably decrease the overall resource abundance, to achieve more realistic values. Let’s see if we can address this in week 3.\nFinally, let’s check whether species are growing properly, given that resource availabilities to them have now been changed. We will also look at the feeding level of all species\n\nplotGrowthCurves(cur_model, species_panel = T)\n\n\n\nplotFeedingLevel(cur_model)\n\n\n\n\nWe can see that smallest fish (smallfish and ruffe) and benthivores are growing pretty well, although predators should probably be growing a little faster. Feeding levels look reasonable and surprisingly close to the default larval value of f0 = 0.6. This means that slow growth rates of predators are likely not due to the lack of food, but insufficient intake rates.\nYou can play with the resource_interaction() and resource parameters (kappa and lambda), but this will be our main goal in the next tutorial on refining our models."
  },
  {
    "objectID": "build/set-multiple-resources.html#exercise",
    "href": "build/set-multiple-resources.html#exercise",
    "title": "Setting up multiple resources",
    "section": "Exercise",
    "text": "Exercise\nIn this exercise please follow all these steps needed to modify the model you built in the last tutorial to include a benthic resource. Use the worksheet “worksheet-3-set-multiple-resources.Rmd” for this tutorial to submit your result."
  },
  {
    "objectID": "build/set-multiple-resources.html#summary",
    "href": "build/set-multiple-resources.html#summary",
    "title": "Setting up multiple resources",
    "section": "Summary",
    "text": "Summary\n1) The “mizerMR” package extends mizer to allow for multiple resource spectra.\n2) The resource parameters are collected in a data frame with one row for each resource. They are added to the model with resource_params().\n3) The strength with which species feed on the different resources is set with resource_interaction().\n4) Finding a steady state with the desired species biomasses proceeds in the same manner as for a model with a single resource.\n5) We chose parameters for the plantonic and the benthic resource to get the desired ontogenetic shift in the fish diets."
  },
  {
    "objectID": "build/refine-model.html",
    "href": "build/refine-model.html",
    "title": "Refine model",
    "section": "",
    "text": "We have a basic model with two background resources. This model produces somewhat reasonable diets, reasonable growth and we also managed to fit the model to the observed average biomasses. But there are more things we want to tune and match, while still staying in a steady state, with constant reproduction and resource levels. We have average catch data and size distributions of catches. We also want predators to eat more fish. So let’s explore how we can tune our model further.\nA large fraction of tuning can be done using a tuneParams() R Shiny gadget that is integrated into mizerExperimental. But because we are using a multiple resource add-on, we will need to install a different branch of mizerExperimental, which will include an updated tuneParams() R Shiny gadget that incorporates multiple resources. This is still work in progress, so please be patient if you find bugs or some other annoying features (please report them, so we can keep improving the tools). To install a specific branch (in our case tuneMR branch) of a package located on GitHub we need to indicate it in the ref= argument. You might need to restart your R session for this to work. Also, remember that next time, if you want to use the main branch of mizerExperimental (without multiple resources) you will need to reinstall it, but without the ref= parameter.\n\nremotes::install_github(\"sizespectrum/mizerExperimental\", ref = \"tuneMR\")\n\n\n* checking for file ‘/tmp/RtmpzQPjS2/remotesfd7c49453a87/sizespectrum-mizerExperimental-0b82838/DESCRIPTION’ ... OK\n* preparing ‘mizerExperimental’:\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\n* building ‘mizerExperimental_2.3.1.7777.tar.gz’\n\nremotes::install_github(\"sizespectrum/mizerMR\")\nlibrary(mizerExperimental)\nlibrary(mizerMR)\nlibrary(tidyverse)\n\nNow let’s load our latest model with two background resources. If you found your own species parameters for roach (and perhaps for breams) and used those parameters in tutorial 2 and 3, you will load your own model version.\n\ncur_model_coarse <- readParams(\"cur_model_coarse.rds\")"
  },
  {
    "objectID": "build/refine-model.html#catch-data",
    "href": "build/refine-model.html#catch-data",
    "title": "Refine model",
    "section": "Catch data",
    "text": "Catch data\nWe will also load data on the size distribution of catches. Such data is often collected in data-poor fisheries, so it will be useful to see how we can use such data for model calibration. This specific dataset is not really from commercial fisheries in Curonian lagoon, but from some years of scientific surveys, where only commercial mesh sizes were used.\n\ncatch_lengths <- readRDS(\"catch.rds\")\nhead(catch_lengths)\n\n\n\n  \n\n\n\nYou can see that for each species we have numbers of individuals observed in 2cm wide length bins (the dl column indicates the width of each bin).\nRemember that in the species parameter data frame we included a column of yield_observed that gives the average annual commercial catches over a certain time period. These are not accurate, but it does not matter here because we use them for illustration purposes only.\n\nspecies_params(cur_model_coarse) |> select(species, yield_observed)"
  },
  {
    "objectID": "build/refine-model.html#calibrating-total-yield",
    "href": "build/refine-model.html#calibrating-total-yield",
    "title": "Refine model",
    "section": "Calibrating total yield",
    "text": "Calibrating total yield\nLet’s first check whether the model yield matches the observed yield.\n\nplotYieldVsSpecies(cur_model_coarse)\n\n\n\n\nThe observed yield is some orders of magnitude larger than model yield. This is because our yield and biomasses are in different units or scales. The biomasses we used for calibration are relative biomasses from scientific surveys. It is hard to know how exactly to scale them to area, so we just used the relative values. The yield, on the other hand, is the reported commercial yield for the entire model area. So naturally they are on very different scales. What we need to do now is to rescale our biomasses so they are in approximately the same units.\nLet’s calibrate the yield, like we calibrated biomasses. If you didn’t have the biomasses for your system, but know the yield and fishing mortalities, this is how you would calibrate your model.\n\ncur_model <- calibrateYield(cur_model_coarse)\nplotYieldVsSpecies(cur_model)\n\nWarning: Removed 1 rows containing missing values (geom_segment).\n\n\n\n\n\nNow the yields are in a similar scale, and this has rescaled abundances of all species by the same factor (like one would calibrate a device). We now still need to rescale our biomass observations by the same factor so convert them from their relative scale to the same absolute scale as the yields.\n\n# Find the scaling factor by dividing abundances of calibrated and initial model \n# (We can use any species and any size, because they all were scaled by the \n# same factor.)\nscaling_factor <- initialN(cur_model)[1, 1] / initialN(cur_model_coarse)[1, 1]\nscaling_factor\n\n[1] 2680.075\n\n# Rescale the observed biomass values by that factor\nspecies_params(cur_model)$biomass_observed <- \n    species_params(cur_model)$biomass_observed * scaling_factor\n\nNow that we have scaled both the model biomasses and the observed biomasses by the same factor, they are of course again in agreement:\n\nplotBiomassVsSpecies(cur_model)"
  },
  {
    "objectID": "build/refine-model.html#exploring-catch-size-distributions",
    "href": "build/refine-model.html#exploring-catch-size-distributions",
    "title": "Refine model",
    "section": "Exploring catch size distributions",
    "text": "Exploring catch size distributions\nNow we want to know whether our modelled and observed catch size distributions agree. The plotYieldVsSize() function lets us see how well they match:\n\nplotYieldVsSize(cur_model, species = \"breams\", catch = catch_lengths, \n                x_var = \"Length\")\n\n\n\n\nThey don’t match very well at all. The modelled catch has a peak earlier than the observed catch. Clearly our guess that for each species the selectivity reaches 50% at 30cm length is incorrect. There are R tools to estimate selectivity curves, but we will just assume that 50% selectivity is at 35cm (inflection point of the logistic selectivity curve) and 25% selectivity is at 32 cm (value, defining steepness of the curve). We will adjust these values using gear_params() function.\nLet us look at the current gear parameter data frame first.\n\n# Let's look at our gear params first \ngear_params(cur_model)\n\n\n\n  \n\n\n\nWe notice that the row names are made up of the species name and the gear name, separated by a comma. So we can change the selectivity parameters specifically for breams with\n\n# Modify the l50 and l25 for breams\ngear_params(cur_model)[\"breams, Main\", \"l50\"] <- 35\ngear_params(cur_model)[\"breams, Main\", \"l25\"] <- 32\n\n#check the match between model and observed catch size distributions\nplotYieldVsSize(cur_model, species = \"breams\", catch = catch_lengths, \n                x_var = \"Length\")\n\n\n\n\nThis looks much better. But now that we have changed fishing selectivity we need to find a new steady state. It is important to run steady() frequently, while making small changes to the model parameters. If we accumulate too many changes, finding a new steady state might be harder.\n\ncur_model <- steady(cur_model)\n\nConvergence was achieved in 10.5 years.\n\n\nNote that even this small change in the selectivity of the gear has increased the biomass of breams, as would be expected.\n\nplotBiomassVsSpecies(cur_model)\n\n\n\n\nThis illustrates a general point: as we change parameters to get one aspect of the model to agree with observations, other aspects will stop to agree.\nNow you can look at the catch size distributions for some other species.\nOf course, the size distributions of catches will depends on fishing mortality, on correct representation of species growth and predation mortality. We can see that setting the same selectivity for ruffe was not correct, because it is a small bodied species and it would not be caught with the same gear. This and many other aspects we can explore further using the R Shiny gadget, which we call with the tuneParams() function. If you have catch length data, make sure to pass it into the tuneParams() function via the catch argument.\n\ncur_model <- tuneParams(cur_model, catch = catch_lengths)\n\nNote how we assign the return value from the tuneParams() function back to the cur_model variable. That way we capture the changes that we make in the gadget.\n\n\n\n\n\n\n\n\n\nThe tuneParams() gadget has a lot of useful panels and allows you to play with the parameters interactively. But most of these plots are also available as separate plot functions in mizer or in mizerExperimental."
  },
  {
    "objectID": "build/refine-model.html#exercise-use-tuneparams-gadget-to-refine-your-model",
    "href": "build/refine-model.html#exercise-use-tuneparams-gadget-to-refine-your-model",
    "title": "Refine model",
    "section": "Exercise: Use tuneParams gadget to refine your model",
    "text": "Exercise: Use tuneParams gadget to refine your model\nIn our video we only started refining the model by adjusting some parameters for a few species. We ask you to do something similar but for all species in order to refine the model you have built in the previous tutorial. We are very interested in seeing the model that you come up with. We will collect the models from all participants to give us an ensemble of models to use next week. Please use the worksheet “worksheet-4-refine-model.Rmd” to commit your model."
  },
  {
    "objectID": "build/create-first-model.html",
    "href": "build/create-first-model.html",
    "title": "Building a new multi-species model",
    "section": "",
    "text": "Setting up a mizer model that agrees with observations used to be difficult. That is not a surprise, because we have seen how all the species influence each other, as well as the resource, and how the reproduction rates of all species depend on the size spectra of all species and vice versa. So if you make changes at one end of the model to make it agree with some observation, things change at the other end to mess things up again.\nThere are three dynamic processes in action in a mizer model at the same time: size-spectrum dynamics, reproduction dynamics and resource dynamics. These are fully interacting with each other, with feedback loops. So for example the resource spectrum depends on the consumption by fish, which depends on the fish size spectra, which depend on the fish growth rates, which depends on the resource spectrum. Similarly the reproduction rate depends on the number of mature fish and on their energy income, which depends among other things on the rate at which new individuals are recruited, which depends among other things on the reproduction rate. And all of these processes depend on the model parameters that we are supposed to choose in a way that reproduces observed behaviour. It seems hopeless!\nThe way we have arrived at a simple process for the creation of a viable mizer model is to decouple the tuning of the size spectrum dynamics from the tuning of the reproduction dynamics and resource dynamics. So, as we have done last week, initially we turn off reproduction dynamics and resource dynamics. We set the constant reproduction rate to a level that produces the observed biomasses and we set the constant resource spectrum according to observations or, in the absence of observations, we set it to a Sheldon power law. We then use that size spectrum dynamics on its own quickly settles down to its steady state, so that we can interactively tune parameters to get the steady state to agree with observations.\nOnce we are happy with the steady state of the model, we turn the reproduction and resource dynamics back on, but with parameter choices that do not modify the steady state of the coupled system. We then have to tune the remaining parameters of the reproduction dynamics and resource dynamics to achieve the correct sensitivity of the system to perturbations away from its steady state. But by separating this tuning of the dynamics from the tuning of the steady state, the whole process becomes much more manageable.\nWe will concentrate on building models with the correct steady state this week and then tune the behaviour away from steady state next week.\nIn this tutorial we will take the species parameters that we assembled in the previous tutorial for the Curonian lagoon and use the newMultispeciesParams() function to build a mizer model with them. We will let mizer choose most of the defaults and then adjust a few things so that the model has a steady state that has the observed species biomasses and growth curves. We will not do any fine-tuning of the steady state because the first big improvement that we will make in the next tutorial will be to add multiple resource spectra, as is appropriate for this shallow coastal ecosystem.\nAs always, we start by loading packages.\n\nremotes::install_github(\"sizespectrum/mizerExperimental\")\n\nrlang       (1.0.3   -> 1.0.4) [CRAN]\nhtmltools   (0.5.2   -> 0.5.3) [CRAN]\nRcpp        (1.0.8.3 -> 1.0.9) [CRAN]\nfontawesome (0.2.2   -> 0.3.0) [CRAN]\npillar      (1.7.0   -> 1.8.0) [CRAN]\ntibble      (3.1.7   -> 3.1.8) [CRAN]\nfarver      (2.1.0   -> 2.1.1) [CRAN]\nstringi     (1.7.6   -> 1.7.8) [CRAN]\nshiny       (1.7.1   -> 1.7.2) [CRAN]\ndeSolve     (1.32    -> 1.33 ) [CRAN]\nrintrojs    (0.3.0   -> 0.3.2) [CRAN]\npackage 'rlang' successfully unpacked and MD5 sums checked\n\n\nWarning: cannot remove prior installation of package 'rlang'\n\n\nWarning in file.copy(savedcopy, lib, recursive = TRUE): problem copying C:\n\\Users\\Gustav\\AppData\\Local\\R\\win-library\\4.2\\00LOCK\\rlang\\libs\\x64\\rlang.dll\nto C:\\Users\\Gustav\\AppData\\Local\\R\\win-library\\4.2\\rlang\\libs\\x64\\rlang.dll:\nPermission denied\n\n\nWarning: restored 'rlang'\n\n\npackage 'htmltools' successfully unpacked and MD5 sums checked\n\n\nWarning: cannot remove prior installation of package 'htmltools'\n\n\nWarning in file.copy(savedcopy, lib, recursive = TRUE):\nproblem copying C:\\Users\\Gustav\\AppData\\Local\\R\\win-\nlibrary\\4.2\\00LOCK\\htmltools\\libs\\x64\\htmltools.dll to C:\n\\Users\\Gustav\\AppData\\Local\\R\\win-library\\4.2\\htmltools\\libs\\x64\\htmltools.dll:\nPermission denied\n\n\nWarning: restored 'htmltools'\n\n\npackage 'Rcpp' successfully unpacked and MD5 sums checked\npackage 'fontawesome' successfully unpacked and MD5 sums checked\npackage 'pillar' successfully unpacked and MD5 sums checked\npackage 'tibble' successfully unpacked and MD5 sums checked\npackage 'farver' successfully unpacked and MD5 sums checked\npackage 'stringi' successfully unpacked and MD5 sums checked\n\n\nWarning: cannot remove prior installation of package 'stringi'\n\n\nWarning in file.copy(savedcopy, lib, recursive = TRUE): problem copying C:\n\\Users\\Gustav\\AppData\\Local\\R\\win-library\\4.2\\00LOCK\\stringi\\libs\\icudt69l.dat\nto C:\\Users\\Gustav\\AppData\\Local\\R\\win-library\\4.2\\stringi\\libs\\icudt69l.dat:\nInvalid argument\n\n\nWarning in file.copy(savedcopy, lib, recursive = TRUE):\nproblem copying C:\\Users\\Gustav\\AppData\\Local\\R\\win-\nlibrary\\4.2\\00LOCK\\stringi\\libs\\x64\\stringi.dll to C:\n\\Users\\Gustav\\AppData\\Local\\R\\win-library\\4.2\\stringi\\libs\\x64\\stringi.dll:\nPermission denied\n\n\nWarning: restored 'stringi'\n\n\npackage 'shiny' successfully unpacked and MD5 sums checked\npackage 'deSolve' successfully unpacked and MD5 sums checked\npackage 'rintrojs' successfully unpacked and MD5 sums checked\n\nThe downloaded binary packages are in\n    C:\\Users\\Gustav\\AppData\\Local\\Temp\\Rtmp6fMkfA\\downloaded_packages\n* checking for file 'C:\\Users\\Gustav\\AppData\\Local\\Temp\\Rtmp6fMkfA\\remotes33c865fe11d4\\sizespectrum-mizerExperimental-f2d9e2f/DESCRIPTION' ... OK\n* preparing 'mizerExperimental':\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\n* building 'mizerExperimental_2.3.1.tar.gz'\n\n\nlibrary(mizerExperimental)\nlibrary(tidyverse)"
  },
  {
    "objectID": "build/create-first-model.html#step-1-create-mizerparams-object",
    "href": "build/create-first-model.html#step-1-create-mizerparams-object",
    "title": "Building a new multi-species model",
    "section": "Step 1: Create MizerParams object",
    "text": "Step 1: Create MizerParams object\nWe collected the species parameters and the interaction matrix for our model in the previous tutorial and saved them as .csv files. So here we only need to read in those files.\n\ncuronian_species_params <- read.csv(\"curonian_species_params.csv\")\ncuronian_interaction <- read.csv(\"curonian_interaction.csv\", row.names = 1)\n\nWe use rownames = 1 to let read.csv know that the first column in the spreadsheet, which contains the predator names, should be used as the names of the rows of the interaction matrix.\nIf you want to check that the data was read in correctly, you can click on curonian_species_params and curonian_interaction in the “Environment” tab. That will open the data frames in your editor window.\nWe will now set up a multi-species mizer model using the function newMultispeciesParams(). Besides the species parameters and the interaction matrix, the other information that flows into a multi-species model are the resource parameters, the gear parameters and the fishing effort.\nWe let mizer choose defaults for the resource parameters and gear parameters. By default, the resource carrying capacity will be set to a power law N_R(w) = \\kappa w^{-\\lambda} with \\lambda = 2.05, as we are already familiar with from week 1.\nThe default fishing gear selects all individuals above maturity size of all species with a catchability of 1. So if we set the fishing effort to 0.3 that imposes a fishing mortality of 0.3 per year on those fish.\nLast week we discussed that natural choice for the allometric exponents n (growth exponent) and p (metabolic exponent) is to take them both equal to 3/4. That is the choice we will use.\nWith this information we call the function newMultispeciesParams() which returns a MizerParams object that we save in the variable cur_model (lazy shorthand for “Curonian model”):\n\ncur_model <- newMultispeciesParams(species_params = curonian_species_params, \n                                   interaction = curonian_interaction, \n                                   initial_effort = 0.3,\n                                   lambda = 2.05, n = 3/4, p = 3/4)\n\nNo h provided for some species, so using f0 and k_vb to calculate it.\nNo ks column so calculating from critical feeding level.\nUsing z0 = z0pre * w_inf ^ z0exp for missing z0 values.\n\n\nAs you see from the messages it has printed, the newMultispeciesParams() function has made choices for some model parameters based on the information we supplied.\nSo for example it chose the coefficient h of the maximum intake rate for each species to produce growth curves that are roughly in agreement with the von Bertalannfy growth parameters k_vb that we supplied and with a larval feeding level f0 (which we did not supply but which mizer chose as f0 = 0.6).\nMizer chose the coefficient ks of the metabolic rate for each species so that a proportion fc of the maximum intake rate would be enough to cover the metabolic expenses. We did not specifiy this critical feeding level fc so mizer chose fc = 0.2.\nFinally mizer has set a constant background mortality z0 that scales with the species’ asymptotic size. Let’s look at the result:\n\nspecies_params(cur_model) |> select(h, ks, z0)"
  },
  {
    "objectID": "build/create-first-model.html#step-2-project-to-steady-state",
    "href": "build/create-first-model.html#step-2-project-to-steady-state",
    "title": "Building a new multi-species model",
    "section": "Step 2: Project to steady state",
    "text": "Step 2: Project to steady state\nThe newMultispeciesParams() function is not very good at choosing a good initial community configuration. Let’s have a look at what is has set up:\n\nplotSpectra(cur_model, power = 2)\n\n\n\n\nThere is a lot wrong here. The species spectra lack the characteristic bulge at adult sizes. Also the species spectra do not line up nicely with the abundance of the resource. But most importantly, these spectra are not close to their steady state values.\nWe will now project to the steady state, which will finally give us realistic species spectra. To do this we use the special function steady() which implements our trick of keeping the reproduction rate and the resource spectrum constant.\n\ncur_model <- steady(cur_model)\n\nConvergence was achieved in 15 years.\n\n\nWarning in setBevertonHolt(params, reproduction_level = old_reproduction_level):\nThe following species require an unrealistic reproductive efficiency greater\nthan 1: roach\n\n\nWe can ignore the warning from the setBevertonHolt() function about unrealistic reproductive efficiencies. Those warnings are an artefact of how the reproduction level is set by default by the matchBiomasses() function. We could fix those defaults, but we are not yet concerned with the reproduction dynamics so we don’t have to do that and just ignore the warnings.\nNow let us look at the spectra in the steady state:\n\nplotlySpectra(cur_model, power = 2)\n\n\n\n\n\n\n\n\n\n\n\nIf step 2 fails\n\n\n\n\n\nThe steady() function is not guaranteed to find the steady state. It may be that the steady state is actually unstable. In that case the system evolves towards an oscillating state instead. This is luckily rare for realistic parameters, but may well happen while you are still trying to find the correct parameters. Let us illustrate this in a modified model. We decrease the width of the feeding kernel for all species to sigma = 1 and increase the slope of the resource spectrum to lambda = 2.2. We know from mathematical studies that both of these changes have a destabilising effect.\n\nmodified_species_params <- curonian_species_params\nmodified_species_params$sigma <- 1\n\nmodified_model <- \n    newMultispeciesParams(species_params = modified_species_params,\n                          interaction = curonian_interaction,\n                          initial_effort = 0.3,\n                          lambda = 2.2, n = 3/4, p = 3/4)\n\nNo h provided for some species, so using f0 and k_vb to calculate it.\nNo ks column so calculating from critical feeding level.\nUsing z0 = z0pre * w_inf ^ z0exp for missing z0 values.\n\n\nNow let us see what happens when we try to run this system to steady state:\n\nmodified_model <- steady(modified_model)\n\nSimulation run did not converge after 99 years. Value returned by the distance function was: 0.759089044351571\n\n\n\nsim <- steady(modified_model, return_sim = TRUE)\n\nSimulation run did not converge after 99 years. Value returned by the distance function was: 1.7392491172154\n\n\n\nplotBiomass(sim)"
  },
  {
    "objectID": "build/create-first-model.html#step-3-calibrate-the-scale",
    "href": "build/create-first-model.html#step-3-calibrate-the-scale",
    "title": "Building a new multi-species model",
    "section": "Step 3: Calibrate the scale",
    "text": "Step 3: Calibrate the scale\nMizer is agnostic of whether you want to measure biomass per square meter, or per square kilometer, or for the entire area of the fishery or whatever. So initially it had set things up on an arbitrarily chosen scale. We can see this if we compare the biomasses of the species in the model with the observed biomasses from your species parameter file with the plotBiomassVsSpecies() function:\n\nplotBiomassVsSpecies(cur_model)\n\n\n\n\nThis shows for each species the model biomass (open circle) and the observed biomass (filled square) on a logarithmic y-axis. The line connecting model value and observed value is for visual purposes only. We see that model values and observed values are many orders of magnitude apart.\nUsing your supplied biomass observations, mizer can now calibrate its scale so that the total biomass in the model coincides with the total observed biomass, summed over all species.\n\ncur_model <- calibrateBiomass(cur_model)\n\nOf course for the individual species the model biomasses will still disagree with the observed biomasses, with some being too high while others are too low. Just the total summed over all species agrees between model and observation.\n\nplotBiomassVsSpecies(cur_model)"
  },
  {
    "objectID": "build/create-first-model.html#step-4-rescale-species-spectra",
    "href": "build/create-first-model.html#step-4-rescale-species-spectra",
    "title": "Building a new multi-species model",
    "section": "Step 4: Rescale species spectra",
    "text": "Step 4: Rescale species spectra\nTo fix the discrepancy between the model biomasses and the observed biomasses we simply need to rescale the abundance of each species by the appropriate factor. The matchBiomasses() function does this for us.\n\ncur_model <- matchBiomasses(cur_model)\nplotBiomassVsSpecies(cur_model)\n\n\n\n\nNow the circles and squares lie on top of each other.\nThere are similar functions matchNumbers() and matchYields() that you would use in case either total numbers of individuals or fisheries yields are known instead of total biomasses."
  },
  {
    "objectID": "build/create-first-model.html#step-5-rinse-and-repeat",
    "href": "build/create-first-model.html#step-5-rinse-and-repeat",
    "title": "Building a new multi-species model",
    "section": "Step 5: Rinse and repeat",
    "text": "Step 5: Rinse and repeat\nRescaling the spectra of the individual species has not created another steady state. All species now experience a new prey distribution and a new predator distribution and so their growth and death rates have changed, which requires us to run the dynamics again to find the new steady state. So we essentially go back to step 2 and project to steady state:\n\ncur_model <- steady(cur_model)\n\nSimulation run did not converge after 99 years. Value returned by the distance function was: 0.182533427975559\n\n\nThe function tell us that running the dynamics for 99 years was not enough to converge sufficiently close to the steady state. In other words, the state was still changing after 99 years. There are now two possibilities: 1) the dynamics will never converge to a steady state but instead continue to oscillate for ever or 2) we simply need to be a bit more patient. Let’s hope for the second option and call steady() again.\n\ncur_model <- steady(cur_model)\n\nSimulation run did not converge after 99 years. Value returned by the distance function was: 0.0280180720197587\n\n\nWe were lucky and only had to wait for another 13.5 years. We’ll discuss what to do when we are not lucky in the When things don’t go smoothly section.\nBut while the system settled down to the new steady state, the species biomasses have changed, so they now no longer agree with observation.\n\nplotBiomassVsSpecies(cur_model)\n\n\n\n\nWe appear to be in a bind: If we match the biomasses we are no longer at steady state, if we run to steady state we no longer match the biomasses. But notice that the discrepancies are not as big as previously. So we don’t give up but simply keep iterating.\nAfter repeating the cycle of matching biomasses and running to steady state 10 more times we get this picture:\n\ncur_model <- cur_model |>\n    matchBiomasses() |> steady() |> matchBiomasses() |> steady() |>\n    matchBiomasses() |> steady() |> matchBiomasses() |> steady() |>\n    matchBiomasses() |> steady() |> matchBiomasses() |> steady() |>\n    matchBiomasses() |> steady() |> matchBiomasses() |> steady() |>\n    matchBiomasses() |> steady() |> matchBiomasses() |> steady()\n\nWarning in setBevertonHolt(params): For the following species `erepro` has been\nincreased to the smallest possible value: erepro[predator_fish] = 3.11e-06\n\n\nConvergence was achieved in 58.5 years.\n\n\nWarning in setBevertonHolt(params): For the following species `erepro` has\nbeen increased to the smallest possible value: erepro[ruffe] = 0.00582;\nerepro[perch] = 0.000903; erepro[pikeperch] = 3.52e-05; erepro[burbot] = 4e-05;\nerepro[predator_fish] = 8.99e-07\n\n\nConvergence was achieved in 30 years.\n\n\nWarning in setBevertonHolt(params): For the following species `erepro` has been\nincreased to the smallest possible value: erepro[ruffe] = 0.00128; erepro[perch]\n= 0.000189; erepro[pikeperch] = 1.09e-05; erepro[burbot] = 1.2e-05;\nerepro[predator_fish] = 4.88e-07\n\n\nConvergence was achieved in 22.5 years.\n\n\nWarning in setBevertonHolt(params): For the following species `erepro` has\nbeen increased to the smallest possible value: erepro[ruffe] = 0.000507;\nerepro[perch] = 9.73e-05; erepro[pikeperch] = 7.46e-06; erepro[burbot] =\n8.38e-06; erepro[predator_fish] = 4.36e-07\n\n\nConvergence was achieved in 16.5 years.\n\n\nWarning in setBevertonHolt(params): For the following species `erepro` has\nbeen increased to the smallest possible value: erepro[ruffe] = 0.000375;\nerepro[perch] = 8.15e-05; erepro[pikeperch] = 7.33e-06; erepro[burbot] =\n8.36e-06; erepro[predator_fish] = 4.86e-07\n\n\nConvergence was achieved in 12 years.\n\n\nWarning in setBevertonHolt(params): For the following species `erepro` has been\nincreased to the smallest possible value: erepro[ruffe] = 0.00036; erepro[perch]\n= 8.18e-05; erepro[pikeperch] = 7.68e-06; erepro[burbot] = 8.8e-06;\nerepro[predator_fish] = 5.28e-07\n\n\nConvergence was achieved in 9 years.\n\n\nConvergence was achieved in 7.5 years.\n\n\nConvergence was achieved in 6 years.\n\n\nConvergence was achieved in 1.5 years.\nConvergence was achieved in 1.5 years.\n\nplotBiomassVsSpecies(cur_model)\n\n\n\n\nAnd here is how the spectra look with the correct observed biomasses:\n\nplotSpectra(cur_model, power = 2)\n\n\n\n\n\n\n\n\n\n\nIf step 5 fails\n\n\n\n\n\ncould diverge\n\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\n\n\nNow use your species parameter data frame that you assembled in the exercise in the previous tutorial. Go through the 5 steps that we went through above to build your own mizer model based on your species parameters.\nUse the worksheet for this tutorial to submit your result."
  },
  {
    "objectID": "build/create-first-model.html#exercise",
    "href": "build/create-first-model.html#exercise",
    "title": "Create your first model",
    "section": "Exercise",
    "text": "Exercise\nNow use your species parameter data frame that you assembled in the exercise in the previous tutorial. Use the worksheet for this tutorial “worksheet-2-create-first-model.Rmd” to go through the 5 steps that we went through above to build your own mizer model based on your species parameters.\nThere are ways how the above method can fail. If that happens, there are various ways to rescue the situation. But rather than discussing such eventualities in the abstract, we will wait to see if you run into concrete difficulties. If you do, please save your code and email gustav.delius@gmail.com. We will then use your example to discuss the solutions."
  },
  {
    "objectID": "build/create-first-model.html#summary",
    "href": "build/create-first-model.html#summary",
    "title": "Create your first model",
    "section": "Summary",
    "text": "Summary\nWe have gone through the 5-step process of building a mizer model from your species parameters and your interaction matrix. The 5 steps were:\n\nCreate a MizerParams object with newMultispeciesParams().\nFind a coexistence steady state with steady().\nSet the scale of the model to agree with the observed total biomass with calibrateBiomass(). This does not spoil the steady state.\nUse matchBiomass() to move the size spectra of the species up or down to match the observed biomasses. This will spoil the steady state.\nIterate steps 2 and 4 as often as you like to get the steady-state biomasses to agree as precisely with your observations as you like."
  },
  {
    "objectID": "troubleshooting.html",
    "href": "troubleshooting.html",
    "title": "Troubleshooting",
    "section": "",
    "text": "If you can’t find your issue resolved on this page, make sure to post a comment.\nYou can help out by editing this page when you come across an issue and its solution. For example if you managed to find the solution yourself, please nevertheless edit this page to add your issue and your solution because it will save others time.\n\nIf your R project is located inside a directory with a very long path name, you might get an error messge because R will not be able to access the path.\nThe error message may look like this: ’Warning in gzfile(file, “wb”): cannot open the compressed file ’C:/….. “\nSolution: make sure you create your R project in a higher directory with a shorter path\nFor some users, Github asks for username and password (or personal access token) every time you want to push your commits to Github. This can happen if your Git version is too old.\nSolution: install the latest version of Git."
  },
  {
    "objectID": "understand/dynamics-of-spectra.html",
    "href": "understand/dynamics-of-spectra.html",
    "title": "Dynamics of size spectra",
    "section": "",
    "text": "In previous tutorials we have concentrated on the steady state of the mizer model, where for each size class and each species, the rate at which individuals grow into the size class balances the rate at which individuals grow out of the size class or die, thus keeping the size spectrum constant. In this tutorial we explore the dynamic that takes place when this balance is changed.\nSize-spectrum dynamics is described by the beautiful partial differential equation\n\n\\frac{\\partial N(w)}{\\partial t} + \\frac{\\partial g(w) N(w)}{\\partial w}\n  = -\\mu(w) N(w)\n\ntogether with the boundary condition\n\nN(w_{min}) = \\frac{R_{dd}}{g(w_{min})},\n\nwhere N(w) is the number density at size w, g(w) is the growth rate and \\mu(w) is the death rate of individuals of size w, w_{min} is the egg size and R_{dd} is the birth rate. Luckily it is easy to describe in words what these equations are saying.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nSize spectrum dynamics is very intuitive: The rate at which the number of individuals in a size class changes is the difference between the rate at which individuals are entering the size class and the rate at which they are leaving the size class. Individuals can enter a size class by growing in or, in the case of the smallest size class, by being born into it. They can leave by growing out or by dying.\n\n\n\nWhat makes these seemingly obvious dynamics interesting is how the growth rate and the death rate are determined in terms of the abundance of prey and predators and the feeding preferences and physiological parameters of the individuals. We have discussed a bit of that in previous tutorials and will discuss it much more in upcoming tutorials. We will discuss the birth rate R_{dd} below in the section on how reproduction is modelled. But first we want to look at the results of simulating the size spectrum dynamics.\nYou will be doing your own work for this tutorial in the accompanying worksheet file “worksheet5-dynamics-of-spectra.Rmd”. You will find this file in the worksheet repository for this week that you already used in previous tutorials.\nAs always, we start by making sure we have the latest version of the mizerExperimental package and load it as well as the tidyverse.\n\nremotes::install_github(\"sizespectrum/mizerExperimental\")\nlibrary(mizerExperimental)\nlibrary(tidyverse)\n\n\nIn the previous tutorial, in the section on trophic cascades, we already simulated the size-spectrum dynamics to find the new steady state. But we only looked at the final outcome once the dynamics had settled down to the new steady state. We reproduce the code here:\n\n# Create trait-based model\nmp <- newTraitParams() |> \n    # run to steady state with constant reproduction rate\n    steady() |>\n    # turn of reproduction and instead keep egg abundance constant\n    setRateFunction(\"RDI\", \"constantEggRDI\") |>\n    setRateFunction(\"RDD\", \"noRDD\")\n\nThe resource carrying capacity has been commented and therefore will not be recalculated from the resource parameters.\n\n\nConvergence was achieved in 6 years.\n\n\nThe resource carrying capacity has been commented and therefore will not be recalculated from the resource parameters.\n\n# We make a copy of the model\nmp_lessRes <- mp\n# and set the resource interaction to 0.8 for species 8 to 11\nspecies_params(mp_lessRes)$interaction_resource[8:11] <- 0.8\n\n# We run the dynamics until we reach steady state\nmp_lessRes_steady <- projectToSteady(mp_lessRes)\n\nConvergence was achieved in 24 years.\n\n# We compare the steady states\nplotSpectra2(mp_lessRes_steady, \"less resource\", mp, \"original\", \n            total = TRUE, power = 2, \n            ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\nBut we can also save and then display the spectra of all the species at intermediate times. This is what the project() function does. It projects the current state forward in time and saves the result of that simulation in a larger object, a MizerSim object, which contains the resulting time series of size spectra. Let’s use it to project forward by 24 years.\n\nsim_lessRes <- project(mp_lessRes, t_max = 24)\n\nWe can now use this MizerSim object in the animateSpectra() function to create an animation showing the change in the size spectra over time.\n\nanimateSpectra(sim_lessRes, total = TRUE, power = 2, \n               ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\n\nGo ahead, press the Play button.\nNote, for some species size spectra at the largest size class drop all the way to very small values (e.g. 10^-7) and for others they stop higher. This is just a discretisation artifact and is not important. Try to ignore it.\nOf course we can also get at the numeric values of the spectra at different times. First of all the function getTimes() gives the times at which simulation results are available in the MizerSim object:\n\ngetTimes(sim_lessRes)\n\n [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n\n\nThe function N() returns a three-dimensional array (time x species x size) with the number density of consumers. To get for example the number density for the 2nd species after 5 years in the 1st size class we do\n\nN(sim_lessRes)[6, 2, 1]\n\n[1] 2.621407\n\n\nIf the function getBiomass() is supplied with a MizerSim object then it returns an array (time x species) containing the biomass in grams at each time step for all species. So for example the biomass in grams of the 2nd species after 5 years is\n\ngetBiomass(sim_lessRes)[6, 2]\n\n[1] 0.003433498\n\n\nThe biomass time series can be plotted with plotBiomass():\n\nplotBiomass(sim_lessRes)\n\n\n\n\nMizer provides many more functions to analyse the results of a simulation, some of which you will learn later in this course."
  },
  {
    "objectID": "understand/dynamics-of-spectra.html#reproduction-dynamics",
    "href": "understand/dynamics-of-spectra.html#reproduction-dynamics",
    "title": "Dynamics of size spectra",
    "section": "Reproduction dynamics",
    "text": "Reproduction dynamics\nThe above simulation was run with constant abundance in the smallest size class for each species. This of course is not realistic. The abundance of the smallest individuals depends on the rate at which mature individuals spawn offspring, and this in turn depends, among other things, on the abundance of mature individuals. So if the abundance of mature individuals goes down drastically, as it did for species 8 to 11 above, then the abundance of offsprings for those species will go down as well.\nTo see the effect we run the same code as above after deleting the two lines that turned off the reproduction dynamics. We also specify with t_save = 2 that we want to save the spectrum only every second year, which speeds up the display of the animation.\n\n# Create trait-based model\nmp <- newTraitParams() |> \n    # run to steady state with constant reproduction rate\n    steady()\n\nThe resource carrying capacity has been commented and therefore will not be recalculated from the resource parameters.\n\n\nConvergence was achieved in 6 years.\n\n\nThe resource carrying capacity has been commented and therefore will not be recalculated from the resource parameters.\n\n# We make a copy of the model\nmp_lessRes <- mp\n# and set the resource interaction to 0.8 for species 8 to 11\nspecies_params(mp_lessRes)$interaction_resource[8:11] <- 0.8\n\n# We simulate the dynamics for 30 years, saving only every 2nd year\nsim_lessRes <- project(mp_lessRes, t_max = 30, t_save = 2)\n\n# We animate the result\nanimateSpectra(sim_lessRes, total = TRUE, power = 2, \n               ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\n\nI think you might be surprised at the result when you press the Play button now.\nWhat is going on with species 1?"
  },
  {
    "objectID": "understand/dynamics-of-spectra.html#how-reproduction-is-modelled",
    "href": "understand/dynamics-of-spectra.html#how-reproduction-is-modelled",
    "title": "Dynamics of size spectra",
    "section": "How reproduction is modelled",
    "text": "How reproduction is modelled\nEnergy invested into reproduction\nWe already discussed the investment into reproduction in an earlier tutorial. As mature individuals grow they invest an increasing proportion of their income into reproduction and at their asymptotic size they would be investing all income into reproduction. Summing up all these investments from mature individuals of a particular species gives the total rate E_R at which that species invests energy into reproduction. This total rate of investment is multiplied by a reproduction efficiency factor erepro, divided by a factor of 2 to take into account that only females reproduce, and then divided by the egg weight w_min to convert it into the rate at which eggs are produced. The equation is:\n\nR_{di} = \\frac{\\rm{erepro}}{2 w_{min}} E_R.\n\nThis is calculated in mizer with getRDI():\n\ngetRDI(mp)\n\n          1           2           3           4           5           6 \n0.344090412 0.211705188 0.130253809 0.080140004 0.049306967 0.030336622 \n          7           8           9          10          11 \n0.018664921 0.011483786 0.007065518 0.004347133 0.002674619 \n\n\nThe erepro parameter or reproduction efficiency can vary between 0 and 1 (although 0 would be bad) and reflects the fact that only a fraction of energy invested into reproduction can make into viable eggs or larvae.\nDensity-dependence in reproduction\nNote that what mizer models is not the rate of recruitment but the rate of egg production. The size spectrum dynamics then determine how many of those larvae grow up and survive to be recruited to the fishery.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nThe stock-recruitment relationship is an emergent phenomenon in mizer, with several sources of density dependence. Firstly, the amount of energy invested into reproduction depends on the energy income of the spawners, which is density-dependent due to competition for prey. Secondly, the proportion of larvae that grow up to recruitment size depends on the larval mortality, which depends on the density of predators, and on larval growth rate, which depends on density of prey.\n\n\n\nHowever there are other sources of density dependence that are not explicitly modelled mechanistically in mizer. An example would be a limited carrying capacity of suitable spawning grounds and other spatial effects. So mizer has another species parameter R_{max} that gives the maximum possible rate of recruitment. Imposing a finite maximum reproduction rate leads to a non-linear relationship between energy invested and eggs hatched. This density-dependent reproduction rate is given by a Beverton-Holt type function:\n R_{dd} = R_{di} \\frac{R_{max}}{R_{di} + R_{max}}\nRather than looking at the formula, let’s look at a figure:\n\n\n\n\n\nThis figure shows two graphs of R_{dd} (solid lines), one for higher R_{max} (black) and one for lower R_{max} (blue). The values of R_{max} are indicated by the dotted lines. The dashed lines show the density-independent rate R_{di}.\nThe important fact to observe is that the solid curves becomes more shallow as R_{max} gets closer to the actual reproduction rate R_{dd}. This slope determines how big the effect of a change in investment into reproduction (for example due to a change in spawning stock biomass) is on the reproduction rate. As the energy invested in reproduction changes away from the steady state value E_R on the x-axis, the the solid curves shows how much the reproduction rate changes on the y-axis. The change is smaller along the shallower blue line, the one that corresponds to the R_{max} value that is closer to R_{dd}. The result is that a species with a low ration between R_max and R_{dd} will be less impacted by depletion of its spawning stock by fishing, for example. This ratio we will refer to as the reproduction level and we will discuss it in the next section.\nThis density-dependent rate of reproduction is calculated in mizer with getRDD():\n\ngetRDD(mp)\n\n          1           2           3           4           5           6 \n0.258067809 0.158778891 0.097690357 0.060105003 0.036980226 0.022752467 \n          7           8           9          10          11 \n0.013998691 0.008612839 0.005299139 0.003260350 0.002005964 \n\n\nThis is the rate at which new individuals are entering the smallest size class. The actual number density in the smallest size class is then determined by the usual size-spectrum dynamics."
  },
  {
    "objectID": "understand/dynamics-of-spectra.html#reproduction-level",
    "href": "understand/dynamics-of-spectra.html#reproduction-level",
    "title": "Dynamics of size spectra",
    "section": "Reproduction level",
    "text": "Reproduction level\nWe have seen the two species parameters that determine how the energy invested into reproduction is converted to the number of eggs produced: erepro and R_max. For neither of these is it obvious what value they should have. The choice of values influences two important properties of a model: the steady state abundances of the species and the density-dependence in reproduction. It is therefore useful to change to a new set of two parameters that reflect these two properties better. These are:\n\nThe birth rate R_{dd} at steady state. This determines the abundance of a species.\nThe ratio between R_{dd} and R_{max} at steady state. This determines the degree of density dependence.\n\nThe ratio R_{dd} / R_{max} we denote as the reproduction level. This name may remind you of the feeding level, which was the ratio betweenthe actual feeding rate and the the maximum feeding rate and described the level of density dependence coming from satiation. It takes a value between 0 and 1. It follows from our discussion in the previous section that a species with a high reproduction level is more resilient to changes.\nWe can get the reproduction levels of the different species with getReproductionLevel():\n\ngetReproductionLevel(mp)\n\n   1    2    3    4    5    6    7    8    9   10   11 \n0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 \n\n\nWe see that by default newTraitParams() had given all species the same reproduction level. We can change the reproduction level with the setBevertonHolt() function. We can set different reproduction levels for each species, but here we will simply set it to 0.9 for all species:\n\nmp9 <- setBevertonHolt(mp, reproduction_level = 0.9)\n\nChanging the reproduction level has no effect on the steady state, because that only depends on the rate of egg production R_dd and that is kept fixed when changing the reproduction level. We can check that by running our new model to steady state and plotting that steady state together with the original steady state. They overlap perfectly.\n\nmp9 <- projectToSteady(mp9)\n\nConvergence was achieved in 4.5 years.\n\nplotSpectra2(mp, \"reproduction_level = 0.25\", mp9, \"reproduction_level = 0.9\", \n            total = TRUE, power = 2, ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\nHowever the reproduction level has an effect on how sensitive the system is to changes. As an example, let us look at the dynamics that is triggered by the reduction in interaction with the resource by species 8 through 11.\n\n# We make a copy of the model\nmp_lessRes9 <- mp9\n# and set the resource interaction to 0.8 for species 8 to 11\nspecies_params(mp_lessRes9)$interaction_resource[8:11] <- 0.8\n\nsim_lessRes9 <- project(mp_lessRes9, t_max = 30, t_save = 2)\n\nanimateSpectra(sim_lessRes9, total = TRUE, power = 2, \n               ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\n\nNotice how the species have settled down to a new steady state after 30 years without any extinctions and the impact on species 1 is almost negligible. As expected, the higher reproduction level has made the species much more resilient to perturbations.\nThe problem of course is that in practice the reproduction level is hardly ever known. Instead one will need to use any information one has about the sensitivity of the system from observed past perturbations to calibrate the reproduction levels. We’ll discuss this again in week 3.\n\n\n\n\n\n\nExercise 1\n\n\n\n\n\nGo back to the example with fishing on individuals above 1kg from the section on fishing-induced cascades. Impose the same fishing, but now on the trait-based model with reproduction dynamics left turned on and with a reproduction level of 0.5 for all species. Project the model for 20 years. How many species have a reduced total biomass after 20 years? What is the total biomass of species 1 after 20 years?"
  },
  {
    "objectID": "understand/dynamics-of-spectra.html#resource-dynamics",
    "href": "understand/dynamics-of-spectra.html#resource-dynamics",
    "title": "Dynamics of size spectra",
    "section": "Resource dynamics",
    "text": "Resource dynamics\nThe resource spectrum is not described by size spectrum dynamics, because in reality it is typically not made up of individuals that grow over a large size range during their life time. In mizer, the resource number density in each size class is describe by semichemostat dynamics: the resource number density in each size class increases recovers after depletion, and this biomass growth or recovery rate will decrease as the number density gets close to a carrying capacity. If you want the mathematical details, you can find them in the mizer model description in the section on resource density.\nThe effect of these dynamics is that if the number of fish consuming the resource in a certain size range increases, the resource abundance in that size range will decrease, if it cannot recover quickly enough (regeneration rate of the resource is set by the user). So there is competition for the resource, which provides a stabilising influence on the fish abundances. We will be discussing this more in week 3."
  },
  {
    "objectID": "understand/dynamics-of-spectra.html#summary-and-recap",
    "href": "understand/dynamics-of-spectra.html#summary-and-recap",
    "title": "Dynamics of size spectra",
    "section": "Summary and recap",
    "text": "Summary and recap\n1) Size spectrum dynamics is very intuitive: the rate at which the number of individuals in a size class changes is the difference between the rate at which individuals grow into (or are born into) the size class and the rate at which individuals grow out of or the size class or die in the size class.\n2) The project() function simulates the dynamics and creates a MizerSim object that contains the resulting time series of size spectra.\n3) Mizer provides many functions for extracting, analysing and plotting the results of a simulation, some of which we will be using in week 3.\n4) Instead of a stock-recruitment relationship as used in other fisheries models, a mizer model relates the energy invested into reproduction to the number of eggs produced. The growth and mortality that the larvae experience until they are recruited to the fishery lead to density-dependence in the recruitment. Additional density dependence is applied to the egg production.\n5) The relation between energy invested in reproduction and the actual birth rate is described by two parameters: the density independent reproduction efficiency erepro and the maximum birth rate R_max.\n6) In practice a more useful way to parametrise the reproduction is by two other parameters: the birth rate R_{dd} at steady state (which determines the total abundance of a species) and the reproduction level (which determines the amount the amount of density dependence that applies to egg production).\n7) A change in the reproduction level does not change the steady state but it changes the sensitivity of a species and the system to changes."
  },
  {
    "objectID": "understand/index.html",
    "href": "understand/index.html",
    "title": "Week 1: Understand size-spectrum modelling",
    "section": "",
    "text": "Your goal in this first week of the course is to gain a thorough understanding of size spectra and their dynamics. This means that at the end of the week you will understand the parameters that shape the size spectra and how size spectra respond to changes. You will have a feel for how size-spectrum dynamics is different from usual single-species age-based dynamics.\nIt is worth spending an entire week on building this understanding, because it will enable you to build more reliable models in the second week and to appropriately explore the model predictions in the third week."
  },
  {
    "objectID": "understand/index.html#guest-lecture-by-ken-andersen",
    "href": "understand/index.html#guest-lecture-by-ken-andersen",
    "title": "Week 1: Understand size-spectrum modelling",
    "section": "Guest lecture by Ken Andersen",
    "text": "Guest lecture by Ken Andersen\nIn the following video Ken Andersen introduces many of the concepts that we will be discussing in this course. However don’t feel that you have to take it all in at once. We will come back to these topics during the course where we hope to make them concrete by working hands-on with mizer."
  },
  {
    "objectID": "understand/index.html#tutorials",
    "href": "understand/index.html#tutorials",
    "title": "Week 1: Understand size-spectrum modelling",
    "section": "Tutorials",
    "text": "Tutorials\nThe material is split into 5 tutorials:\n\nObserved size spectra\nBecause many of the physiological rates in fish (like growth, mortality, metabolism, reproduction) depend on the size of the individuals, a mizer model needs to keep track of the size distribution of the populations, the so-called size spectra. To get a feel for size spectra, in this first tutorial you will take observational data and make plots of size spectra. There is confusion in the size spectrum literature because there are different ways to represent the size spectra and this tutorial will introduce these, so that you can cut through the confusion.\nSingle-species spectra\nAt the community level, size spectra tend to look like power laws. But the size spectrum of each individual species making up the community will look different. In this tutorial we will investigate how the shape of the single species spectrum is determined by an interplay of growth and mortality.\nPredation, growth and mortality\nA particular strength of a mizer model is that growth curves and mortality rates are not fixed externally but are emergent and dependent on the availability of prey and the presence of predators. In this tutorial we explore how predation is modelled in mizer and how it effects growth and mortality.\nSpecies interactions\nIn a mizer model all the species in the community interact with each other through size-based predation. So any changes in one species’ size spectrum affects the size spectra of the other species, which in turn affects that first species. In this tutorial we start investigating some of the effects this has.\nDynamics of spectra\nIn previous tutorials we have concentrated on the steady state of the mizer model, where for each size class and each species, the rate at which individuals grow into the size class balances the rate at which individuals grow out of the size class or die, thus keeping the size spectrum constant. In this tutorial we explore the dynamic that takes place when this balance is changed."
  },
  {
    "objectID": "understand/index.html#worksheets",
    "href": "understand/index.html#worksheets",
    "title": "Week 1: Understand size-spectrum modelling",
    "section": "Worksheets",
    "text": "Worksheets\nEach tutorial comes with exercises and a worksheet in which to complete the exercises. These worksheets are contained in a dedicated repository on GitHub to which you will push your work to get feedback. This will work the same way as we discussed in the tutorial Use Git and GitHub. If you did not yet get a chance to work through that tutorial, please do so now before continuing with this week’s tutorials.\n\n\n\n\n\n\n\n\n\nTo get your worksheet repository for this week, follow this link:\nhttps://classroom.github.com/a/5cnr1H7R\nWhile reading through a tutorials in your web browser, you may want to have the accompanying worksheet open in RStudio and occasionally copy and paste code from the tutorial there and possibly modify it to see for yourself what happens. Copying code from the tutorial is made easy because when you hover over a chunk of R code in the tutorial you will see a copy icon appearing that you can click to copy the entire content of that R chunk to your clipboard. You can then create a new R chunk in your worksheet and paste the code into it.\nDo save the worksheet frequently and commit all those experiments of yours to your repository. You never know whether you may not want to revisit some of them later."
  },
  {
    "objectID": "understand/species-interactions.html",
    "href": "understand/species-interactions.html",
    "title": "Species interactions",
    "section": "",
    "text": "In the previous tutorials we studied a single species interacting with a fixed background community. In this tutorial we want to acknowledge that there is no such thing as a fixed background community. Instead, all species form part of a dynamical ecosystem in which changes to any species has knock-on effects on other species. Furthermore, the resulting changes in the other species will react back on the first species, which now finds its prey community and its predator community changed. This is where we realise that we need multi-species models, because without a model we cannot calculate or easily predict how all these changes will affect each other.\nYou will be doing your own work for this tutorial in the accompanying worksheet file “worksheet4-species-interactions.Rmd”. You will find this file in the worksheet repository for this week that you already used in previous tutorials.\nAs always, we start by making sure we have the latest version of the mizerExperimental package and load it, as well as the tidyverse."
  },
  {
    "objectID": "understand/species-interactions.html#trait-based-model",
    "href": "understand/species-interactions.html#trait-based-model",
    "title": "Species interactions",
    "section": "Trait-based model",
    "text": "Trait-based model\nIn this first week we aim for understanding, not realism. So in this tutorial we investigate the tangled web of interactions in an idealised multi-species system. We choose a trait-based model in which the species making up the community differ from each other only in a single trait: their asymptotic body size (sometimes it is also called maximum body size, although it is not exactly the same).\nWe use the newTraitParams() function to create our idealised trait-based multi-species model. The function has many parameters, but we will just keep the defaults. Unlike the newSingleSpeciesParams() function, the newTraitParams() function does not set the initial spectra to their steady state values. We thus need to run the result through the steady() function (we’ll discuss that function more next week). We assign the resulting MizerParams object to the variable mp.\n\nmp <- newTraitParams() |> steady()\n\nThe resource carrying capacity has been commented and therefore will not be recalculated from the resource parameters.\n\n\nConvergence was achieved in 6 years.\n\n\nThe resource carrying capacity has been commented and therefore will not be recalculated from the resource parameters.\n\n\nLet us look at the biomass density in log weight.\n\nplotSpectra(mp, power = 2, total = TRUE)\n\n\n\n\nWe see 11 species spectra and a resource spectrum. The resource spectrum starts at a smaller size than the fish spectra, in order to provide food also for the smallest individuals (larvae) of the fish spectra. Each species spectrum has a shape of the type we expect, given what we have seen in the tutorial on single species spectra. The spectra of the different species all look essentially the same, except for being shifted along the size axis. This is because in this trait-based model the species differ only through their asymptotic size. This regularity will of course not be present in a real-world ecosystem, but it makes it easier for us to build an intuition about the effects of species interactions.\nNote how the community size spectrum, plotted in black, that is obtained by summing together all the individual species and resource spectra, approximately follows a power law (i.e., approximately follows a straight line in the log-log plot).\nTurn off reproduction dynamics\nAs in previous tutorials, we want to concentrate on the shapes of the size spectra and we do not yet want to look at what determines the overall abundance of each species. Therefore we modify the model so that it keeps the abundances at egg size fixed (i.e. numbers in the first size bin). You do not need to look in detail at the following code, except to note that a mizer model is very customisable in the sense that an advanced user can overwrite almost any behaviour with custom behaviour.\n\nmp <- mp |>\n    setRateFunction(\"RDI\", \"constantEggRDI\") |>\n    setRateFunction(\"RDD\", \"noRDD\")\n\nThe functionality for customising and extending mizer could be the subject of an entire extra week, and we will not have time for it. But during the course you can certainly let us know what kinds of customisation you would like to make and we can give pointers. You can also look at a recent blog post where Phoebe Woodworth-Jefcoats shows how to use custom rate functions to implement temperature-dependent rates in mizer."
  },
  {
    "objectID": "understand/species-interactions.html#mortality-from-other-species",
    "href": "understand/species-interactions.html#mortality-from-other-species",
    "title": "Species interactions",
    "section": "Mortality from other species",
    "text": "Mortality from other species\nThe species interact with each other via predator-prey interactions. These interactions shape both mortality and energy income. In this section we look at mortality imposed on a particular species by its predators. We choose to look at species 8. The following graph shows the relative contributions to the mortality rate for species 8 from all the other species:\n\nplotlyDeath(mp, species = \"8\")\n\n\n\n\n\nThe horizontal axis shows the size of the individual whose mortality we are looking at. Towards the left we see the mortality of the small larvae, as we move towards the right we move to larger individuals. So the main important message from this graph is that as an individual grows up, their main predators change.\nYou might have expected that species 8 would be predated upon by the larger species 9, 10 and 11. And for large individuals of species 8, these three species do indeed form the dominant source of predation mortality, but we see also that smaller individuals of species 8 are predominantly predated upon by predators from smaller species. This arises because each predator prefers to feed at a certain fraction of its own size (which is set to 1/100th in this model), so the larger predators loose interest in the larvae and concentrate on the larger prey.\nThis ontogenetic diet shift as an individual grows up is the main reason why standard food-web models, where interaction between predator and prey is entirely determined by their species, are inappropriate for modelling fish communities.\nIn the above graph you also see that the smallest individuals and the largest individuals get the majority of their mortality from “external” sources, by which we designate all the mortality that is not from predation by the modelled species. So it is “external” in the sense that its sources are not represented inside the model. For large individuals this external mortality would include predation from mammals and senescence mortality. For small individuals this external mortality comes from predation by small, possibly planktonic, organisms that are not explicitly modelled.\nIn the absence of other information, our simple trait-based model just assumes that this external mortality is such that the total mortality scales allometrically with an individual’s size to the power of -1/4. This is why larval mortality is actually quite high. We can see this in the following plot which instead of proportions shows the actual mortality rates:\n\nplotDeath(mp, species = \"8\", proportion = FALSE)\n\n\n\n\nThe plotDeath() function is extremely useful when building your own model, both as a proportion of mortality and as an absolute rate. It is important to know where the majority of mortality on your species and its various sizes come from. So make sure you remember it and use it a lot."
  },
  {
    "objectID": "understand/species-interactions.html#income-from-other-species",
    "href": "understand/species-interactions.html#income-from-other-species",
    "title": "Species interactions",
    "section": "Income from other species",
    "text": "Income from other species\nNow that we have investigated who eats species 8, we also want to know who is eaten by species 8. We can check that by plotting the diet of this species:\n\nplotDiet(mp, species = \"8\")\n\n\n\n\nThe diet looks quite reasonable. Small individuals of species 8 initially feed entirely on the resource (plankton and other small things). From about the size of 1g (which is roughly 4-5 cm) they start eating larvae of other fish.\nThe diet composition we see in the plot is shaped by two things: the predation kernel (the size preference in the feeding of the predator) and the relative abundances of prey at different sizes. First, a predator will only eat food that is within the predation kernel size range. But once in this size range the relative proportion of different species or resource consumed will simply depend on their relative biomass. So if, for example, 80% of biomass in a specific prey size class consists of resource, 15% of species 1 and 5% of species 2, then the diet of the predator feeding in that size class will consist of 80% resource, 15% of species 1 and 5% of species 2.\nIn our example model, resource abundance at small size classes is very high compared to abundance of fish. So when a predator feeds in those size classes, naturally most of the diet will consist of resource. This is what we see in the diet plot.\nOf course, when we build a model for a real-world ecosystem we will have some knowledge about the biology of the species and their food preferences. Perhaps one species is actively selecting fish out of the resource, or predating on specific species only? This is where the interaction matrix comes in that we will discuss in the next section.\nNote, that it is very important to explore diets of species in your model, so, like the plotDeath() function, the plotDiet() function is very useful.\n\n\n\n\n\n\nExercise 1\n\n\n\n\n\nNow, check how the diets of other species look like. Start from species 1 (smallest one) and all the way to species 11.\nWhich of the following statements is true?\n\nAll species eat all other species.\nThe reason that the x-axis covers a larger range of sizes in the diet plots for higher species is because higher species have a larger asymptotic size.\nThe proportion of different species in the diets of higher species increases and then decreases. This is because as predators grow larger they prefer to eat larger prey.\nThe proportion of different species in the diets of higher species increases and then decreases. This is because as predators grow larger they start eating species that are the most abundant.\nThroughout its lifetime even the higher species (species 8-10) feed almost entirely on the resource.\nAll species are cannibalistic.\nLower species can eat higher species.\n\nYou will be prompted for your answer in the worksheet for this tutorial."
  },
  {
    "objectID": "understand/species-interactions.html#interaction-matrix",
    "href": "understand/species-interactions.html#interaction-matrix",
    "title": "Species interactions",
    "section": "Interaction matrix",
    "text": "Interaction matrix\nNow we arrive to an interesting and challenging aspects of multi-species modelling - setting up parameters for species and resource interactions. By default, mizer assumes that all species in the model can access all other species and resource equally and the amount of different prey consumed just depends on their relative abundance in the predator’s feeding size range. So the default interaction matrix of the species in our model looks very simple\n\ngetInteraction(mp)\n\n        prey\npredator 1 2 3 4 5 6 7 8 9 10 11\n      1  1 1 1 1 1 1 1 1 1  1  1\n      2  1 1 1 1 1 1 1 1 1  1  1\n      3  1 1 1 1 1 1 1 1 1  1  1\n      4  1 1 1 1 1 1 1 1 1  1  1\n      5  1 1 1 1 1 1 1 1 1  1  1\n      6  1 1 1 1 1 1 1 1 1  1  1\n      7  1 1 1 1 1 1 1 1 1  1  1\n      8  1 1 1 1 1 1 1 1 1  1  1\n      9  1 1 1 1 1 1 1 1 1  1  1\n      10 1 1 1 1 1 1 1 1 1  1  1\n      11 1 1 1 1 1 1 1 1 1  1  1\n\n\nThe matrix has all values set at 1 and shows that all predators can access all prey species with the same probability.\nIn reality we might have some knowledge about predators’ diet preferences, or about prey vulnerability to predation. This knowledge should be incorporated in the interaction matrix. Perhaps we know that some predators cannot or do not eat certain prey. For example some species in our system might only feed on resource and never ever eat any fish. In this case we will set all values in the row for that predator equal to 0. Alternatively, we might know that some prey is less available to predation due to some anti-predation behaviour or defence mechanisms. In this case we would decrease all values in the prey column to something < 1.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nIt is important to note that you should not set an entry in the interaction matrix to 0 just because a particular prey is never recorded in the stomach of a predator. It may well be that the predator species consumes the larvae of the prey species at some stage of their life and these larvae are simply not recorded in the stomach content.\n\n\n\nSometimes the interaction matrix is used to encode spatial overlap of species in a large ecosystem, as in this application of mizer to the North Sea. In this case the interaction matrix might be estimated from spatial surveys assessing species spatial overlap. The interaction matrix can encode lots of effects and it will have a large impact on the model behaviour.\nSo let’s go ahead and change one value in the interaction matrix.\n\n# We get the interaction matrix and assign it to a variable.\ninteraction_modified <- getInteraction(mp)\n# We change row 11 (predator species 11) and column 2 (prey species 2) to a smaller value\ninteraction_modified[11, 2] <- 0.2\n# and save the MizerParams object with the new interaction matrix in a new variable\nmp_modified <- setInteraction(mp, interaction_modified)\n#check that it looks correct\ngetInteraction(mp_modified)\n\n        prey\npredator 1   2 3 4 5 6 7 8 9 10 11\n      1  1 1.0 1 1 1 1 1 1 1  1  1\n      2  1 1.0 1 1 1 1 1 1 1  1  1\n      3  1 1.0 1 1 1 1 1 1 1  1  1\n      4  1 1.0 1 1 1 1 1 1 1  1  1\n      5  1 1.0 1 1 1 1 1 1 1  1  1\n      6  1 1.0 1 1 1 1 1 1 1  1  1\n      7  1 1.0 1 1 1 1 1 1 1  1  1\n      8  1 1.0 1 1 1 1 1 1 1  1  1\n      9  1 1.0 1 1 1 1 1 1 1  1  1\n      10 1 1.0 1 1 1 1 1 1 1  1  1\n      11 1 0.2 1 1 1 1 1 1 1  1  1\n\n\nNow let’s compare the source of mortality for species 2 in the two models.\n\nplotDeath(mp, species = 2)\nplotDeath(mp_modified, species = 2)\n\n\n\n\n\nOriginal\n\n\n\n\n\n\nModified\n\n\n\n\n\n\nYou will see a reduction of the contribution of species 11 to the mortality of species 2.\nNext let us compare diets of species 11 in the two models.\n\nplotDiet(mp, species = 11)\nplotDiet(mp_modified, species = 11)\n\n\n\n\n\nOriginal\n\n\n\n\n\n\nModified\n\n\n\n\n\n\nYou will see a reduction in the contribution of species 2 to the diet of species 11. By setting the entry in row 11 and column 2 of the interaction matrix to 0.2 we simply reduced the availability of prey species 2 for predator species 11 by a factor of 5. The entries in the interaction matrix simply serve as multipliers on the available prey biomass.\nResource interactions\nThe interaction coefficients between the fish species as consumers and the resource as food, which one could have expected to find in an additional column in the interaction matrix, is instead saved as a species parameter.\n\nspecies_params(mp)$interaction_resource\n\n [1] 1 1 1 1 1 1 1 1 1 1 1\n\n\nWe see that the default value for all these interaction coefficients is also 1.\nNow we might want to reduce the availability of resource to some predators. Perhaps we know that certain species much prefer to feed on other fish rather than on similar sized plankton. Let us look at an example where species 8 through 11 have a 20% reduction in their interaction with resource.\n\n# We make a copy of the model\nmp_lessRes <- mp\n# and set the resource interaction to 0.8 for species 8 to 11\nspecies_params(mp_lessRes)$interaction_resource[8:11] <- 0.8\n# We print out the result to check\nspecies_params(mp_lessRes)$interaction_resource\n\n [1] 1.0 1.0 1.0 1.0 1.0 1.0 1.0 0.8 0.8 0.8 0.8\n\n\nNow we can look at the diet of for example species 9 and compare it with the previous model\n\nplotDiet(mp, species = 9)\nplotDiet(mp_lessRes, species = 9)\n\n\n\n\n\nOriginal\n\n\n\n\n\n\nModified\n\n\n\n\n\n\nThe change seems small enough. However, now that we changed the availability of resources, which is so important for larval stages, these four species will experience a much reduced growth rate during their juvenile stage. We can see that effect by recalculating the single-species spectra with\n\nmp_lessRes_sss <- singleSpeciesSteady(mp_lessRes)\n\nand then ploting the spectra\n\nplotSpectra(mp_lessRes_sss, power = 2)\n\n\n\n\nWe can see the drastic reduction in the abundances of species 8 to 11.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nIt is very important to understand that the above picture does not represent what will actually happen in the multi-species model. The above picture represents single-species thinking. We changed something for species 8 to 11 and then calculated the effect that change has on those species assuming they stayed in the same environment with the same prey and predator abundances. But of course the rest of the ecosystem will react, as we will now investigate."
  },
  {
    "objectID": "understand/species-interactions.html#trophic-cascades",
    "href": "understand/species-interactions.html#trophic-cascades",
    "title": "Species interactions",
    "section": "Trophic cascades",
    "text": "Trophic cascades\nAs we just discussed, the above picture does does not show a steady state of the ecosystem. Species now find themselves with a different abundance of predators and prey and this will change their mortality and their growth and hence their size spectra.\nThe easiest way to find the new steady state that the ecosystem will settle into is to simulate the full multi-species dynamics forward in time. Mizer refers to this simulation to find the future state of the ecosystem as “projecting”. We can use the function projectToSteady() to project forward in time far enough so the system has settled down again close to the new steady state.\n\nmp_lessRes_steady <- projectToSteady(mp_lessRes)\n\nConvergence was achieved in 24 years.\n\n\n\nplotSpectra2(mp_lessRes_steady, \"less resource\", mp, \"original\", \n            total = TRUE, power = 2, ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\nThere is much to see in this graph. We can see how the reduction in the abundance of large individuals leads to undulations in fish and resource size spectra, compared to the original model.\nPerhaps you would prefer to plot the above graph with power = 1, which will show the biomass density in weight instead of the Sheldon spectrum. Different people find different options more intuitive.\n\nplotSpectra2(mp_lessRes_steady, \"less resource\", mp, \"original\", \n            total = TRUE, power = 1, ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\nFishing-induced cascades\nLet’s investigates these trophic cascades a bit more. This time we can look at how fishing large fish will affect the ecosystem.\nThe model has been set up with a knife-edge fishing gear that selects all individuals above 1kg, irrespective of species. To use that gear we just have to set a non-zero fishing effort. We create a new model mp_fishing with a very high fishing effort of 2 (note that in fishing mortality values in mizer are not the same as fishing mortality values in age-based or similar stock assessment models, but this is a separate topic).\n\nmp_fishing <- mp\ninitial_effort(mp_fishing) <- 2\n\nWe can plot the resulting fishing mortality:\n\nplotFMort(mp_fishing)\n\n\n\n\nThis is not a realistic gear and mizer can do much better, as we will see in week 3. But it serves our current purpose, because it will impose a fishing mortality that only impacts the larger species that actually grow to sizes above 1kg. As we did in the section on fishing mortality in the previous tutorial, we can visualise the direct effect that this fishing mortality has on individual species:\n\nmp_fishing_sss <- singleSpeciesSteady(mp_fishing)\nplotSpectra(mp_fishing_sss, power = 2)\n\n\n\n\nAs expected, the largest species have their abundances reduced above 1kg if they are fished, and if they continue to encounter the same amount of prey and are exposed to the same amount of predation mortality.\nAgain the important point is that the above picture does does not show a steady state of the ecosystem.\n\n\n\n\n\n\nExercise 2\n\n\n\n\n\nProject the mp_fishing model to its steady state and then make a plot comparing it to the steady state of the un-fished system. By looking at the resulting graph, determine which of the following statements is true. In the statements we refer to the species as “lower” or “higher” based on their number, i.e., species “3” we say is lower than species “4”.\n\nFishing strongly reduces abundances of fish above 1 kg of weight.\nAdult (after maturation size) abundance of intermediate fish (species 5-8) increases due to fishing.\nIn fact, adult abundances of all fish lower than 9 increases due to fishing.\nEntire community size spectrum is severely truncated above 1kg fish size - all due to fishing.\nIf adult biomasses for some species increase due to fishing, then for the same species larval biomasses (below the size of 1 g) will decrease.\nFishing does not only create undulations and trophic cascades in the individual fish spectra, but also in the total community spectrum.\n\nYou will be prompted for your answer in the worksheet for this tutorial."
  },
  {
    "objectID": "understand/species-interactions.html#summary-and-recap",
    "href": "understand/species-interactions.html#summary-and-recap",
    "title": "Species interactions",
    "section": "Summary and recap",
    "text": "Summary and recap\n1) When using mizer models it is very important to investigate who eats whom and where mortality comes from. So we need to use functions plotDeath() and plotsDiet() often.\n2) It is important to remember that the amount of different species consumed will depend on the biomasses of these species in the suitable size range. If all values of the species interaction matrix are set to 1 then consumption will simply be proportional to the relative abundance of the prey species.\n3) The species interaction matrix is important as it defines availability of each species to predation by other species. By changing the interaction matrix we can make our models more realistic and more complex. But with so many parameters in the matrix we need to have a clear set of rules on how these values should be set.\n4) Many implementations of mizer models assume that resource availability to all species is always 1. Modelers might want to reduce this availability to a smaller value, but it will have a large impact on the model dynamics.\n5) Trophic cascades are one of the coolest things in multi-species models and the reason we build these models. We want to understand how changes in one species and its sizes will affect the ecosystem and, in turn, the same species. Mizer has many ways how we can explore such trophic cascades."
  },
  {
    "objectID": "understand/single-species-spectra.html",
    "href": "understand/single-species-spectra.html",
    "title": "Single species spectra",
    "section": "",
    "text": "At the end of the previous tutorial we plotted single-species size spectra from our dataset and observed that they were a bit of a mess. In this tutorial we will use the mizer model to gain an understanding of what determines the shape of a species size spectrum.\nIn this tutorial you are also going to start using mizer functions. When you want to learn more about any of the functions that we use in the examples, simply click on the function name. This will open the function’s help page in a new browser window.\nFirst, load some required packages with the following commands:\n\nremotes::install_github(\"sizespectrum/mizerExperimental\")\nlibrary(mizerExperimental)\nlibrary(tidyverse)\n\nNote how for the mizerExperimental package we also call remotes::install_github(). This will reinstall the package only if it has changed on GitHub since you last installed it. If nothing has changed, the command will just issue a message to reassure you of that fact. So for packages that improve as frequently as mizerExperimental, it is always a good idea to call remotes::install_github() frequently.\nYou will be doing your own work for this tutorial in the accompanying worksheet file “worksheet2-single-species-spectra.Rmd”. You will find this file in the worksheet repository for this week that you already used during the previous tutorial."
  },
  {
    "objectID": "understand/single-species-spectra.html#single-species-model",
    "href": "understand/single-species-spectra.html#single-species-model",
    "title": "Single species spectra",
    "section": "Single-species model",
    "text": "Single-species model\nIn this and the next tutorial we want to keep the size-spectrum aspects of the mizer model separate from the multi-species aspects, in order to not have to think about too many things at once. So we will explore a model where a single species lives in a non-dynamical background community that we will set to a Sheldon power-law abundance. Only in the fourth tutorial of this week exploring species interactions will we start to consider the interesting multi-species phenomena that arise in mizer models.\nIn this tutorial we will only be interested in the shape of the size spectrum, i.e., in how the total number of individuals is distributed over the different sizes. We are not yet interested in the overall abundance of the species. The overall abundance would be influenced by the total rate of reproduction and recruitment for the species. This in turn would be influenced by the size spectrum, because that determines how many of the individuals are mature. This dynamic feedback will of course become important when we build real-world models in week 2 and use them in week 3. But for now we have enough on our plate without thinking also about this.\nMizer collects all the parameters describing a size-spectrum model into one object of class MizerParams. You do not need to set up this object by hand but instead there are several wrapper functions in mizer that create the object for you for various types of models, and also many functions for changing specific parameters in a model. We will use the newSingleSpeciesParams() function to set up a model describing a single fish species living in an ecosystem whose community size spectrum is given by a power-law.\nThe newSingleSpeciesParams() function has many arguments that allow you to specify parameters for the fish species as well as for the community, but all these arguments have default values, so we can simply call the function without specifying those arguments. We will only specify the power-law exponent lambda of the background community. Note that in mizer the size spectrum exponent refers to the number density on a linear weight axis x and is therefore expected to be around 2.\n\nparams <- newSingleSpeciesParams(lambda = 2.05)\n\nThe function returns a MizerParams object and we have assigned that to the variable params. We will be explaining more about this model as we go along."
  },
  {
    "objectID": "understand/single-species-spectra.html#steady-state-spectrum",
    "href": "understand/single-species-spectra.html#steady-state-spectrum",
    "title": "Single species spectra",
    "section": "Steady state spectrum",
    "text": "Steady state spectrum\nAs a final simplification in this and the next two tutorials, we will only consider the steady state size spectra. The steady state is the state where in each size class the inflow of individuals through growth exactly balances the outflow of individuals through growth and death. This means that the size spectrum is in equilibrium. You might have heard that models are often “initialised” from some initial species abundances and then ran to equilibrium until species biomasses and size distributions stop changing. However, we can calculate what sort of initial abundance we need to ensure that a species is in an equilibrium and this is what mizer does. The initial size spectra in the params object that we created with newSingleSpeciesParams() have already been set to the steady state size spectra.\nWe can plot the size spectrum with the plotSpectra() function.\n\nplotSpectra(params, power = 0)\n\n\n\n\nThe power = 0 argument to the plotSpectra() function specifies that we want to plot the number density, rather than for example the biomass density. We’ll discuss this more below in the section on other representations.\nThe green line represents the number density of the background community, labelled as “Resource” in the plot legend, in which our foreground species finds itself. The green line is a straight line with slope lambda = -2.05. Thus the number density of the background community is proportional to w^{-2.05}. It is important to understand that a power-law curve looks like a straight line when plotted on logarithmic axes and the slope of the line is the exponent in the power law. If this does not sound familiar, please revisit the section in the previous tutorial where we fitted a power-law to the community spectrum.\nThe other line represents the number density of our single species, which by default is just named unimaginatively “Target species”. We see that it is a straight line initially, but then has a bump before declining rapidly at large sizes. We will discuss in a short while what causes that shape.\nRemember what these size spectra plots indicate? They show the number density of individuals as a function of size. The initial slope of the target species’ number density is negative, which vaguely means that there are fewer larger fish than smaller fish. That is of course understandable: lots of fish die while they are growing up, so there tend to be fewer fish in larger size classes.\nIt is now time to do the first exercise of this tutorial. To complete the exercise, go to your copy of this week’s worksheet repository and open the file “worksheet2-single-species-spectra.Rmd” in RStudio. There you will find the following first exercise:\n\n\n\n\n\n\nExercise 1\n\n\n\n\n\nCreate a MizerParams object describing a single species in a power-law background where the Sheldon exponent is 2.1. Then plot the number density as a function of weight."
  },
  {
    "objectID": "understand/single-species-spectra.html#numbers",
    "href": "understand/single-species-spectra.html#numbers",
    "title": "Single species spectra",
    "section": "Numbers",
    "text": "Numbers\nWhile the plotSpectra() function gives us a plot of the number density, it would be nice if we could get at the actual numerical values. We can access them with the initialN() function. Let us assign this to a variable n:\n\nn <- initialN(params)\n\nAs you can see in the “Environment” pane in RStudio, n is a matrix with 1 row and 101 columns. The one row corresponds to the one species. In a multispecies model there would be one row for each species, holding the number density for that species. The 101 columns are for the number densities in each of the 101 size classes. By default mizer uses 100+1 size clases (or size bins), although you can easily change that. In fact, n is a named array, i.e., each row and each column has names. These we can extract with the dimnames() function.\n\ndimnames(n)\n\n$sp\n[1] \"Target species\"\n\n$w\n  [1] \"0.001\"   \"0.00112\" \"0.00126\" \"0.00141\" \"0.00158\" \"0.00178\" \"0.002\"  \n  [8] \"0.00224\" \"0.00251\" \"0.00282\" \"0.00316\" \"0.00355\" \"0.00398\" \"0.00447\"\n [15] \"0.00501\" \"0.00562\" \"0.00631\" \"0.00708\" \"0.00794\" \"0.00891\" \"0.01\"   \n [22] \"0.0112\"  \"0.0126\"  \"0.0141\"  \"0.0158\"  \"0.0178\"  \"0.02\"    \"0.0224\" \n [29] \"0.0251\"  \"0.0282\"  \"0.0316\"  \"0.0355\"  \"0.0398\"  \"0.0447\"  \"0.0501\" \n [36] \"0.0562\"  \"0.0631\"  \"0.0708\"  \"0.0794\"  \"0.0891\"  \"0.1\"     \"0.112\"  \n [43] \"0.126\"   \"0.141\"   \"0.158\"   \"0.178\"   \"0.2\"     \"0.224\"   \"0.251\"  \n [50] \"0.282\"   \"0.316\"   \"0.355\"   \"0.398\"   \"0.447\"   \"0.501\"   \"0.562\"  \n [57] \"0.631\"   \"0.708\"   \"0.794\"   \"0.891\"   \"1\"       \"1.12\"    \"1.26\"   \n [64] \"1.41\"    \"1.58\"    \"1.78\"    \"2\"       \"2.24\"    \"2.51\"    \"2.82\"   \n [71] \"3.16\"    \"3.55\"    \"3.98\"    \"4.47\"    \"5.01\"    \"5.62\"    \"6.31\"   \n [78] \"7.08\"    \"7.94\"    \"8.91\"    \"10\"      \"11.2\"    \"12.6\"    \"14.1\"   \n [85] \"15.8\"    \"17.8\"    \"20\"      \"22.4\"    \"25.1\"    \"28.2\"    \"31.6\"   \n [92] \"35.5\"    \"39.8\"    \"44.7\"    \"50.1\"    \"56.2\"    \"63.1\"    \"70.8\"   \n [99] \"79.4\"    \"89.1\"    \"100\"    \n\n\nThe names of the columns are the weight in grams at the start of each size class. Notice how R displays long vectors by breaking them across many lines and starting each line with a number in brackets. That number is the index of the first value in that row. So for example we see that the 61st size class starts at 1 gram. The number density in the size class between 1 gram and 1.12 grams (the start of the next size class) is\n\nn[1, 61]\n\n[1] 0.0003282314\n\n\nIt is important to realise that this is not the number of fish in the size class, but the average number density in the size class. To get the number of fish we have to multiply the number density by the width of the size class. Those widths can be obtained with the dw() function. So the number of fish in each size class is obtained with\n\nnumbers <- n * dw(params)\n\nThe number of individuals in the size class between 1 gram and 1.12 grams is\n\nnumbers[1, 61]\n\n[1] 4.005029e-05\n\n\nYou may be surprised by the small number if you interpret it as the number of fish between 1 gram and 1.12 gram in the entire ocean. However it looks more reasonable if it is the average number per square meter of sea. For more of a discussion of this issue of working with numbers per area, numbers per volume or numbers for the entire system see https://sizespectrum.org/mizer/reference/setParams.html#units-in-mizer\n\n\n\n\n\n\nExercise 2\n\n\n\n\n\nDetermine the total number of fish in the model with sizes between 10 grams and 20 grams. You can use the sum() function to add together contributions from the various size classes.\n\n\n\nAgain, you should complete this exercise in the worksheet in which you already completed exercise 1."
  },
  {
    "objectID": "understand/single-species-spectra.html#other-representations",
    "href": "understand/single-species-spectra.html#other-representations",
    "title": "Single species spectra",
    "section": "Other representations",
    "text": "Other representations\nWe have seen in the previous tutorial on observed size spectra that the size spectrum can be represented in various ways. Besides the number density N(w) we introduced the biomass density B(w), the number density in log weight N_{\\log}(w) and the biomass density in log weight B_{\\log}(w). These were related to each other by multiplication by different powers of w:\nB(w) = N_{\\log}(w) = w N(w) \\text{ and } B_{\\log}(w) = w^2 N(w).\nWe can use the power argument of the plotSpectra() function to determine which of these densities to plot. Above we plotted the number density by setting power = 0. Without the power argument (or with power = 1 which is the default) the plotSpectra() function plots the biomass density as a function of weight, which is also the number density as a function of log weight:\n\nplotSpectra(params)\n\n\n\n\nNow the green line representing the biomass density of the background has a slope of -1.05 and not the -2.05 number density slope that we actually set when creating the params object.\nThe initial slope of the species biomass density is also negative, meaning that the biomass density in the species decreases with size.\nWe can also plot the biomass density in log weight, i.e., the Sheldon spectrum, by supplying the argument power = 2 to plotSpectra().\n\nplotSpectra(params, power = 2)\n\n\n\n\nThis now shows an approximately constant background biomass density in log weight (the slope of the green line is -0.05). The biomass density of the species in log size initially increases. So if binned in logarithmically-sized bins the biomass in each bin will initially increase, until it starts decreasing close to the maximum size of the species.\nThis latest plot seems to indicate that most of the biomass of the species is concentrated at larger sizes of around 30 grams, whereas the previous plot seemed to indicate that most of the biomass is at the smallest sizes. So which one is true? Please think about this question, because it really highlights the importance of not confusing biomass density with biomass. Questions about the amount of biomass at a size do not make sense. Instead you have to ask about biomass in a size range.\nSo for example, we might want to consider the prey biomass available to two different predators of our species, one small and one large. Assume that the smaller predator feeds on prey in the size range from 1g to 2g. The other predator, which we assume is 10 times larger, feeds on prey in the size range from 10g to 20g. These feeding intervals have the same width on the logarithmic weight axis. Therefore we should look at the plot of the biomass density in log weight to see that the larger predator has a lot more prey biomass from our species available to it than the smaller one. This is in spite of the fact that the plot of biomass density in weight tells us that the biomass density is lower at 10g than at 1g.\nIt may have been a bit confusing that we displayed the same size spectrum in three different ways. But it is important to be aware of this because in the literature you will see all different conventions being used, so if you see a plot of a size spectrum you always need to ask yourself exactly which density is being shown."
  },
  {
    "objectID": "understand/single-species-spectra.html#biomass",
    "href": "understand/single-species-spectra.html#biomass",
    "title": "Single species spectra",
    "section": "Biomass",
    "text": "Biomass\nAs we did for numbers above, let us also look at how to extract biomasses from the model.\nWe already said above that we can obtain the biomass density in a size class from the number density by multiplying the number density by the weight of the individuals in the size class. To obtain the appropriate weights, we use the function w() that returns the weights at the start of each size class. So we calculate\n\nbiomass_density <- n * w(params)\n\nWe obtain the total biomass in each size class by multiplying the biomass density in each size class by the width of each size class\n\nbiomass <- biomass_density * dw(params)\n\nFor example the biomass of fish between 1 gram and 1.12 grams is\n\nbiomass[61]\n\n[1] 4.005029e-05\n\n\nLet us briefly present yet another way to represent the size distribution. When we talk about size spectra, we always have the representation in terms of densities in mind. You may already be familiar with the concept of a densities from probability theory, where you can describe a probability distribution in terms of its probability density function. But perhaps you also know that there is an alternative description of the probability distribution in terms of the cumulative distribution function. We can similarly describe the size distribution of the biomass by a cumulative biomass distribution function, which gives the total biomass of all sizes up to a specific size.\n\n# Initialise an array with the right dimensions\ncumulative_biomass <- biomass\n# Calculate the cumulative sum of all biomasses in previous bins\ncumulative_biomass[] <- cumsum(biomass)\n# Normalise this so that it is given as a percentage of the total biomass\ncdf <- cumulative_biomass / cumulative_biomass[1, 101] * 100\n# Melt the array to a data frame and then plot\nggplot(melt(cdf), aes(x = w, y = value)) +\n    geom_line() + \n    labs(x = \"Weight [g]\",\n         y = \"% of total biomass\")\n\n\n\n\nThis plot shows us for example that 50% of the individuals are smaller than 12.5g and only a very small percentage is larger than 75g.\nThe biomass density is the slope of this graph. We can also plot the cumulative biomass distribution function on a logarithmic weight axis:\n\nggplot(melt(cdf), aes(x = w, y = value)) +\n    geom_line() +\n    labs(x = \"Weight [g]\",\n         y = \"% of total biomass\") +\n    scale_x_log10()\n\n\n\n\nThis graph contains exactly the same information as the previous graph, just showing more detail at smaller sizes and less detail at larger sizes. We can see for example that about 20% of individuals are less than 1g, which was difficult to see in the previous graph. The slope of this graph is the biomass density in log weight."
  },
  {
    "objectID": "understand/single-species-spectra.html#allometric-rates",
    "href": "understand/single-species-spectra.html#allometric-rates",
    "title": "Single species spectra",
    "section": "Allometric rates",
    "text": "Allometric rates\nThe first striking feature of the species size-spectrum, independently of which density you plot, is that for small fish (larvae and juveniles) it is given by a straight line. This is due to the allometric scaling of the physiological rates that our model is assuming and which we will discuss in this section. The other striking feature is the bulge at around maturity size, which we will discuss in the section on the shape of the adult spectrum.\nWe will assume that the metabolic rate, i.e., the rate at which an organism expends energy on its basic metabolic needs, scales as a power of the organism’s body size, and the power is about p = 3/4.\nBecause this energy needs to be supplied by consumption of food, it is natural to assume that also the consumption rate scales allometrically with a power of n = 3/4. When the consumption is greater than the metabolic cost then the excess leads to growth. Hence the growth rate too scales allometrically with power 3/4.\nIn a multi-species mizer model the mortality is an emergent property that depends on the abundance of predators. In this single species model the mortality rate is set to the one that would emerge if all the species in the fixed background community predated with the same ferocity as the target species. This leads to a mortality rate that scale allometrically with a power of n - 1 = 3/4 - 1 = -1/4. This means that the death rate experienced by larger individuals is smaller than that of small individuals.\nIt is a result of the mathematics that if the growth and death rates scale allometrically with exponents p and 1-p respectively, for some metabolic exponent p, that the number density at steady state is also a power law, i.e., a straight line on the log-log plot.\nLet us check that in our model the physiological rates are indeed power laws, at least for the small sizes. We can get the growth rate with the getEGrowth() function. We assign the result to a variable that we name growth_rate.\n\ngrowth_rate <- getEGrowth(params)\n\nYou can again see in the “Environment” pane that this is a matrix with one row for the one species and 101 columns for the 101 size classes. So for example the growth rate at size 1 gram is\n\ngrowth_rate[1, 61]\n\n[1] 8.26968\n\n\n(because we had seen that the 61st size class starts at 1 gram). This is the instantaneous per-capita growth rate, measured in grams per year. Note that in mizer all rates are measured in units of year, but for many people daily values are easier to understand. Since growth rate here is an instantaneous rate we can simply divide it by 365 to get a daily rate (although note that mizer does not simulate processes on daily time steps). This gives us a growth rate per day for a 1g sized fish of\n\ngrowth_rate[1, 61] / 365\n\n[1] 0.02265666\n\n\nWe would like to make a log-log plot of the growth rate against size to check that it gives a straight line. We will use ggplot() for that purpose. ggplot() likes to work with data frames instead of named matrices, so we first convert the matrix into a data frame with the melt() function.\n\ngrowth_rate_frame <- melt(growth_rate)\n\nYou can see in the “Environment” pane that the new variable that we called growth_rate_frame is a data frame with 101 observations of 3 variables. The 101 observations correspond to the 101 size classes. The 3 variables have names\n\nnames(growth_rate_frame)\n\n[1] \"sp\"    \"w\"     \"value\"\n\n\nThey are the species sp, the size w, and the value which contains the growth_rate. This data frame we can pass to ggplot().\n\np <- ggplot(growth_rate_frame) +\n    geom_line(aes(x = w, y = value)) +\n    scale_x_log10(name = \"Weight [g]\") +\n    scale_y_log10(name = \"Growth rate [g/year]\")\n\np\n\n\n\n\nNote how we linked the x axis to the w variable and the y axis to the value variable and specified that both axes should be on a logarithmic scale.\nWe see that at least up to a size of a few grams the line is straight. Let’s isolate the growth rate for those smaller sizes\n\ng_small_fish <- filter(growth_rate_frame, w <= 10)\n\nand fit a linear model\n\nlm(log(g_small_fish$value) ~ log(g_small_fish$w))\n\n\nCall:\nlm(formula = log(g_small_fish$value) ~ log(g_small_fish$w))\n\nCoefficients:\n        (Intercept)  log(g_small_fish$w)  \n              2.113                0.750  \n\n\nThe slope of the line is indeed 0.75 = 3/4. In fact, the above shows that for juveniles \\log(g(w)) \\approx 2.113 + \\frac34 \\log(w) and thus g(w) = g_0\\ w^p \\approx \\exp(2.113)\\  w^{3/4}\\approx 8.27\\  w^{3/4}.\nOf course in a real model, the growth rate would not so exactly follow a power law, because growth rate would vary depending on food availability, for example. In this example food is the background resource and its abundance is fixed, so food abundance does not vary.\n\n\n\n\n\n\nExercise 3\n\n\n\n\n\nUse the methods you have just seen to make a log-log plot of the mortality rate. You can get the mortality rate with the getMort() function. While adjusting the code to this new task, you need to take into account that the name of the size-dimension of the array returned by getMort() is \"w_prey\" instead of \"w\".\nThen fit a linear model to determine the slope and and intercept and thus the allometric exponent r and the coefficient \\mu_0 for the mortality rate \\mu(w) = \\mu_0 w^r."
  },
  {
    "objectID": "understand/single-species-spectra.html#slope-of-juvenile-spectrum",
    "href": "understand/single-species-spectra.html#slope-of-juvenile-spectrum",
    "title": "Single species spectra",
    "section": "Slope of juvenile spectrum",
    "text": "Slope of juvenile spectrum\nWe have seen that for juvenile fish the growth rate and the death rate are both power laws with exponents p=3/4 and r=p-1=-1/4 respectively. By solving a differential equation we can derive that the juvenile spectrum also follows a power law: N(w) = N_0\\ w^{-\\mu_0/g_0 - p}\nI won’t do the maths here with you (and you probably don’t want me to anyway), but we can see that the result makes sense. It tells us that the number density drops of faster with size if the mortality rate coefficient \\mu_0 is higher or if the growth rate coefficient g_0 is smaller, which is what we would expect.\nWe can also check this claim numerically. Let’s look at the spectrum of individuals up to 10 grams. By now we know how to do this. We first convert the number density matrix n into a dataframe and then filter out all observations that do not have w\\leq 10. The resulting data frame we pass to ggplot() and ask it to plot a line on log-log axes.\n\nnf <- melt(n) %>% \n  filter(w <= 10)\n\nggplot(nf) +\n  geom_line(aes(x = w, y = value)) +\n  scale_x_log10(name = \"Weight [g]\") +\n  scale_y_log10(name = \"Number density [1/g]\")\n\n\n\n\nThat confirms what we had seen earlier, that for fish less than 10 grams the number density is a power law. To determine the exponent of the power law we need the slope of that straight line in the log-log plot, and the easiest way to do that is to fit a linear model to the log variables:\n\nlm(log(nf$value) ~ log(nf$w))\n\n\nCall:\nlm(formula = log(nf$value) ~ log(nf$w))\n\nCoefficients:\n(Intercept)    log(nf$w)  \n     -8.022       -1.682  \n\n\nThe linear model fit says that the exponent is -1.682. The mathematics claimed that the exponent should be -\\mu_0 / g_0 - p. We have already observed that g_0 \\approx 8.27 and you have determined \\mu_0 in Exercise 3, so we get\n\n-m0 / g0 - 3/4\n\n[1] -1.714505\n\n\nThat is not quite the result of the linear model fit, but that is the nature of numerical calculations: one gets discretisation errors and rounding errors. Anyway it is close enough. And it is also amazing how we can calculate expected numbers of fish from basic assumptions and rules. Of course natural ecosystems never look like that, but if we have theoretical expectations derived from clear assumptions (about growth and mortality rate and food availability), we can start asking questions about which processes in natural ecosystems deviate from these generic assumptions, why this happens and how it should affect the observed size spectra."
  },
  {
    "objectID": "understand/single-species-spectra.html#shape-of-adult-spectrum",
    "href": "understand/single-species-spectra.html#shape-of-adult-spectrum",
    "title": "Single species spectra",
    "section": "Shape of adult spectrum",
    "text": "Shape of adult spectrum\nNow that we understand the shape of the size spectrum for the juvenile fish, let us try to understand the shape of the adult spectrum. Here is the plot of the biomass density again, but with the w axis restricted to weights above 10g:\n\nplotSpectra(params, wlim = c(10, NA))\n\n\n\n\nThe increase of abundance that we see at around the maturity size of our species is due to a drop in growth rate at that size. This in turn is due to the fact that the mature fish invests some of its energy into reproduction. So the details of the shape of the adult spectrum will be influenced both by food intake, maintenance and mortality (like in juveniles), but also by how adults split their energy income between growth and reproduction.\nInvestment into reproduction\nLet us look at a plot of the proportion of the available energy that is invested into reproduction as a function of the size. This is the product of the proportion of individuals that are mature (obtained with the function maturity() and the proportion of their energy income that a mature fish invests into reproduction (obtained with the function repro_prop().\n\nreprod_proportion <- maturity(params) * repro_prop(params)\n# Convert the array to a data frame for ggplot\npsi <- melt(reprod_proportion)\n\np <- ggplot(psi) +\n    geom_line(aes(x = w, y = value)) +\n    labs(x = \"Weight [g]\",\n         y = \"Proportion invested into reproduction\")\n\np\n\n\n\n\nHow was this maturity curve specified? You can find the details in the mizer documentation. There are four species parameters involved:\n\nthe maturity size w_mat at which 50% of the individuals are mature.\nthe size w_mat25 at which 25% of the individuals are mature.\nthe asymptotic size w_inf at which an organism invests 100% of its income into reproduction and thus growth is zero.\nan exponent m that determines how the proportion that an individual invests into reproduction scales with its size.\n\nSuch species parameters are contained in a data frame inside the params object that we can access with the species_params() function.\n\nspecies_params(params)\n\n                      species w_min w_inf    w_mat w_min_idx k_vb    gamma\nTarget species Target species 0.001   100 25.11886         1    1 4067.903\n                     ks  f0   fc beta sigma z0 alpha   erepro\nTarget species 5.906914 0.6 0.25  100   1.3  0   0.4 0.899483\n               interaction_resource    n    p   q pred_kernel_type        h k\nTarget species                    1 0.75 0.75 0.8        lognormal 59.06914 0\n                w_mat25 m R_max\nTarget species 22.50546 1   Inf\n\n\nAs you can see, there are a lot of other species parameters, some of which we will talk about later. For now let’s just select the 4 parameters we are interested in.\n\nselect(species_params(params), w_mat, w_mat25, w_inf, m)\n\n                  w_mat  w_mat25 w_inf m\nTarget species 25.11886 22.50546   100 1\n\n\nAnd with this knowledge of parameter we can improve the plot for clarity and add a vertical line at 25% and 50% maturation weight\n\nmaturation_weight50 <- species_params(params)$w_mat\nmaturation_weight25 <- species_params(params)$w_mat25\n\np + geom_vline(xintercept = maturation_weight50, lty = 2) +\n    geom_vline(xintercept = maturation_weight25, lty = 2, col = \"grey\")\n\n\n\n\nChange in maturity curve\nLet us investigate what happens when we change the maturity curve. Let’s assume the maturity size is actually 40 grams and the size at which 25% of individuals is mature is 30 grams. Let us change the values in the species_params data frame. But first we make a copy of the params object so that we can keep the old version around unchanged.\n\nparams_changed_maturity <- params\n\nIn this copy we now change the species parameters\n\nspecies_params(params_changed_maturity)$w_mat <- 40\nspecies_params(params_changed_maturity)$w_mat25 <- 30\nselect(species_params(params_changed_maturity), w_mat, w_mat25, w_inf, m)\n\n               w_mat w_mat25 w_inf m\nTarget species    40      30   100 1\n\n\nNow the maturity curve has changed, which we can verify by plotting it\n\npsi_changed_maturity <- melt(maturity(params_changed_maturity) * \n                                 repro_prop(params_changed_maturity))\n\nggplot(psi_changed_maturity) +\n    geom_line(aes(x = w, y = value)) +\n    geom_vline(xintercept = species_params(params_changed_maturity)$w_mat, \n               lty = 2) +\n    geom_vline(xintercept = species_params(params_changed_maturity)$w_mat25, \n               lty = 2, col = \"grey\") + \n    labs(x = \"Weight [g]\",\n         y = \"Proportion invested into reproduction\")\n\n\n\n\nTwo curves in one plot\nAt this point let’s take a little break and learn how to draw two curves in the same graph. How can we see the old maturity curve and the new maturity curve in the same plot? First we add an extra column to each dataframe describing it\n\npsi$type = \"original\"\npsi_changed_maturity$type = \"changed\"\n\nThen we bind the two data frames together\n\npsi_combined <- rbind(psi, psi_changed_maturity)\n\nand send that combined data frame to ggplot()\n\nggplot(psi_combined) +\n    geom_line(aes(x = w, y = value, colour = type)) +\n    labs(x = \"Weight [g]\",\n         y = \"Proportion invested into reproduction\")\n\n\n\n\nThis change in the maturity curve of course implies a change in the growth rates.\n\n\n\n\n\n\nExercise 4\n\n\n\n\n\nMake a plot showing the growth rates of the original model and of the model with the changed maturity curve.\n\n\n\nEffect of changed maturity\nNext let us look at how the change in the maturity parameters affects the steady state spectrum. First need to calculate the new steady state using the function singleSpeciesSteady().\n\nparams_changed_maturity <- singleSpeciesSteady(params_changed_maturity)\n\nThen we can use the function plotSpectra2() to plot the old size spectrum and the new size spectrum on the same graph.\n\nplotSpectra2(params, \"Early maturity\",\n             params_changed_maturity, \"Late maturity\",\n             power = 2, resource = FALSE, wlim = c(10, NA))\n\n\n\n\nAs expected, the bump happens later due to the larger maturity size and it is less pronounced, because the maturity curve is less steep. This means that fish do not suddenly start investing most of their energy into reproduction, but still keep growing while they are maturity. Since they are still growing they will be moving from one size class to another and fewer individuals will accumulate in one size class.\nThis was our first investigation of how the shape of a species size spectrum changes as model parameters are changed. We will do much more in this direction in the next tutorial in which we discuss how growth and mortality are determined through predation."
  },
  {
    "objectID": "understand/single-species-spectra.html#summary-and-recap",
    "href": "understand/single-species-spectra.html#summary-and-recap",
    "title": "Single species spectra",
    "section": "Summary and recap",
    "text": "Summary and recap\n1) The steady state is the state where the system has reached an equilibrium in which the rate at which individuals grow into each size class is equal to the rate at which individuals either grow out of the size class or die in the size class.\n2) Mizer stores the size spectrum in the form of the number density in size classes. To get the numbers in a size class we need to multiply the number density by the width of the size class (dw). To get total biomass in each size class we further multiple this value by the weight of this size class (w).\n3) Allometric scaling of physiological rates with size plays a big role in a mizer model and shapes the size spectrum.\n4) We studied a single species living in a fixed background community with a power-law spectrum. In this simple case we can determine the steady state spectrum and find that the juvenile spectrum is given by a power law whose exponent is determined by the ratio of mortality to growth and is different from the community spectrum power law.\n5) As fish mature they start investing some of their energy into reproduction and hence their growth slows. This leads to a bump in the size spectrum. We saw how changes in the parameters describing the maturity ogive change the shape of that bump."
  },
  {
    "objectID": "understand/predation-growth-and-mortality.html",
    "href": "understand/predation-growth-and-mortality.html",
    "title": "Predation, growth and mortality",
    "section": "",
    "text": "It is now time to discuss the important issue of predation. It is through predation that the fish obtains the energy it needs to maintain its metabolism, to grow and to invest in reproduction. But also a large proportion of the natural mortality of fish comes from predation by their predators. So it is important how mizer models predation. While you can also read about the details in the description of the general mizer size-spectrum model, in this tutorial we will approach the topic in a more hands-on experimental fashion, using the mizer package itself to help us build intuition.\nAs in the previous tutorials, we load the mizerExperimental and tidyverse packages and create a single-species model with a power-law background with exponent -2.05.\nYou will be doing your own work for this tutorial in the accompanying worksheet file “worksheet3-predation-growth-and-mortality.Rmd”. You will find this file in the worksheet repository for this week that you already used in previous tutorials."
  },
  {
    "objectID": "understand/predation-growth-and-mortality.html#growth",
    "href": "understand/predation-growth-and-mortality.html#growth",
    "title": "Predation, growth and mortality",
    "section": "Growth",
    "text": "Growth\nEffect of prey availability\nThe energy income for a fish comes from predation on its prey. If there is less prey, the fish consumes less and its growth rate will decrease. Let us investigate this by artificially removing some prey. Because in our simple single-species model we work with a fixed community spectrum that is under our control, we can do that.\nBelow we decrease the community spectrum by a factor of 10 in the size range from 1mg to 10mg.\n\n# Create a new parameter object to be able to keep the old one around unchanged.\nparams_starved <- params\n\n# Create logical vector identifying the size bins we want to change. \n# Here w_full is a mizer vector for all size bins including community and \n# modelled species\nsize_range <- w_full(params) > 10^-3 & w_full(params) < 10^-2\n\n# Divide the abundances in those size bins by 10\ninitialNResource(params_starved)[size_range] <- \n    initialNResource(params)[size_range] / 10\n\nLet’s make a plot to check that this did what we intended:\n\n# The `species = FALSE` means that we will only plot the background\nplotSpectra(params_starved, power = 2, species = FALSE)\n\n\n\n\nThe plot shows the big drop in the background abundance in our selected size range. This reduced availability of prey in that size range will lead to a drop in the growth rate in the fish that feed in that size range. We can see the slow-down in growth by comparing the growth rates in the original model and the new model. We will use the method that we saw at the end of the previous tutorial in the section “Two curves in one plot”.\n\ngf_original <- melt(getEGrowth(params))\ngf_original$Model <- \"Original\"\ngf_starved <- melt(getEGrowth(params_starved))\ngf_starved$Model <- \"Reduced prey\"\ngf <- rbind(gf_original, gf_starved)\ngrowth_rates_plot <- ggplot(gf, aes(x = w, y = value, colour = Model)) +\n    geom_line() +\n    scale_x_log10(\"Weight [g]\") +\n    scale_y_log10(\"Growth rate [g/year]\")\ngrowth_rates_plot\n\n\n\n\nThe slow-down occurs at a size that is about a factor of 100 larger than the size at which food is reduced. Why this is we will discuss in the next section.\nThe dip in the growth rate may not seem very significant in the above plot, but it has a dramatic effect on the steady state size distribution of our species. We know from the previous tutorial that we can set the abundances in the single-species model to the steady state value with\n\nparams_starved <- singleSpeciesSteady(params_starved)\n\nWe can now plot this:\n\nplotSpectra(params_starved, power = 2)\n\n\n\n\nIt would again be nice to put this onto the same plot as the original model. So we need to adapt our previous method for combining plots to the case where the plot is created by one of mizer’s built-in plot functions.\nWe first get the data frames behind the plots by specifying the return_data = TRUE argument.\n\nbf_original <- plotSpectra(params, power = 2, wlim = c(1e-3, NA),\n                           return_data = TRUE)\nbf_starved <- plotSpectra(params_starved, power = 2, wlim = c(1e-3, NA),\n                          return_data = TRUE)\n\nWe add an extra column Model to each dataframe describing it and then bind the two data frames together:\n\nbf_original$Model <- \"Original\"\nbf_starved$Model <- \"Reduced prey\"\n\nbf <- rbind(bf_original, bf_starved)\n\nWe send the combined dataframe to ggplot, specifying that the linetype should be determined by the variable Model:\n\nspectra_plot <- ggplot(bf, aes(x = w, y = value, colour = Legend, \n                               linetype = Model)) +\n    geom_line() +\n    scale_x_log10(\"Weight [g]\") +\n    scale_y_log10(\"Biomass density [g]\") + \n    # The following uses the same colours as the built-in plot functions\n    scale_colour_manual(values = getColours(params), limits = force)\nspectra_plot\n\n\n\n\nThe lack of food and the resulting slow-down in growth leads to a traffic jam: a peak in the biomass density and then low density on the other side of the traffic jam. Because fish do not get enough food and do not grow into the next size class, they are stuck in smaller size classes for a long time and are affected by mortality, which is higher for small size classes.\nOne may think that the drop in abundance is at sizes where the predator encounters fewer prey than before and thus has lower growth rate. This is what classic predator-prey thinking would suggest: low prey abundance leads to low predator abundance. Size spectrum dynamics is different. To drive this point home we will display the growth rate plots and the spectrum plots directly above each other\n\n\n\ngrowth_rates_plot\nspectra_plot\n\n\n\n\n\n\n\n\n\nWe see that where the growth starts slowing down, the abundance actually increases. This is because a decrease in the growth rate leads to a pile-up of individuals. You know this phenomenon from traffic jams. Where the speed of the cars decreases on a motorway, their density increases. Then when the speed increases again on the other side of the traffic jam, the density of cars drops and you wonder what caused the traffic jam in the first place. We see the same phenomenon in size spectrum dynamics. We see from the graphs above: it is where the growth rate starts growing faster again that the density goes down.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nThe above shows that size spectrum dynamics is very different from predator-prey dynamics.\n\n\n\nThe reduction of prey has led to a significant reduction in the overall abundance of the species. This is in spite of the fact that we have kept the abundance constant at the lowest size, i.e. we assumed that recruitment of new fish is not affected by what happens in larger size classes. In reality, the drastic reduction of spawning stock biomass will lead to a reduction in the number of eggs as well, so the effect will be even more dramatic.\nHere we hand over to you to investigate what happens when the prey abundance is increased instead of decreased. Please open the worksheet named “worksheet3-predation-growth-and-mortality.Rmd” in your worksheet repository, where you will find the following exercise:\n\n\n\n\n\n\nExercise 1\n\n\n\n\n\nMake a single plot, similar to the one above, comparing the steady state biomass density in log weight in the original model with that when the community abundance is increased by a factor of 10 in the size range from 1mg to 10mg."
  },
  {
    "objectID": "understand/predation-growth-and-mortality.html#how-predation-is-modelled",
    "href": "understand/predation-growth-and-mortality.html#how-predation-is-modelled",
    "title": "Predation, growth and mortality",
    "section": "How predation is modelled",
    "text": "How predation is modelled\nThe easiest case in which to understand predation is to imagine a filter feeding fish, swimming around with its mouth open. Clearly the amount of food it takes in is determined by four things:\n\nthe density of prey in the water,\nhow much volume of water the fish is able to filter, which will depend on how fast it swims as well as on its gape size.\nwhat sizes of prey the fish is able to filter out of the water, which will be limited by its gape size and by how fine its gill rakers are,\nhow fast it can digest the food. If it can filter the prey faster than it can digest, it will have to start letting prey go uneaten.\n\nFor a more active hunter the situation will be similar. The rate at which it predates will depend on four things:\n\nthe density of prey in the water\nthe volume of water that the fish patrols and in which it will be able to seek out its prey. This may depend on things like radius of vision.\nwhich of this detected prey the fish is able to catch, which will depend on its mouth size but also on its agility and skill as well as on the defensive mechanisms of the prey.\nhow fast it can digest the food.\n\nOf these four factors, we have already been discussing the density of prey. In the next section we will discuss the ability to filter out or catch prey of particular sizes, which we model via the predation kernel. In the section after that we will discuss the search volume and then in the following section the maximum consumption rate.\nThe predation kernel\nFish will be particularly good at catching prey in a specific range of sizes, smaller than themselves. This is encoded in the size-spectrum model by the predation kernel. Let us take a look at the predation kernel in our model. We can obtain it with the function getPredKernel().\n\npred_kernel <- getPredKernel(params)\n\nThis is a large three-dimensional array (predator species x predator size x prey size). We extract the kernel of a predator of size 10g (using that we remember that this is in size class 81)\n\npred_kernel_10 <- pred_kernel[, 81, , drop = FALSE]\n\nThe drop = FALSE option is there to prevent R from dropping any of the array dimensions. We can now plot this as usual\n\nggplot(melt(pred_kernel_10)) +\n  geom_line(aes(x = w_prey, y = value)) +\n  scale_x_log10()\n\n\n\n\nWe see that the predator of size 10g likes to feed on prey that is about the size of 0.1g, which is about 100 times smaller than itself. But it also feeds on other sizes, just with reduced preference. The preferred predator/prey size ratio is determined by the species parameter beta and the width of the feeding kernel, i.e., how fussy the predator is regarding their prey size, is determined by the species parameter sigma. beta is the preferred predator prey mass ratio or PPMR. Larger PPMR values mean that the predator prefers to feed on a relatively smaller prey (larger ratio). In our model these have the values\n\nselect(species_params(params), beta, sigma)\n\n               beta sigma\nTarget species  100   1.3\n\n\nLet us change the preferred predator prey mass ratio from 100 to 1000. As usual, we first create a copy of the parameter object, then we make the change in that copy.\n\nparams_pk <- params\nspecies_params(params_pk)$beta <- 1000\n\nLet’s make a plot to see that the predation kernel has indeed changed.\n\ngetPredKernel(params_pk)[, 81, , drop = FALSE] %>% \n  melt() %>% \n  ggplot() +\n  geom_line(aes(x = w_prey, y = value)) +\n  scale_x_log10()\n\n\n\n\nIf we now again reduce the prey in the size range from 1mg to 10mg as before, we now expect this to produce a peak in the biomass spectrum somewhere between 1g and 10g. Let’s check.\n\n# Put reduced resource abundance values into params_pk \ninitialNResource(params_pk) <- initialNResource(params_starved)\n# Find the new steady state, because conditions have changed.\nparams_pk <- singleSpeciesSteady(params_pk)\n\nbf_pk <- plotSpectra(params_pk, power = 2, return_data = TRUE)\nbf_pk$Model <- \"Reduced prey, large PPMR\"\nbf <- rbind(bf_original, bf_starved, bf_pk)\nggplot(bf, aes(x = w, y = value, colour = Legend, linetype = Model)) +\n    geom_line() +\n    scale_x_log10(\"Weight [g]\") +\n    scale_y_log10(\"Biomass density [g]\") + \n    # The following uses the same colours as the built-in plot functions\n    scale_colour_manual(values = getColours(params), limits = force)\n\n\n\n\nThe dip is indeed happening later.\nYou can see another phenomenon in the above plot: Initially the biomass density in log weight is increasing faster in the model with the larger PPMR. Can you explain why? This is something worth discussing at one of the online meetings this week.\n\n\n\n\n\n\nLinks to documentation\n\n\n\n\n\nFor details of how beta and sigma parametrise the predation kernel, see https://sizespectrum.org/mizer/reference/lognormal_pred_kernel.html#details. For information on how to change the predation kernel, see https://sizespectrum.org/mizer/reference/setPredKernel.html#setting-predation-kernel\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n\nDo not confuse the prey preference with the diet. Just because a predator might prefer to feed on prey of a particular size if it had free choice does not mean that it actually feeds predominantly on such prey. The actual diet of the fish depends also on the availability of prey. Because smaller prey are more abundant, the realised predator prey mass ratio in the diet will be smaller than the preferred predator prey mass ratio. This is particularly important when estimating the predation kernel from stomach data.\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\n\n\nChange the parameters of the predation kernel to beta = 50 and sigma = 2 and plot the predation kernel of a predator of size 1g. You should see that the predation kernel is truncated so that the predator never feeds on prey larger than themselves.\nNext, plot the steady state arising with this feeding kernel when the prey abundance is artificially reduced by a factor of 10 in the size range between 1mg and 10mg as in previous examples. What do you observe? Are you surprised?\n\n\n\nSearch volume\nNext we consider the factor that models the volume of water a filter feeder is able to filter in a certain amount of time, or the volume of water a forage fish is able to patrol in a certain amount of time. This is difficult to model from first principles, although people have tried to argue in terms of swimming speeds of fish. We assume that this search volume rate is also an allometric rate. Let \\gamma(w), also called gamma, denote this rate for a predator of size w. Thus we assume that \\gamma(w) = \\gamma_0\\ w^q for some exponent q. We know that a fish needs to consume prey at a rate that scales with its body size to the power n, with n about 3/4. We also know that the prey density will be approximately described by a power law, i.e., that N(w) \\approx N_0\\ w^{-\\lambda}. A bit of maths then says that q = 2 - \\lambda + n. This explains the message you got when you created the params object with a certain choice of \\lambda: mizer chose the search volume exponent automatically according to this formula. The formula is based on observations about size distributions and the fact that in the real world, evolution had made sure that the fish have developed a feeding strategy that allows it to cover its metabolic costs. Together this would have led to that search volume exponent of approximately q=2-\\lambda+n but of course in reality there is quite a bit of variability.\nThis is one of many powerful aspects about strong theoretical basis behind size based models. We can of course disagree with this assumption if we have evidence and data, but at least there is a basic assumption to base the discussion on.\nMost people using mizer rarely modify the default assumptions about the body scaling exponents and focus on more on the coefficients. So let us see what effect changing the coefficient \\gamma_0 in the search volume rate has. Its current value in our model is\n\nspecies_params(params)$gamma\n\n[1] 4067.903\n\n\nWe change that to 2000 and find the new steady state.\n\nparams_new_gamma <- params\nspecies_params(params_new_gamma)$gamma <- 2000\nparams_new_gamma <- singleSpeciesSteady(params_new_gamma)\n\nWe can see the effect in the growth curve of our species.\n\ngf_original <- plotGrowthCurves(params, return_data = TRUE)\ngf_original$Model <- \"Original\"\ngf_new <- plotGrowthCurves(params_new_gamma, return_data = TRUE)\ngf_new$Model <- \"Reduced search volume\"\n\nggplot(rbind(gf_original, gf_new), aes(x = Age, y = value, colour = Model)) +\n    geom_line()\n\n\n\n\nAs expected, the smaller search volume leads to a slower growth due to slower feeding rate.\n\n\n\n\n\n\nExercise 3\n\n\n\n\n\nWhat effect will this change in growth rate have on the slope of the juvenile spectrum? Will it be steeper or shallower? Make the plot of the spectrum to see.\n\n\n\nFeeding level\nIn mizer we assume that feeding rate follows a Holling type II feeding curve. This means that feeding rate is increasing fast at low prey densities, but then reaches a maximum or satiation level. So a predator will not be able to utilise food at a faster rate than its maximum intake rate. Of course in practice it will not feed at the maximum intake rate because of limited availability of prey. We describe this by the feeding level which is the proportion of its maximum intake rate at which the predator is actually taking in prey.\nIn our simple model this feeding level is constant across all fish body sizes (this is rarely the case in more realistic models, as you will see later).\n\nplotFeedingLevel(params) + theme(text = element_text(size = 20))\nplotFeedingLevel(params_new_gamma) + theme(text = element_text(size = 20))\n\n\n\n\n\nOriginal\n\n\n\n\n\n\nModified\n\n\n\n\n\n\nIn the model with the reduced search volume the feeding level is lower, as one would expect.\nThe feeding level will depend on the maximum intake, search rate and food availability. The maximum intake rate scales with body size with the exponent n = 3/4 and is determined by the coefficient h. So the maximum intake rate at size h(w) is modelled as h(w) = h w^n. Again, if we want to modify the maximum intake rate we usually change the coefficient h. We will do that in later tutorials. The current value of the coefficient h is\n\nspecies_params(params)$h\n\n[1] 59.06914\n\n\nand is measured in g of food per g^-n of predator weight per year (remember, maximum consumption scales with fish weight with the power of n)."
  },
  {
    "objectID": "understand/predation-growth-and-mortality.html#mortality",
    "href": "understand/predation-growth-and-mortality.html#mortality",
    "title": "Predation, growth and mortality",
    "section": "Mortality",
    "text": "Mortality\nPredation mortality\nOf course feeding of the predator is only one aspect of predation. The other is the death of the prey. Feeding and mortality are coupled. Increased feeding and growth of one class of individuals will necessitate increased death of another. There is no free lunch.\nOnce we have specified the predation parameters, these parameters determine both the growth of predators but also the mortality rate of prey. So we don’t have to introduce new parameters for death from predation. Of course with a one species model we cannot easily demonstrate this predation. We will explore predation more thoroughly in future tutorials.\nBackground and external mortality\nIn more realistic multi-species models mortality component also includes a baseline, size-independent mortality. This is also often called background mortality and it accounts for processes that are not related to predation, for example disease. This background mortality in mizer is assumed to depend on the maximum body size of a species, as you will see later.\nIn addition, mizer allows you to include other sources of external mortality. This could be predation from animals that we have not included in our model, like sea birds or mammals, death from old age (senescent death) and so on.\nFishing mortality\nThe cause of mortality that is most under our control is mortality from fishing. We discuss more how fishing is set up in mizer in week 3 of this course when we study the consequences of changes in fishing rates. Here we only look at a simple example: we introduce fishing on our species only for fish above 30 grams. All fish greater than 30 grams will be exposed to the same fishing mortality. We call this kind of fishing selectivity “knife_edge” selectivity. Mizer can of course also deal with more general selectivity curves, like sigmoidal or doubly sigmoidal.\n\nparams_fishing <- params\ngear_params(params_fishing)$sel_func <- \"knife_edge\"\ngear_params(params_fishing)$knife_edge_size <- 30\n\nWe also need to specify the fishing effort or fishing mortality, which we set as an annual instantaneous fishing mortality rate. Now we can then plot the resulting fishing mortality. For illustration we will set a rate of 1 per year.\n\ninitial_effort(params_fishing) <- 1\nplotFMort(params_fishing)\n\n\n\n\nWe can now see how fishing affects the adult size spectrum.\n\n# We find the new steady state with fishing mortality imposed \nparams_fishing <- singleSpeciesSteady(params_fishing)\n\nplotSpectra2(params, \"No Fishing\", params_fishing, \"Knife-edge\",\n             power = 2, wlim = c(10, NA))\n\n\n\n\nThe difference may not seem to be very big, but note that we are using a logarithmic scale on the y axis. At large sizes the biomass densities differ almost by a factor of 10."
  },
  {
    "objectID": "understand/predation-growth-and-mortality.html#summary-and-recap",
    "href": "understand/predation-growth-and-mortality.html#summary-and-recap",
    "title": "Predation, growth and mortality",
    "section": "Summary and recap",
    "text": "Summary and recap\n1) In a mizer model the growth curve is not fixed but instead the growth rate of an individual changes as the prey abundance changes. This makes it important to understand how fish choose their prey.\n2) A size spectrum model reacts differently to low prey abundance than a predator-prey model. In a size spectrum model when the growth rate of a predator slows down due to lack of prey, the abundance of predators of that size increases.\n3) A fish is assumed to have a feeding preference for prey in a range of sizes at a certain fraction of its own size. So as the fish grows up, its preference shifts to larger sizes, so that the preferred predator prey mass ratio \\beta (beta) stays the same.\n4) The search rate of a species determines the rate at which it can find food and thus influences its growth rate. In mizer this search rate is an allometric rate with exponent q which by default is set as q=2-\\lambda+n so that at least in the larval stage the growth rate scales with exponent n = 3/4.\n5) Fish have a maximum intake rate that scales with body size with exponent n = 3/4. Due to scarcity of prey they will only feed at a proportion of their maximum intake rate. This proportion is called the feeding level.\n6) Species size spectra depend strongly on mortality rates and in a realistic model this mortality rate will depend on the abundance of predators. We will explore this in greater detail in the next tutorials. Here we just looked at the effect of fishing mortality on the size spectrum."
  },
  {
    "objectID": "understand/observed-size-spectra.html",
    "href": "understand/observed-size-spectra.html",
    "title": "Observed size spectra",
    "section": "",
    "text": "In this tutorial you will take observational data and plot the resulting size spectra for the community and for individual species. This will give you a concrete understanding of what size spectra are. There are various different ways of how size spectra can be represented, and this is a common source of confusion. We will discuss this in detail."
  },
  {
    "objectID": "understand/observed-size-spectra.html#introduction",
    "href": "understand/observed-size-spectra.html#introduction",
    "title": "Observed size spectra",
    "section": "Introduction",
    "text": "Introduction\nWe will start the introduction into size spectra using text from Ken H Andersen’s book “Fish Ecology, Evolution, and Exploitation” (2019):\n\nWhat is the abundance of organisms in the ocean as a function of body size? If you take a representative sample of all life in the ocean and organize it according to the logarithm of body size, a remarkable pattern appears: the total biomass of all species is almost the same in each size group. The sample of marine life does not have to be very large for the pattern to appear. … What is even more surprising is that the pattern extends beyond the microbial community sampled by plankton nets—it persists up to the largest fish, and even to large marine mammals.\n\n\nThis regular pattern is often referred to as the Sheldon spectrum in deference to R. W. Sheldon, who first described it in a ground-breaking series of publications. Sheldon had gotten hold of an early Coulter counter that quickly and efficiently measured the size of microscopic particles in water. Applying the Coulter counter to microbial life in samples of coastal sea water, he observed that the biomass was roughly independent of cell size among these small organisms (Sheldon and Parsons, 1967). And he saw the pattern repeated again and again when he applied the technique to samples from around the world’s oceans. Mulling over this result for a few years, he came up with a bold conjecture (Sheldon et al., 1972): the pattern exists not only among microbial aquatic life, but it also extends all the way from bacteria to whales.\n\nYou can read more about this work in the references below:\nSheldon, R. W., and T. R. Parsons (1967). “A Continuous Size Spectrum for Particulate Matter in the Sea.” Journal Fisheris Research Board of Canada 24(5): 909–915.\nSheldon, R.W., A. Prakash, andW. H. Sutcliffe (1972). “The Size Distribution of Particles in the Ocean.” Limnology and Oceanography 17(3): 327–340\nBlanchard, J. L., Heneghan, R. F., Everett, J. D., Trebilco, R., & Richardson, A. J. (2017). From bacteria to whales: using functional size spectra to model marine ecosystems. Trends in ecology & evolution, 32(3), 174-186.\nK.H. Andersen, N.S. Jacobsen and K.D. Farnsworth (2016): The theoretical foundations for size spectrum models of fish communities. Canadian Journal of Fisheries and Aquatic Science 73(4): 575-588.\nK.H. Andersen (2019): Fish Ecology, Evolution, and Exploitation - a New Theoretical Synthesis. Princeton University Press.\nAnd in many other references listed in the sizespectrum.org publications page"
  },
  {
    "objectID": "understand/observed-size-spectra.html#example-code",
    "href": "understand/observed-size-spectra.html#example-code",
    "title": "Observed size spectra",
    "section": "Example code",
    "text": "Example code\nThese tutorials contain a lot of working R code, because learning R coding for mizer is best done by looking at example code. We envisage that you may want to copy and paste the code from this tutorial into your tutorial worksheet to try it out and possibly modify it to see what happens.\n\n\n\n\n\n\n\n\n\nTo analyse and plot the data we will be making use of the tidyverse package, in particular dplyr and ggplot2. If you are not familiar with these, you can learn what is needed just by studying the example code in this tutorial. Before we can use a package we need to load it in from the package library with the library() function:\n\nlibrary(tidyverse)\n\nWhen you hover over any function name in the R code in these tutorials, you will notice that they are links. If you click on them this will open the function’s help page in a new browser window. Thus you can always easily read more information about the functions we are using.\nYou will find explanations of the code if you expand the “R details” sections located below many of the code chunks. To expand an explanation section, just click on the “Expand for R details”."
  },
  {
    "objectID": "understand/observed-size-spectra.html#the-data",
    "href": "understand/observed-size-spectra.html#the-data",
    "title": "Observed size spectra",
    "section": "The data",
    "text": "The data\nSo let’s see if we can find Sheldon’s pattern ourselves. First we load the data.\n\ndata <- readRDS(\"size-data.rds\")\nstr(data)\n\n'data.frame':   925594 obs. of  3 variables:\n $ species: chr  \"Cod\" \"Cod\" \"Cod\" \"Cod\" ...\n $ weight : num  52.77 56.37 6.14 5.66 5.89 ...\n $ length : num  17.41 17.8 8.5 8.27 8.38 ...\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nThe readRDS() function loads the file “size-data.rds” which contains the data frame with the size data. We assign this data frame to the variable data for use below and then, to get an impression of what is in the data frame we use the str() function.\n\n\n\nThe data consists of measurements of the length in centimetres of 925594 fish of various species. The species included are\n\nunique(data$species)\n\n[1] \"Cod\"       \"Whiting\"   \"Haddock\"   \"Saithe\"    \"Herring\"   \"Sandeel\"  \n[7] \"Nor. pout\" \"Plaice\"    \"Sole\"     \n\n\nThis data was assembled by Ken Andersen at DTU Aqua in Copenhagen. The length in centimetres l was converted to weight in grams w using the standard allometric relationship\n w = a\\, l ^ b,\nwhere the coefficient a and the exponent b are species-specific parameters (we’ll discuss how to find such species parameters in a later tutorial). The reason we like to work with weight as the measure of a fish’s size is that there are well-known allometric relationships between weight and physiological rates. For example, metabolic rate is generally expected to scale as w^{3/4} and mortality to scale as w^{-1/4}, as we will be discussing in the section on allometric rates in the next tutorial.\n\n\n\n\n\n\nImportant\n\n\n\nWhen not otherwise specified, all lengths are given in centimetres [cm] and all weights are given in grams [g]."
  },
  {
    "objectID": "understand/observed-size-spectra.html#histogram",
    "href": "understand/observed-size-spectra.html#histogram",
    "title": "Observed size spectra",
    "section": "Histogram",
    "text": "Histogram\nTo get an impression of the size distribution of the fish, we plot a histogram of the fish weights.\n\np <- ggplot(data) +\n    geom_histogram(aes(weight), fill = \"blue\", colour = \"black\") +\n    scale_x_continuous(name = \"Weight [g]\") +\n    scale_y_continuous(name = \"Number of fish\")\n\np\n\n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nWe have used the ggplot2 package, included in the tidyverse package, to make the plot. It is much more powerful and convenient than the base plot commands. It implements the “grammar of graphics”. If you are not already using ggplot2 it is worth your time to familiarise yourself with it. However for the purpose of this tutorial, you can simply pick up the syntax from the examples we give.\nIn the above we first specify with ggplot(data) that the graph shall be based on the data frame data that we loaded previously. We then add features to the graph with the +.\nFirst geom_histogram() specifies that we want a histogram plot. The argument specifies the variable to be represented. Note how this is wrapped in a call to aes(). Don’t ask why, that is the way the grammar of graphics likes it. The specification of how the variables are tied to the aesthetics of the graph will always be given withing the aes() function.\nWe then specify that we want the bars in the histogram to be blue (fill = \"blue\") with a black border (colour = \"black\"). Such tuning of the appearance is of course totally optional. By the way: one has to admire how the ggplot2 package accepts both colour and color, so that our US friends can use color = \"black\".\nThen we add our own labels to the axes with labs().\nWe assign the resulting plot to the variable p because that way we can manipulate the plot further below. Because the assignment operator in R does not display any result, we added another line with just the variable name p which will display the plot.\n\n\n\nThe plot is not very informative. It just tells us that most fish are very small but there is a small number of very large fish. We can not see much detail. We will apply 3 methods to improve the graph.\nLogarithmic y axis\nThe first way to improve the plot is to plot the y-axis on a logarithmic scale. That has the effect of stretching out the small values and squashing the large values, revealing more detail.\n\np + scale_y_log10()\n\nWarning: Transformation introduced infinite values in continuous y-axis\n\n\nWarning: Removed 2 rows containing missing values (geom_bar).\n\n\n\n\n\nWe get a warning because there were bins that contained no fish, and taking the log of 0 is not allowed. We can ignore these warnings because the empty bins will simply not be given a bar in the resulting plot.\nLogarithmically sized bins\nThe second way to deal with the fact that there are so many more small fish than large fish, is to make the bin widths different. At the moment all bins are the same width, but we can make bin widths larger at larger sizes and smaller at smaller sizes. For example we could make the smallest bin go from 1 gram to 2 gram, the next bin to go from 2 gram to 4 gram, and so on, with each next bin twice the size of the previous. This means that for large fish bins will be very wide and a lot more individuals will fall into these bins. So let’s create the break points between these bins:\n\n(log_breaks <- seq(from = 0, to = 11, by = 1))\n\n [1]  0  1  2  3  4  5  6  7  8  9 10 11\n\n(binbreaks <- 2 ^ log_breaks)\n\n [1]    1    2    4    8   16   32   64  128  256  512 1024 2048\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nWe had decided that we wanted the breaks between the bins to be located at powers of 2. We first create the vector log_breaks with the exponents. The seq() function creates a vector of numbers starting at from and going up to to in steps of size by. You do not need to give the names of the arguments because they can also be identified by their position. So you could also have written seq(0, 11, 1). Such integer sequences are used so often that there is the even shorter notation 0:11 giving the same sequence.\nThe second line above creates a vector containing the powers of 2 with the exponents we just created in the vector log_breaks. Note how R can perform calculations for all entries of a vector at once, without the need for a loop.\nThe reason we have put parentheses ( ... ) around the assignments in the above code is because that also leads to the result being displayed whereas the assignment operator without those parentheses around it would not display anything.\n\n\n\nNow we can use these logarithmically spaced bins in the histogram while also keeping the logarithmic y-axis.\n\np2 <- ggplot(data) +\n    geom_histogram(aes(weight), fill = \"blue\", colour = \"black\",\n                   breaks = binbreaks) +\n    labs(x = \"Weight [g]\",\n         y = \"Number of fish\") +\n    scale_y_log10()\np2\n\n\n\n\nThe heights are now slightly more even among the bins, because the largest bin is so wide.\nIt is very important that you break up your reading of the tutorials with some hands-on work that builds on what you have just learned. Therefore you will find exercises throughout the tutorials. You have now reached the first exercise. You will find that it can be accomplished using the R functions you have already learned about. Please do your work in the worksheet that accompanies this tutorial and that you will find in this week’s worksheet repository.\nIf you have not yet created this week’s worksheet repository, you can do so by following this link to accept your assignments for week 1:\nhttps://classroom.github.com/a/5cnr1H7R\nOnce your repository has been created on GitHub, you will be given the URL that you need to clone it to your computer by creating a new project in RStudio. To do that you will need to follow the same steps as in the Use Git and GitHub tutorial. You may want to review the instructions in the Create repository and Clone repository sections.\nYou will find the worksheet for this tutorial in the file “worksheet1-observed-size-spectra.Rmd” in your worksheet repository for this week. In that worksheet you will find the following first exercise:\n\n\n\n\n\n\nExercise 1\n\n\n\n\n\nNow you want to double the number of logarithmically-sized bins used to get a more detailed picture of the size spectrum. So instead of using 11 bins to cover the range from 1g to 2048g, where each bin is twice as large as the previous, you want to use 22 bins where each bin is larger than the previous one by a factor of \\sqrt{2}.\nCreate the vector with the breaks between the bins and then use that when you plot the histogram.\n\n\n\nAfter successful completion of that exercise, return here to continue with the tutorial. Do not do the other exercises until you reach them in this tutorial.\nLogarithmic w axis\nFinally, we can also display the weight axis on a logarithmic scale:\n\np2 + scale_x_log10()\n\n\n\n\nNote how on the logarithmic axis the logarithmically-sized bins all have the same width.\nDensities\nNote that the height of the bars changed as we changed how we bin the data. That is obvious. If we make a bin twice as large, we expect twice as many fish in that bin.\nNow please pay attention! We want to get rid of this dependence on the choice of the bin width. We want to represent the data in a way that does not depend on our choice of binning. We can do this if we divide the height of each bar by its width. This means we will work with density and the bin height will be scaled by the bin width.\nBecause it is important to understand this concept of density, we will calculate the number density by hand below, even though ggplot has a built-in function geom_density() that we could use instead. We first bin the data by hand, and then we calculate and plot the densities."
  },
  {
    "objectID": "understand/observed-size-spectra.html#binning",
    "href": "understand/observed-size-spectra.html#binning",
    "title": "Observed size spectra",
    "section": "Binning",
    "text": "Binning\nTo understand better what the histogram did and to improve the plots further, we bin the data ourselves. We do this by first adding a bin number to each observation, which indicates in which bin the weight of the fish lies.\n\ndata_with_bins <- data |>\n    mutate(bin = cut(weight, breaks = binbreaks, right = FALSE,\n                     labels = FALSE))\nhead(data_with_bins)\n\n  species    weight    length bin\n1     Cod 52.771869 17.410082   6\n2     Cod 56.370714 17.797179   6\n3     Cod  6.142102  8.500393   3\n4     Cod  5.656656  8.270275   3\n5     Cod  5.885482  8.380322   3\n6     Cod  5.917816  8.395640   3\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nWe used the pipe operator |> that simply pipes the output of the code preceeding it into the first argument of the function following it. So the above code is equivalent to\n\ndata_with_bins <- mutate(data, bin = cut(weight, breaks = binbreaks, \n                                         right = FALSE, labels = FALSE))\n\nThe pipe operator becomes really useful only if you do a longer sequence of operations on data. You will see examples of its use later.\nThe mutate() function can add new columns to a data frame or modify existing columns. In the above example it adds a new column bin. The entries in that column are here calculated by the function cut that returns the label of the bin into which an observation falls. We specify the bin boundaries with the breaks = binbreaks to be the boundaries we have calculated above. The right = FALSE means that in case an observation falls exactly on a right bin boundary, it is not included in that bin but instead in the next bin. The labels = FALSE means that the bins are not labelled by the intervals but simply by integer codes.\n\n\n\nWe then group the data by bin and calculate the number of fish in each bin\n\nbinned_numbers <- data_with_bins |> \n    group_by(bin) |> \n    summarise(Numbers = n())\nbinned_numbers\n\n# A tibble: 11 × 2\n     bin Numbers\n   <int>   <int>\n 1     1  223609\n 2     2  188847\n 3     3  279646\n 4     4  132316\n 5     5   53082\n 6     6   17039\n 7     7   14238\n 8     8   15061\n 9     9    1570\n10    10     159\n11    11      27\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nAfter we have grouped together all the observations with the same bin number with the group_by(bin), the summarize() function creates a new data frame with one row for each group, which in this case means one row for each bin. That data frame will always have one column specifying the group and then we specified that we want an extra column Numbers that just counts the number of observations in the group with the n() function. Note that the species is ignored in this calculation.\nIn the above code you see the pipe operator |> being quite convenient, because it allows us to write the functions in the order in which they are applied, rather than having to write summarize(group_by(...)).\n\n\n\nThe numbers in each bin give us the heights of the histogram above."
  },
  {
    "objectID": "understand/observed-size-spectra.html#number-density",
    "href": "understand/observed-size-spectra.html#number-density",
    "title": "Observed size spectra",
    "section": "Number density",
    "text": "Number density\nThe values for Numbers of course depend on the size of the bins we have chosen. Wider bins will have more fish in them. It is therefore convenient to divide these numbers by the bin widths to get the average number density in the bins.\n\nbin_width <- diff(binbreaks)\n\nbinned_numbers <- binned_numbers |> \n    mutate(Number_dens = Numbers / bin_width[bin])\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nWe first calculate the widths of the bins using the diff() function which calculates the difference between neighbouring entries in a vector. Then when we calculate the entries for the new Number_dens column we pick out the bin width appropriate to the given bin for each observation.\n\n\n\nLet’s make a plot of the number density against weight. Note that we only estimated the number density of weights within each bin, so we only have an average value which we use to determine the height of the curve at the midpoint of the bin. So the plot interpolates between these discrete points (at the midpoint of each bin weights) by straight lines to produce a continuous curve.\n\nbin_midpoints <- 2 ^ (log_breaks[-length(log_breaks)] + 1/2)\n\nbinned_numbers$bin_midpoint = bin_midpoints\n\nggplot(binned_numbers) +\n    geom_line(aes(x = bin_midpoint, y = Number_dens)) +\n    scale_x_continuous(name = \"Weight [g]\") +\n    scale_y_continuous(name = \"Number density\")\n\n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nWe first calculate a vector bin_midpoints holding the midpoint of all the bins. We do this using the vector log_breaks[-length(log_breaks)] which contains all the entries of log_breaks except the last. We then add a bin_midpoint column to the dataframe binned_numbers and use that as the variable for the x-axis in the plot.\n\n\n\nAgain the graph tells us that most of the individuals are very small, but we can not see any of the details. We therefore plot the density on log-log axes:\n\nggplot(binned_numbers) +\n    geom_line(aes(x = bin_midpoint, y = Number_dens)) + \n    scale_x_log10(name = \"Weight [g]\") + \n    scale_y_log10(name = \"Number density\")\n\n\n\n\nIt is time for your second exercise of the course. Go back to your week 1 exercise project in RStudio, and do Exercise 2 in worksheet 1:\n\n\n\n\n\n\nExercise 2\n\n\n\n\n\nEarlier you increased the number of bins from 11 to 22. Because the same number of observed fish was then spread over this larger number of bins, all the bars in the histogram were accordingly less high. By going to the number density we have corrected for this. The density plot created with the 22 bins will of course not look exactly the same as the one created with 11 bins. It will look more ragged because it exposes the noise in the data more.\nCreate the plot of the number density using the 22 logarithmically sized bins from exercise 1."
  },
  {
    "objectID": "understand/observed-size-spectra.html#fitting-a-power-law",
    "href": "understand/observed-size-spectra.html#fitting-a-power-law",
    "title": "Observed size spectra",
    "section": "Fitting a power law",
    "text": "Fitting a power law\nThe number density in the above log-log plot is described approximately by a straight line. We can approximate the slope and intercept of that straight line by fitting a linear model\n\n(model <- lm(log(Number_dens) ~ log(bin_midpoint), data = binned_numbers))\n\n\nCall:\nlm(formula = log(Number_dens) ~ log(bin_midpoint), data = binned_numbers)\n\nCoefficients:\n      (Intercept)  log(bin_midpoint)  \n           14.563             -2.241  \n\n\nThis tells us that the straight-line approximation has a slope of about -2.24. We can also ask ggplot to put this line into the plot, together with its 95% confidence interval:\n\nggplot(binned_numbers, aes(x = bin_midpoint, y = Number_dens)) +\n    geom_line() + \n    scale_x_log10(name = \"Weight [g]\") + \n    scale_y_log10(name = \"Number density\") +\n    geom_smooth(method = 'lm')\n\n`geom_smooth()` using formula 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nThe linear regression line is produced by geom_smooth(method='lm'). Note how we moved the call to aes() into the call to ggplot(). That is then used automatically for both the geom_line() and the geom_smooth(), so that we did not have to specify the information twice.\n\n\n\nIf we denote the number density at weight w by N(w), then the above tells us that \\log(N(w)) \\approx 14.6 + \\log(w)^{-2.24}.\nIf we exponentiate both sides to get rid of the logarithms this gives\n\nN(w) \\approx \\exp(14.6) w^{-2.24} = N(1) w^{-\\lambda}\n\nwith \\lambda \\approx 2.24.\n\n\n\n\n\n\nImportant\n\n\n\nA straight line on a log-log plot indicates a power-law relationship between the variables with the slope of the line being the exponent in the power law.\n\n\nThe term lambda or \\lambda is widely used in size spectrum terminology and it denotes the size spectrum slope. A steeper slope (larger \\lambda value) means that there are relatively fewer large fish compared to small fish. A more shallow slope (smaller \\lambda) indicates a relatively larger number of large fish. Now you know how these slopes are calculated.\nOf course the approach we took above of estimating the exponent in the power law from the binned data is not ideal. If one has access to unbinned data, as we have here, one should always use that unbinned data. So the better way to estimate the slope or exponent from our data would be to ask: “If we view our set of observed fish sizes as a random sample from the population described by the power law, for which exponent would our observations be the most likely”. In other words, we should do a maximum likelihood estimation of the exponent. We’ll skip the mathematical details and just tell you the result that the maximum likelihood estimate for the power-law exponent \\lambda is \\lambda = 1+\\frac{n}{\\sum_{i=1}^n\\log\\frac{w_i}{w_{min}}}, where n is the number of observed fish, w_i is the weight of the ith fish and w_{min} is the weight of the smallest fish. For our data this gives\n\nw_min = min(data$weight)\nlambda <- 1 + nrow(data) / sum(log(data$weight / w_min))\nlambda\n\n[1] 1.709584\n\n\nYou can see that this approach, which gives equal weight to each observation rather than giving equal weight to each bin, gives a lower value for \\lambda, namely \\lambda \\approx 1.71 instead of \\lambda \\approx 2.24. This is quite a big difference. But this is still not the end of the story, because we did not take measurement error into account. We assumed that we sampled perfectly. But in reality, small individuals are much easier to miss than large ones, so our data is almost certainly under-reporting the number of small individuals, which leads to a smaller \\lambda or more shallow size spectra. Also, in many ecosystems large fish have been removed by fishing, so we might also be missing them. This would lead to steeper slopes and larger \\lambda. But this is a separate set of analsyes.\nTo estimate slopes properly we should try to observe the power law over a wider range of sizes, all the way from bacteria to whales. This is what Sheldon et.al. did in 1972 and he observed that \\lambda \\approx 2. More thorough investigations since then have led to values just slightly above 2 on average. TODO: references."
  },
  {
    "objectID": "understand/observed-size-spectra.html#biomass-density",
    "href": "understand/observed-size-spectra.html#biomass-density",
    "title": "Observed size spectra",
    "section": "Biomass density",
    "text": "Biomass density\nAbove we first calculated the number of fish in each weight bin and then divided by the width of each bin to obtain the average number density in each bin. Exactly analogous to that, we can calculate the biomass of all the fish in each weight bin and divide that by the width of each bin to obtain the average biomass density in each bin. Note, that number density and biomass density will give quite different results, because there are lots of fish in small bins but their total biomass may not be very large. So in the code below we will now sum weight and not numbers.\n\nbinned_biomass <- data_with_bins |> \n    group_by(bin) |> \n    summarise(Biomass = sum(weight)) |>\n    mutate(Biomass_dens = Biomass / bin_width[bin]) |>\n    mutate(bin_midpoint = bin_midpoints)\n\n\n\n\n\n\n\nExercise 3\n\n\n\n\n\nMake a plot of the biomass density similarly to how we plotted the number density above, using logarithmic axes and also plotting the straight-line approximation.\n\n\n\nFitting a same linear model to the binned biomass density data now gives\n\n(model <- lm(log(Biomass_dens) ~ log(bin_midpoint), data = binned_biomass))\n\n\nCall:\nlm(formula = log(Biomass_dens) ~ log(bin_midpoint), data = binned_biomass)\n\nCoefficients:\n      (Intercept)  log(bin_midpoint)  \n           14.615             -1.265  \n\n\nThe slope is -1.265 for the biomass density whereas it was -2.24 for the number density. This makes perfect sense, because if we denote the biomass density by B(w) then B(w) = w N(w). Therefore if the number density scales with the exponent \\lambda as N(w) \\propto w^{-\\lambda} then the biomass density will scale as B(w)\\propto w^{1-\\lambda}."
  },
  {
    "objectID": "understand/observed-size-spectra.html#densities-in-log-weight",
    "href": "understand/observed-size-spectra.html#densities-in-log-weight",
    "title": "Observed size spectra",
    "section": "Densities in log weight",
    "text": "Densities in log weight\nSo far we found various size spectrum slopes and evidence of decreasing biomass densities with size. Yet, the tutorial started with a reference to Sheldon’s observation about equal biomass across sizes. Why?\nAbove, we calculated densities by dividing the total number or total biomass in each bin by the width that the bin has on the linear weight (w) axis. Instead, we could divide the total biomass in each bin by the width of the bin on the logarithmic weight axis.\nWe saw earlier that when we plot the logarithmically-sized bins on a logarithmic w axis they are all equally sized. We can calculate the size of the bins in log weight:\n\nlog10_breaks <- log10(binbreaks)\nlog10_bin_width <- diff(log10_breaks)\nlog10_bin_width\n\n [1] 0.30103 0.30103 0.30103 0.30103 0.30103 0.30103 0.30103 0.30103 0.30103\n[10] 0.30103 0.30103\n\n\nWe used the logarithm to base 10 above because that is the convention that mizer uses.\nAn aside: Because, while we wrote this section we got confused ourselves, let us state an obvious fact lest it cause confusion for you as well: the width of a bin on the logarithmic axis is not the logarithm of the width of the bin on the linear axis.\nNow if we divide the number of fish in each bin by the width of the size bin in log weight we get what we denote as the “number density in log weight”. Similarly if we divide the biomass in each bin by the width of the size bin on a logarithmic axis we get the “biomass density in log weight”, which is the Sheldon density.\nBelow we plot the number densities (in black) and the biomass densities (in blue), with the solid lines the densities in weight and the dashed lines the densities in log weight, all on the same axes.\n\n# remember how we calculated densities by dividing numbers and biomasses \n# by bin_widths\nbinned <- data_with_bins |> \n    group_by(bin) |> \n    summarise(Numbers = n(),\n              Biomass = sum(weight)) |>\n    mutate(bin_midpoint = bin_midpoints,\n           Number_dens = Numbers / bin_width[bin],\n           Biomass_dens = Biomass / bin_width[bin])\n\n# and now we add densities in log weight by dividing by log_bin_width\nbinned <- binned |> \n    mutate(Number_dens_log_w = Numbers / log10_bin_width[bin],\n           Biomass_dens_log_w = Biomass / log10_bin_width[bin])\n\nggplot(binned) +\n    geom_line(aes(x = bin_midpoint, y = Number_dens),\n              colour = \"black\") +\n    geom_line(aes(x = bin_midpoint, y = Biomass_dens),\n              colour = \"blue\") +\n    geom_line(aes(x = bin_midpoint, y = Number_dens_log_w),\n              colour = \"black\", linetype = \"dashed\") +\n    geom_line(aes(x = bin_midpoint, y = Biomass_dens_log_w),\n              colour = \"blue\", linetype = \"dashed\") +\n    scale_x_log10(name = \"Weight [g]\") +\n    scale_y_log10(name = \"Density\")\n\n\n\n\nThe blue dashed line shows that Sheldon’s density. You will notice that the slope of the Sheldon density is less negative than the slope of the biomass density.\nWe introduce the notation N_{\\log w}(w) for the number density in log weight and B_{\\log w}(w) for the biomass density in log weight (Sheldon’s density). We have the following relations among the various densities:\nB_{\\log w}(w) = w\\, B(w) \\propto w\\, N_{\\log}(w) = w^2 N(w).\nSheldon’s observation was that B_{\\log w}(w) is approximately constant over a large range of sizes w from bacteria to whales. That corresponds to the earlier phrasing of Sheldon’s observation that N(w)\\propto w^{-\\lambda} with \\lambda close to 2. Here is a very important and interesting summary about the slopes:\nThe slope of the number density is approximately -2, the slope of the biomass density and the number density in log weight is approximately -1, and the slope of the biomass density in log weight is approximately 0, i.e., the biomass density in log weight is approximately constant.\n\n\n\n\n\n\nExpand for technical detail\n\n\n\n\n\nWhen we talk of “log weight”, we have to define what we mean. Weight is a dimensionful quantity. We need to choose a unit before we can take the logarithm. In mizer we choose to measure weight in grams. So when we say “log weight”, we mean the logarithm of the weight measured in grams. The result is a dimensionless quantity.\nWe also need to specify the base of the logarithm. The ggplot package likes to work with log10, mizer also follows that convention, therefore that is what we chose in the above graphs. It does not matter: choosing a different base just rescales the density by an overall factor.\nThe different densities have different units. This is the result of two factors: 1) Biomass is measured in grams whereas Numbers are dimensionless and 2) bin widths are measured in grams whereas bin widths in log weight are dimensionless. The densities, obtained by dividing either Biomass or Numbers by either bin widths or bin widths in log weight, have the following units:\n\n\nN(w) has unit 1/grams,\n\nB(w) and N_{\\log w}(w) are dimensionless,\n\nB_{\\log w}(w) has unit grams.\n\nWe know that one should be careful when plotting quantities with different dimensions on the same axis because the result depends on the units chosen. Above we chose grams as our unit."
  },
  {
    "objectID": "understand/observed-size-spectra.html#size-spectra-of-individual-species",
    "href": "understand/observed-size-spectra.html#size-spectra-of-individual-species",
    "title": "Observed size spectra",
    "section": "Size spectra of individual species",
    "text": "Size spectra of individual species\nSo far we have looked at the community spectrum, where we ignored the species identity of the fish. We will now look at the spectra of the individual species. We’ll plot them all on the same graph and display them with plotly so that you can hover over the resulting graph to see which line corresponds to which species. We also include the community size spectrum in black for comparison. The lines look smoother than earlier because now we use kernel density estimation rather than binning to estimate the densities.\n\np <- ggplot(data) +\n    geom_density(aes(weight, stat(count), colour = species), adjust = 4) +\n    geom_density(aes(weight, stat(count)), colour = \"black\", lwd = 1.2, adjust = 4) +\n    scale_x_continuous(trans = \"log10\", name = \"Weight [g]\") +\n    scale_y_continuous(trans = \"log10\", limits = c(1, NA), name = \"Number density in log w\")\n\nplotly::ggplotly(p)\n\nWarning: Transformation introduced infinite values in continuous y-axis\n\n\n\n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nBinning the data is useful but is not the only way to approximate the densities. In reality you don’t need to bin the data by hand or bin it at all. One can also use the kernel density estimation method and ggplot2 even has that built in to its geom_density().\nBy default, geom_density() would normalise the density so that the integral under the density curve is 1. We use stat(count) to tell it that we want the number density, so that the integral under the curve is the total number, not normalised to 1.\nThe kernel density method works by placing a small Gaussian (bell curve) at each data point and then adding up all these little Gaussians. The adjust = 4 means that the width of these Gaussians is 4 times wider than geom_density() would choose by default. This leads to a smoother density estimate curve. This plays a similar role as the bin width does in histograms.\nNote how easy it was to ask ggplot to draw a separate line for each species. We only had to add the colour = species to geom_density(). ggplot automatically chose some colours for the species and added a legend to the plot.\nWe have replaced scale_x_log10() by scale_x_continuous(trans = \"log10\") which does exactly the same thing. But the latter form is more flexible, which we used in scale_y_continuous(trans = \"log10\", limits = c(1, NA)) to also specify limits for the y axis. We chose to plot densities above 1 only because at smaller values there is only noise. We did not want to set an upper limit, hence the NA.\nWe then did not display the plot p but instead fed it to plotly::ggplotly(). The ggplotly() function takes a plot created with ggplot and converts it into a plot created with plotly. plotly plots are more interactive. We called the ggplotly() function with plotly::ggplotly() because that way we did not need to load the plotly package first, i.e., we did not need to do library(plotly).\n\n\n\nThere are three messages you should take away from this plot:\n\nDifferent species have very different size spectra.\nThe estimates of the species size spectra are not very reliable because we do not have very good data.\nThe community size spectrum looks more regular than the species size spectra.\n\nWe will discuss species size spectra more in the next tutorial, where we will look at them with the help of the mizer model."
  },
  {
    "objectID": "understand/observed-size-spectra.html#summary-and-recap",
    "href": "understand/observed-size-spectra.html#summary-and-recap",
    "title": "Observed size spectra",
    "section": "Summary and recap",
    "text": "Summary and recap\n1) It is very useful to know how many organisms of different sizes there are. This is what size spectra show.\n2) We can represent size spectra in different ways. One is to bin the data and plot histograms. The drawback is that the height of the bars in a histogram depend on our choice of bins. A bin from 1 to 2g will have fewer individuals than a bin from 1 to 10g.\n3) To avoid the dependence on bin sizes, we use densities, where the total number of individuals or the total biomass of individuals in each bin are divided by the width of the bin. We refer to these as the number density or the biomass density respectively.\n3) The number density looks very different from the biomass density. There will be a lot of very small individuals, so the number density at small sizes will be large, but each individual weighs little, so their total biomass will not be large.\n5) When we work with a logarithmic weight axis, then it is natural to use densities in log weight, where the numbers of individuals in each bin are divided by the width of the bin on the log axis. We refer to these as the number density in log weight or the biomass density in log weight respectively.\n6) Community size spectra are approximately power laws. When displayed on log-log axes, they look like straight lines. The slope of the number density is approximately -2, the slope of the biomass density and the number density in log weight is approximately -1, and the slope of the biomass density in log weight is approximately 0, i.e., the biomass density in log weight is approximately constant. The latter is called the Sheldon spectrum.\n7) The individual species size spectra are not approximately power laws and thus do not look like straight lines on log-log axes. The approximate power law only emerges when we add all the species spectra together."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Online mizer course",
    "section": "",
    "text": "2022 August 8-26"
  },
  {
    "objectID": "index.html#size-based-ecosystem-models-with-the-r-package-mizer-and-applications-for-coastal-and-inland-ecosystems",
    "href": "index.html#size-based-ecosystem-models-with-the-r-package-mizer-and-applications-for-coastal-and-inland-ecosystems",
    "title": "Online mizer course",
    "section": "Size based ecosystem models with the R package mizer and applications for coastal and inland ecosystems",
    "text": "Size based ecosystem models with the R package mizer and applications for coastal and inland ecosystems\nIn this online course you will learn about the principles of size based community and ecosystem modelling, implementation of these principles in the R package mizer, learn about adaptation of mizer for shallow ecosystems with multiple resources, and learn how to build a new model with your own or example data and use it to investigate the ecosystem effect of changes in fishing or other stressors.\nThe course is led by Gustav Delius (University of York, UK) and Asta Audzijonyte (Nature Research Centre, Lithuania & University of Tasmania, Australia), with technical support by Romain Forestier (University of Tasmania). Invited speakers include Ken Haste Andersen and Julia Blanchard.\nParticipation is free. If you would like to participate in this course, please register."
  },
  {
    "objectID": "index.html#tutorials-and-worksheets",
    "href": "index.html#tutorials-and-worksheets",
    "title": "Online mizer course",
    "section": "Tutorials and worksheets",
    "text": "Tutorials and worksheets\nThe course has three week-long sections:\n\nWeek 1: Understand\nYou will gain an understanding of size spectra and their dynamics by exploring simple example systems hands-on with mizer.\nWeek 2: Build\nFollowing our example, you will build your own multi-species mizer model for the Curonian sea. We will collect the models from all participants to create an ensemble of models.\nWeek 3: Use\nWe will use this new ensemble of mizer models to explore the effects of changes in fishing and changes in resource dynamics. You will run your own model scenarios.\n\nThe course is organised into several tutorials each week. Each tutorial is associated with a worksheet in which you perform the exercises that are dotted throughout the tutorials. You will work through these tutorials and worksheets at times that are convenient for you."
  },
  {
    "objectID": "index.html#on-line-meetings",
    "href": "index.html#on-line-meetings",
    "title": "Online mizer course",
    "section": "On-line meetings",
    "text": "On-line meetings\nThere will be several optional online meeting scheduled throughout the course, see the list of meetings in the table below. The purpose of the meetings is to add a social dimension to the course. You only have to join when you can. For each day we organise two meetings to accommodate different time zones:\n\n7am UK summer time (BST) most suitable for Asia and Australasia:\nhttps://live.remo.co/e/mizer-course-meetings\n3pm UK summer time (BST) most suitable for Europe and America:\nhttps://live.remo.co/e/mizer-course-meetings-2\n\nPlease follow one of these links now. You will be asked to create yourself an account. Please use the email address that you used for registering for this mizer course. If you need to use another email address, please send an email from that email address to gustav.delius@gmail.com and he will add that email to the list of accepted emails.\nOnce you have logged into Remo, you will be introduced to its main features and then Remo will check whether your browser and operating system is on their list of supported configurations.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nDo not worry if you get the message that your configuration is not supported. It will most likely work anyway.\n\n\n\nWhen you get to the landings page for the meeting, click on “Register for Event”. You will only need to do this once. All future meetings will use the same meeting space.\nOn Monday 8th of August we will have an introductory and welcome meeting with all course participants. On Tuesdays and Thursdays of each week course participants are encouraged to join the meetings with other course participants to discuss their progress, challenges and ideas (course tutors will not attend all these meetings). On Fridays we will have meetings with tutors to recap the experience from that week and discuss remaining questions.\n\n\n\nDate\nTime 1\nTime 2\nNotes\n\n\n\n\nAug 8, Monday\n7.00\n15.00\nIntroductory meeting for all course participants and tutors\n\n\nAug 9, Tuesday\n7.00\n15.00\nCourse participants are encouraged to join and form group discussions\n\n\nAug 11, Thursday\n7.00\n15.00\nCourse participants are encouraged to join and form group discussions\n\n\nAug 12, Friday\n7.00\n15.00\nMeetings with course participants and tutors\n\n\nAug 16, Tuesday\n7.00\n15.00\nCourse participants are encouraged to join and form group discussions\n\n\nAug 18, Thursday\n7.00\n15.00\nCourse participants are encouraged to join and form group discussions\n\n\nAug 19, Friday\n7.00\n15.00\nMeetings with course participants and tutors\n\n\nAug 23, Tuesday\n7.00\n15.00\nCourse participants are encouraged to join and form group discussions\n\n\nAug 25, Thursday\n7.00\n15.00\nCourse participants are encouraged to join and form group discussions\n\n\nAug 26, Friday\n7.00\n15.00\nFinal days of meetings with course participants and tutors on Zoom\n\n\n\n\nThis course is organised as a part of the “Sustainable inland fisheries” project, funded by the European Regional Development Fund (project No 01.2.2-LMT-K-718-02-0006) under grant agreement with the Research Council of Lithuania (LMTLT) and the Pyramids of Life, funded by UK Research and Innovation via the Sustainable Management of Marine Resources fund."
  },
  {
    "objectID": "use/fishing-scenarios.html",
    "href": "use/fishing-scenarios.html",
    "title": "Explore fishing scenarios",
    "section": "",
    "text": "Mizer is a tool that can be used to simulate a dynamic size spectrum in a marine ecosystem, subject to changes through time, such as fishing pressure. It is a dynamic multi-species model with emergent growth, reproduction and biomass, so it allows us to better understand how changes in fishing mortality can affect the entire ecosystem.\nIn the previous week we have been focused on the steady state of the model. Now we are ready to make changes through time, which means that the ecosystem will move away from the tuned steady state.\n\n\n\n\n\n\nFor explorations in this tutorial we will be using our mizer model for the Curonian lagoon. We will load the model from our previous tutorial where we tuned reproduction level of each species.\n\nremotes::install_github(\"sizespectrum/mizerExperimental\", ref = \"tuneMR\")\nlibrary(mizerExperimental)\nremotes::install_github(\"sizespectrum/mizerMR\")\nlibrary(mizerMR)\nlibrary(tidyverse)\n\n# Load tuned model with original selectivity\ncm <- readParams(\"cur_model_resilient.rds\")\n\nMizer allows complicated setups of multiple fishing gears and selectivities, but we will start with a few simple scenarios and give references for further reading to users who want to explore more."
  },
  {
    "objectID": "use/fishing-scenarios.html#scenario-1-change-fishing-effort",
    "href": "use/fishing-scenarios.html#scenario-1-change-fishing-effort",
    "title": "Explore fishing scenarios",
    "section": "Scenario 1: Change fishing effort",
    "text": "Scenario 1: Change fishing effort\nThe first option most users want to explore is to see what happens if we start fishing more or if we reduce fishing mortality. We will use our Curonian model with tuned reproduction and change the total fishing effort. We will run the simulation with the changed effort long enough so that it again settles down to a steady state and then look at how the system evolved over this time period.\nWe remind ourselves of the current fishing effort to which we tuned the model in week 2:\n\ninitial_effort(cm)\n\nMain \n 0.3 \n\n\nWe now simulate the result of doubling the fishing effort to 0.6.\n\nsim_double_effort <- project(cm, effort = 0.6, t_max = 30)\n\nWe have assigned the resulting MizerSim object to the variable sim_double_effort. Our convention is to include sim_ in the variable name when we assign a MizerSim object.\nWe can now analyse the time series contained in that MizerSim object. For example we can look at how the species biomasses changed over time:\n\nplotlyBiomass(sim_double_effort)\n\n\n\n\n\nThe changes in biomass can be seen more clearly if we plot the relative change compared to the initial biomass:\n\nplotlyBiomassRelative(sim_double_effort)\n\n\n\n\n\nWe can see that, surprisingly, after doubling fishing effort on all species, the biomasses of breams, roach, vimba, perch and carassius increased rather than decreased!\nTo understand how that is possible, we have to look at how the spectra have changed. After all mizer is all about changes at size. Looking at overall biomasses does not tell use about size dynamics. We can compare the spectra using the plotSpectra2() function:\n\nplotSpectra2(sim_double_effort, 'double', cm, 'same', power = 2)\n\n\n\n\nAgain, the changes are more visible if we plot relative change with respect to the initial spectra:\n\nplotlySpectraRelative(cm, sim_double_effort)\n\nWarning: `gather_()` was deprecated in tidyr 1.2.0.\nPlease use `gather()` instead.\nThis warning is displayed once every 8 hours.\nCall `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\n\n\n\n\n\n\nFishermen of course very interested in the fisheries yield. The time series of yields over time is:\n\nplotlyYield(sim_double_effort)\n\n\n\n\n\nAnd again we look at the relative change over time. The plotlyYieldRelative() function needs also the original MizerParams object cm to be able to calculate the yield in the original model.\n\nplotlyYieldRelative(sim_double_effort, cm)\n\n\n\n\n\nYields for all but predator_fish species increased when the fishing effort was doubled. The initial increase by 100% is because doubling the fishing mortality will give double the yield until the fish populations are affected by the increased fishing mortality.\nLet’s see what happens if we triple the effort on all species.\n\nsim_tripple_effort <- project(cm, effort = 0.9, t_max = 30)\n\nplotlyYieldRelative(sim_tripple_effort, cm)\n\n\n\n\n\nNow the yield on perch increased 8 times and for roach 12 times! This is both because tripling fishing mortality on all species, doubled perch and roach biomasses, and then by tripling the effort we are catching more of them. Let’s look at the change in the spectra again.\n\nplotlySpectraRelative(cm, sim_tripple_effort)\n\n\n\n\n\nNow the change is even more evident. Large individuals of all species are greatly reduced, but this is compensated by an increase in medium-sized and small individuals for most species."
  },
  {
    "objectID": "use/fishing-scenarios.html#scenario-2-change-fishing-on-one-species-only",
    "href": "use/fishing-scenarios.html#scenario-2-change-fishing-on-one-species-only",
    "title": "Explore fishing scenarios",
    "section": "Scenario 2: Change fishing on one species only",
    "text": "Scenario 2: Change fishing on one species only\nPreviously we saw that when effort changed on all species it was impossible to know what is driving change in total biomasses and yields - fishing or species interactions. Clearly, it was both, since in a single species model we would not get more biomass with increased fishing mortality. But to separate this effect better, let’s now change fishing on one species only. We will do that on pikeperch. Let’s double its fishing mortality and see how that affects the ecosystems. We will do that by doubling the catchability parameter in the gear_params dataframe.\n\n# Make a copy of the model in a new variable\ncm_fishPikeperch <- cm\n# Change the catchability of pikeperch\ngear_params(cm_fishPikeperch)[\"pikeperch, Main\", \"catchability\"] <- 2\n# Here \"Main\" means the main gear, because mizer can have multiple gears\n\nNow let’s project with same overall effort and see what happens.\n\nsim_Pikeperch <- project(cm_fishPikeperch, t_max = 30)\n\nplotlyBiomassRelative(sim_Pikeperch)\n\n\n\n\n\nWe can see that just by changing fishing mortality on one important species, we have triggered a trophic cascade and changed biomasses of all other species. Most other species increased in biomass. Only ruffe and smallfish decreased, since they are now more heavily predated by intermediate sized fish. You can use plotDeath() and plotSpectra2() to explore this further.\nLet us also look at the change in yields:\n\nplotlyYieldRelative(sim_Pikeperch, cm)\n\n\n\n\n\nBy fishing pikeperch more intensively, we decreased the yield of pikeperch, but we increased biomasses and yields on nearly all other species. Now we know that yields of other species really changed due to species interactions, since we are fishing them with same parameters as before.\nWe see that biomasses are still changing after 30 years, so we can run project for a longer time and see how the trajectories continue:\n\nsim_Pikeperch <- project(cm_fishPikeperch, t_max = 100)\nplotlyBiomassRelative(sim_Pikeperch)\n\n\n\n\n\nWe can see that pikeperch and perch took a while to stabilise to a new equilibrium."
  },
  {
    "objectID": "use/fishing-scenarios.html#scenario-3-increase-gear-mesh-size",
    "href": "use/fishing-scenarios.html#scenario-3-increase-gear-mesh-size",
    "title": "Explore fishing scenarios",
    "section": "Scenario 3: Increase gear mesh size",
    "text": "Scenario 3: Increase gear mesh size\nOne common policy in fisheries management is to increase mesh sizes of commercial gears, with the goal of protecting young fish and decreasing overall impact on the stock. Let’s see how this can work in a multi-species ecosystem. Our fisheries managers are concerned about predator_fish and increased minimum size limit for this species. This we can achieve by changing it’s gear selectivity and projecting with the same effort. Currently the selectivity parameters for predator_fish are\n\ngear_params(cm)[\"predator_fish, Main\", c(\"l50\", \"l25\")]\n\n\n\n  \n\n\n\nWe will increase L50 for this species from 30 to 40 and keep the slope of size selectivity same (3 cm difference between L50 and L25).\n\n# Make a new params object \ncm_sel <- cm\n# change selectivity parameters\ngear_params(cm_sel)[\"predator_fish, Main\", \"l50\"] <- 40\ngear_params(cm_sel)[\"predator_fish, Main\", \"l25\"] <- 37\n\nWe will project with unchanged fishing effort\n\nsim_largerMesh <- project(cm_sel, t_max = 30)\n\nWe again plot the relative change in biomass and in yield\n\nplotlyBiomassRelative(sim_largerMesh)\n\n\n\n\nplotlyYieldRelative(sim_largerMesh, cm)\n\n\n\n\n\nIndeed, increasing the mesh size helped the predator_fish. We can see that by changing gear selectivity but keeping the same effort, we increased predator_fish biomasses and yields. Yield is lower for predator_fish only in the first few years. Both managers and fishers are happy. Effect on other species yield is negligible.\nYou can now also play with changing size selectivities in your model and see which species react strongly, and which don’t. How does it affect other species in the ecosystem?"
  },
  {
    "objectID": "use/fishing-scenarios.html#scenario-4-protecting-large-fish",
    "href": "use/fishing-scenarios.html#scenario-4-protecting-large-fish",
    "title": "Explore fishing scenarios",
    "section": "Scenario 4: Protecting large fish",
    "text": "Scenario 4: Protecting large fish\nAnother management option that we often hear about is protecting largest fish from fishing. We can implement it in our model by changing selectivity curves from logistic to double_sigmoid (also sometimes called dome-shaped). This will reduce selectivity on largest individuals and will only select intermediate sized fish (if we set selectivity parameters properly). We will do that for all species, but this could also be set for only one species.\n\n# Create new gear parameter dataframe\ngear_double_sigmoid <- gear_params(cm)\n\n# Change all selectivity curves to double sigmoid (changing trawling to gillneting)\ngear_double_sigmoid$sel_func <- \"double_sigmoid_length\"\n\n# Set the right side of selectivity - i.e. the midpoint of the decreasing selectivity part of the curve, to 1.5 of the size at the left side\ngear_double_sigmoid$l50_right <- gear_double_sigmoid$l50 * 1.5\n# and the slope at 2cm difference\ngear_double_sigmoid$l25_right <- gear_double_sigmoid$l50_right + 2\n\n# Create new params object\ncm_gillnet <- cm\n# and set the new gear parameters\ngear_params(cm_gillnet) <- gear_double_sigmoid\n\n#check how the selectivity curves look \nplotlyFMort(cm_gillnet)\n\n\n\n\n\nWe notice how pikeperch selectivity curve is very shallow on the left side. This selection comes from tuneParams() stage, when we were trying to fit observed catch size distributions and overall catches. If we have better data on selectivity, we should use empirical data. But this is just a theoretical example.\nNow we will project with unchanged fishing effort and plot the resulting biomass over time.\n\nsim_gillnet <- project(cm_gillnet, t_max = 30)\n\nplotlyBiomass(sim_gillnet)\n\n\n\n\n\nWe can see that pikeperch does not cope. Even when we protect large pikeperch, its biomass goes down. This is because predator_fish benefited so greatly from this new selectivity and increased a lot and this had a knock down effect on other species.\nThe picture looks quite different for the yield.\n\nplotlyYieldRelative(sim_gillnet, cm)\n\n\n\n\n\nEven though predator_fish biomass increased so much, the yield on predator_fish decreased a lot. This is because we are not catching all the large fish that constitute most biomass.\nFishers would probably try to increase the fishing effort to try and get the same amount of yield. Let’s increase fishing mortality of predator fish and aim to get similar yield. We will need to increase catchability quite a lot to increase yield substantially. Let’s increase it 5 fold from 2 to 10.\n\ngear_params(cm_gillnet)[\"predator_fish, Main\", \"catchability\"] <- 10\n\nNow we run the simulations for 30 years and see if we could increase the yield to what we had previously with logistic selectivity and lower catchability\n\nsim_gillnet <- project(cm_gillnet, t_max = 30)\nplotlyYieldRelative(sim_gillnet, cm)\n\n\n\n\n\nEven after increasing catchability in the selected range 5 times we still only get 10% of the original yield for predator_fish. As a result predator_fish biomass increases and pikeperch biomass decreases, although less drastically:\n\nplotlyBiomassRelative(sim_gillnet)\n\n\n\n\n\nWe definitely want to look at changes in size spectra with this size based fishing example\n\nplotlySpectraRelative(cm, sim_gillnet)\n\n\n\n\n\nPay attention to how abundance of predator_fish in gillnet selectivity case at selected sizes drops sharply but then greatly increases once they are above the selected limit.\n\n\n\n\nExercise\nThere are obviously many fishing scenarios you may want to try out for yourself. This exercise should only get you started with something simple:\nIf you reduce the effort in our model from 0.3 to 0.1, this will of course immediately reduce the yield of all species. How many years does it take in this model before the yield of predator_fish has increased above the yield achieved with an effort of 0.3?"
  },
  {
    "objectID": "use/fishing-scenarios.html#summary",
    "href": "use/fishing-scenarios.html#summary",
    "title": "Explore fishing scenarios",
    "section": "Summary",
    "text": "Summary\n\nMizer has lots of options to explore changes in gears, effort and fishing dynamics. In this tutorial we only explored basic options and found that even with very basic changes, the response of the ecosystem can be surprising and hard to fully understand.\nChanges in fishing on one species can have large effects on the biomasses and yields of other species.\nTo understand the trophic cascades that are triggered by changes in fishing one needs to look at the changes in the size spectra, not only at total biomasses.\nEcosystem responses to fishing scenarios will depend on how we set up species resilience to fishing. It is therefore important to interpret results carefully and explore alternative parameter combinations of reproductive level."
  },
  {
    "objectID": "use/index.html",
    "href": "use/index.html",
    "title": "Week 3: Use mizer models",
    "section": "",
    "text": "Lecture\nThis week’s contributor is Julia Blanchard. Her lecture provides a broad overview of the different ways in which mizer is being used to help understand the consequences of change in aquatic ecosystems. There are a lot of ways! The material describes how you can set model simulations to study change, some of which are explored in this week’s tutorials.\n\n\n\n\n\n\n\n\n\nTutorials\nUsing examples, the tutorials are designed to help you develop your own model simulation experiments:\n\nTune the resilience to fishing First, we will explore how sensitive your model is to the effects of fishing. We will show how the reproduction parameters influence the resilience of the species. We make adjustments to the reproduction levels to produce realistic responses to fishing intensity.\nSimulate fishing scenarios\nOnce the resilience to fishing is tuned, we can assess how the model responds to changes in fishing through time. This step involves looking closer at the fishing parameters in mizer and setting up different fishing scenarios.\nChange resources\nNext we will look at the resource spectrum and how changes in three main resource parameters can affect our ecosystem. With three main parameters for each resource, this can quickly get complicated. We will also show an example of how to use external data on resource time series to force the mizer model.\nExplore further scenarios\nThis tutorial provides extra material, prepared by Julia Blanchard using another system (Patagonian toothfish fishery) as an example. Here you can learn on how to set time series of fishing changes and more.\n\nTo get your worksheet repository for this week, follow this link: https://classroom.github.com/a/_sExBJYv"
  },
  {
    "objectID": "use/tune-resilience.html",
    "href": "use/tune-resilience.html",
    "title": "Tune resilience",
    "section": "",
    "text": "In the previous week we tuned our model parameters so that the steady state of the model agrees with observed growth rates, average observed biomasses and with observed catches. We did not yet tune how sensitively our model reacts to changes away from its steady state. In particular, we did not tune how resilient the species are to fishing. We will do that in this tutorial.\nAs usual, we load the necessary packages\n\nremotes::install_github(\"sizespectrum/mizerExperimental\", ref = \"tuneMR\")\nremotes::install_github(\"sizespectrum/mizerMR\")\nlibrary(mizerExperimental)\nlibrary(mizerMR)\nlibrary(tidyverse)\n\nWe load our Curonian lagoon model that we saved after refining the model in the previous tutorial using the tuneParams() gadget.\n\ncm <- readParams(\"../build/cur_model_refined.rds\")"
  },
  {
    "objectID": "use/tune-resilience.html#reproduction-dynamics",
    "href": "use/tune-resilience.html#reproduction-dynamics",
    "title": "Tune resilience",
    "section": "Reproduction dynamics",
    "text": "Reproduction dynamics\nIn this tutorial we are going to look at an aspect of the model that has a big impact on the resilience of species to perturbations: the reproduction dynamics. In the tutorial on dynamics of size spectra in week 1 we briefly looked at how density dependence of reproduction can influence how species react to changes in mortality, such as from fishing. It might be good if you go back to that tutorial and remind yourself.\nWhen we built our models in week 2 we were not concerned about the parameters that specify the reproduction dynamics. We were only concerned with setting the resulting reproduction rate for each species to the levels that produced the observed species biomass. But because the parameters for the reproduction dynamics will affect how resilient species are, we will choose appropriate values for them in this tutorial.\n\n\n\n\n\n\nStock-recruitment relationships\n\n\n\nIn usual fisheries models, the reproduction dynamics is captured in the stock-recruitment relationship which relates the number of new recruits to the spawning stock biomass. Recruits are the fish that survive up to a size where they enter the fishery, which is the size at which the fisheries model starts modelling them.\nMizer is different in that it tracks individuals from the size at which they hatch (egg size) all the way to adult sizes. So much of the density dependence that is usually encoded in stock-recruitment relationships is modelled explicitly in mizer through the growth and mortality that larvae and juveniles experience until they reach recruitment size. So in mizer we specify the reproduction rate (the rate at which individuals enter the smallest size class) instead of the recruitment rate.\nThere are many density-dependent effects that mizer does not capture explicitly, like for example limits on the available spawning grounds. This additional density dependence is encoded in a non-linear relationship between the energy that a species invests into reproduction and the rate at which new individuals enter the smallest size class in the model, as we will now discuss.\n\n\nThere are several parameters and quantities that were introduced in that earlier tutorial that we would like to recall now:\n\nThe rate E_R at which a species invests energy into reproduction. We discussed how this depends on the species parameters in a section of the tutorial on single species spectra in the first week of the course. In standard fisheries models the energy invested is assumed to be proportional to the spawning stock biomass. In mizer the energy invested also depends on how much food is available for the spawning stock. But nevertheless you won’t go wrong too much if in your head you identify E_R as spawning stock biomass.\nThe parameter erepro describes the efficiency with which the energy that a species invests into reproduction is converted to eggs. Multiplying E_R by erepro and by the conversion factor from biomass to number of eggs gives the quantity that we called R_{di}: the rate of egg production. We also sometimes refer to R_{di} as the “density-independent reproduction rate”. The efficiency erepro can be quite small because a lot of the energy expended on reproduction goes not into the production of eggs but in associated processes, like for example migration to the spawning grounds.\nThe rate R_{dd} at which new individuals can enter the smallest size class in the model (usually this represents the hatching of eggs). This depends in a non-linear way on the rate R_{di} of egg production and therefore also non-linearly on the rate at E_R at which the species invests energy into reproduction. We therefore sometimes refer to this as the “density-dependent reproduction rate”.\nThe parameter R_max that gives the maximum rate at which individuals can join the smallest size class, no matter how much energy the species invests.\n\nThese concepts are nicely illustrated by the following figure that you saw earlier:\n\n\n\n\n\nThe black dot in the diagram is meant to represent the steady-state values for E_R and R_{dd}. The solid curves represents how the density-dependent reproduction rate R_{dd} depends on the rate E_R. Both the solid blue line and the solid black line go through the black dot, which means that they result in the same steady-state reproduction. They differ by the choice of the maximum reproduction rate R_max (the height of the dotted line) and the reproductive efficiency erepro (the slope of the dashed line representing R_{di}).\nWe can see in the diagram how, as E_R is changed, for example through a depletion of spawning stock biomass due to fishing, the resulting change in the reproduction rate R_{dd} is more pronounced along the solid black curve than along the blue curve. This is why an increase in R_{max} will make the species less resilient to fishing.\nNote how both R_max and erepro need to be changed at the same time in order for the resulting curve for the reproduction rate to still go through the black dot, i.e., in order not to change the reproduction rate in the steady state. As we discussed earlier, the function setBevertonHolt() automatically changes both parameters together in the correct manner. In that function we can specify the desired reproduction curve by specifying either R_max or erepro or the ratio between R_{dd} at steady state and R_{max}, which we refer to as the reproduction level.\nWe like to work with the reproduction level because it is a number between 0 and 1, where 0 means that the rate of reproduction increases in proportion to E_R and 1 means that the rate of reproduction is independent of E_R. The higher the value of the reproduction level the less impact a change in E_R will have on the species’ reproduction. Thus higher levels of the reproduction level make the species more resilient for example to fishing.\nAs usual, we load the necessary packages\n\nremotes::install_github(\"sizespectrum/mizerExperimental\", ref = \"tuneMR\")\nremotes::install_github(\"sizespectrum/mizerMR\")\nlibrary(mizerExperimental)\nlibrary(mizerMR)\nlibrary(tidyverse)\n\nWe load our Curonian lagoon model that we saved after refining the model in the previous tutorial using the tuneParams() gadget.\n\ncm <- readParams(\"../build/cur_model_refined.rds\")"
  },
  {
    "objectID": "use/tune-resilience.html#how-resilient-should-species-be",
    "href": "use/tune-resilience.html#how-resilient-should-species-be",
    "title": "Tune resilience",
    "section": "How resilient should species be?",
    "text": "How resilient should species be?\nWe will need to tune the reproduction level of each species to make sure that their response to fishing is reasonable. How do we know what is reasonable? It is not a straightforward question. We can start by consulting general fisheries models. You can read about the principles of basic fisheries surplus production models in this excellent book by Malcolm Haddon “Using R for Modelling and Quantitative Methods in Fisheries”.\nIn the simplest of these models, the population dynamics are specified in terms of a maximum population growth rate r (not to be confused with the maximum hatching rate R_max used in mizer) and a carrying capacity, which represents the unfished biomass level. Under these simplest standard assumptions about density dependence, maximum sustainable yield (MSY) is obtained when the stock is at 50% of the unfished biomass level. MSY is approximately r/4 \\cdot unfished biomass and the fishing mortality which gives this MSY is r/2. This fishing mortality is referred to as F_{MSY}. This means that if for example r = 0.5 then the peak of the yield curve should be at about F_{MSY} = 0.25. If unfished biomass is 1000 tons, MSY will be at 125 tons.\nWe usually do not know population growth rates r for our species, but we can look up estimates in the FishBase life-history tool section. Or we can use generic estimates which suggest r of 0.6-1.5 for high resilience species (Von Bertalanffy growth rate K>0.3, maturation age < 1, high fecundity) and r of 0.2-1 for medium resilience species. We reproduce the table from this reference here:\n\nWe had included the categorisation of our species in the species parameter dataframe in the resilience column.\n\nspecies_params(cm) |> select(resilience, funcgr)\n\n\n\n  \n\n\n\nThus according to the above discussion, we should expect an F_{MSY} between 0.3 and 0.75 for smallfish, between 0.1 and 0.5 for our benthivores and between 0.025 and 0.25 for the ominvores and predators. These values are derived from single species models with very different assumptions to those of ours, so they can only be used as very general guides.\nAlternatively, we can use Ken Andersen’s book and expectations for species with different asymptotic sizes, as estimated from trait-based models (where all species parameters are determined in terms of the asymptotic size) and when all species are fished with 50% selectivity at 5% of their asymptotic size. The panels below represents species with different asymptotic sizes: 333 g (top), 10 g (bottom left), and 10 kg (bottom right). The lines show yield (solid black lines), yield per recruit (dashed lines), spawning stock biomass (dark gray lines), and recruitment (light gray lines), all scaled by their maximum value. We will not deal with yield per recruit, so ignore the dashed lines. This figure shows that highest yields are expected at fishing mortality of about 0.3-0.5/year.\n\nIn this tutorial we will tune our model so that they give the maximum sustainable yield at the fishing mortalities that are in the range suggested by the table above, i.e. so that F_{MSY} = r/2 with r in the range given in the last row of that table. We are not saying that this is the only or best method."
  },
  {
    "objectID": "use/tune-resilience.html#constant-reproductive-efficiency",
    "href": "use/tune-resilience.html#constant-reproductive-efficiency",
    "title": "Tune resilience",
    "section": "Constant reproductive efficiency",
    "text": "Constant reproductive efficiency\nThe reproduction parameters in our model are not yet chosen sensibly, as we can see by looking at the current reproduction levels:\n\ngetReproductionLevel(cm)\n\n    smallfish         ruffe        breams         roach         vimba \n   0.32264652    0.02129403    0.00000000    0.52334987    0.00000000 \n    carassius         perch     pikeperch        burbot predator_fish \n   0.07675473    0.22022985    0.65493089    0.30352817    0.10223259 \n\n\nFor some species these reproduction levels are extremely low.\nWe need to decide what reproduction parameters we should set to start our tuning. We will follow the approach of Jacobsen et al. 2016 and initially set the reproductive efficiency erepro to the same value for all species.\nWe use the setBevertonHolt() function to set the values for erepro. That function automatically also adjusts the values for R_max to keep the steady state reproduction rate R_{dd} the same, as we discussed above.\nIf we try to set the value for erepro very low, the setBevertonHolt() function will issue a warning:\n\ncm <- setBevertonHolt(cm, erepro = 0.0001)\n\nWarning in setBevertonHolt(cm, erepro = 1e-04): For the following species\n`erepro` has been increased to the smallest possible value: erepro[ruffe] =\n0.000321; erepro[roach] = 0.000736; erepro[carassius] = 0.000311; erepro[perch]\n= 0.000177\n\n\nBecause we want all species to have the same value, we choose a value that is larger than those required. So we choose erepro = 0.001.\n\ncm <- setBevertonHolt(cm, erepro = 0.001)\nspecies_params(cm) |> select(erepro, R_max)\n\n\n\n  \n\n\n\nLet’s see what reproduction levels this gives:\n\ngetReproductionLevel(cm)\n\n    smallfish         ruffe        breams         roach         vimba \n    0.9460163     0.6794001     0.9040744     0.2642426     0.9185775 \n    carassius         perch     pikeperch        burbot predator_fish \n    0.6891149     0.8232825     0.9905353     0.9881604     0.9962368 \n\n\nRemember: the reproduction level is the ratio between RDD and R_max and can vary between 0 and 1. It tells us how close the actual reproduction (after applying density dependence) is to the theoretical maximum, set by R_max. So instead of using the getReproductionLevel() function we could also have done the calculation ourselves:\n\ngetRDD(cm) / species_params(cm)$R_max\n\n    smallfish         ruffe        breams         roach         vimba \n    0.9460163     0.6794001     0.9040744     0.2642426     0.9185775 \n    carassius         perch     pikeperch        burbot predator_fish \n    0.6891149     0.8232825     0.9905353     0.9881604     0.9962368 \n\n\nWe can also look how close the density dependent reproduction rate RDD is to the density independent reproduction rate RDI, which is the rate at which eggs are produced.\n\ngetRDI(cm) / getRDD(cm)\n\n    smallfish         ruffe        breams         roach         vimba \n    18.524101      3.119152     10.424749      1.359144     12.281619 \n    carassius         perch     pikeperch        burbot predator_fish \n     3.216623      5.658749    105.655800     84.462397    265.728307 \n\n\nThis tells us that many species can produce large amounts of eggs, but the actual reproduction is strongly capped by the R_max parameter."
  },
  {
    "objectID": "use/tune-resilience.html#tuning-resilience-to-fishing",
    "href": "use/tune-resilience.html#tuning-resilience-to-fishing",
    "title": "Tune resilience",
    "section": "Tuning resilience to fishing",
    "text": "Tuning resilience to fishing\nWe now want to adjust the reproduction levels so that the resilience of the species in our model matches expectations.\nSetting generic gear selectivity\nIf you have system specific data on how changes in fishing under system specific gear parameters change species biomasses, you should use these system specific details. We do not have such data for Curonian Lagoon, so we will explore species responses in general. For that purpose, for this exploration of the resilience of species, we set the gear parameters in such a way that all species are fished similarly.\nOur current gear parameters are set for a specific commercial fishery, which selects some species but does not catch smallfish and almost no ruffe. For smaller fish they target only adults and for largest fish they also target juveniles. Thus the fishing mortality this gear imposes on the different species is not suited to assess resilience equally for all species.\nTo tune the resilience of each species to extra mortality we will set catchability of all species to 1, so that effort values directly reflect fishing mortality. We will also set gear 50% selectivity to half the maturation length of each species and 25% selection to half the 25% maturation length.\nGear selectivity parameters are defined by length, so we will first convert w_mat and w_mat25 to length values.\n\nweight_to_length <- function(w, params) {\n    a <- species_params(params)$a\n    b <- species_params(params)$b\n    (w / a) ^ (1 / b)\n}\n\nl_mat = weight_to_length(species_params(cm)$w_mat, cm)\nl_25mat = weight_to_length(species_params(cm)$w_mat25, cm)\n\nWe now create a new gear parameter data frame with changed selectivity parameters:\n\n# We start with the current gear parameters\ngp <- gear_params(cm)\n# and update values in l50 and l25 columns\ngp$l50 <- l_mat / 2\ngp$l25 <- l_25mat / 2\n# and set all catchability to 1\ngp$catchability <- 1\n\nWe assign the model that uses these new gear parameters in a new variable cm_generic_gear so that we can keep the old model around.\n\ncm_generic_gear <- cm\n# Set new gear parameters for the new model \ngear_params(cm_generic_gear) <- gp\n\nLet’s look at the fishing mortality from the new gear:\n\nplotFMort(cm_generic_gear)\n\n\n\n\nAs always after having changed model parameters, we need to bring the model to steady state again.\n\ncm_generic_gear <- steady(cm_generic_gear)\n\nConvergence was achieved in 16.5 years.\n\n\nExploring yield curves\nTo measure the resilience of our species to fishing, we will change the fishing mortality for one species at a time and check how their yields, spawning-stock biomasses (SSB) and reproduction rate (RDD) change in response. We keep the fishing mortality for the other species fixed. For our selected species we run through a range of fishing mortalities between 0 and a maximum. For each fishing mortality we run the projection until the system has settled down to a new steady state. Then we calculates the yield, the spawning stock biomass SSB and the reproduction rate RDD in that steady state. After doing that for all fishing mortalities we can plot all the results in a graph. The plotYieldCurve() function does all that for us. Here we plot the yield curve for smallfish.\n\nplotYieldCurve(cm_generic_gear, species = \"smallfish\", F_max = 2)\n\n\n\n\nWe refer to the yield achieved in the steady state as the sustainable yield (SY) because because it can be sustained indefinitely. The sustainable yield for this species has a maximum (MSY) at a fishing mortality of about 0.8. We refer to this value as F_{MSY}. The small fish have a high resilience to fishing. This is close enough to expectations, so we judge that it is not necessar to make changes to the resource level of “smallfish”.\nNext we look at ruffe. This is classified as a medium resilience species, so we would like the F_{MSY} to be between 0.1 and 0.5.\n\nplotYieldCurve(cm_generic_gear, species = \"ruffe\", F_max = 1)\n\n\n\n\nWe see that the F_{MSY} is at about 0.4, so again we have no reason to change the reproduction level. We encourage you to investigate the yield curves of the other medium resilience species in a similar way.\n\n\n\n\n\n\nNote\n\n\n\nIf you run the above code yourself in your worksheet, you will notice that for some fishing mortalities, plotYieldCurve() gives a warning that convergence was not reached within the 99 years for which we ran the projection. This means that we stopped the simulation before the species had completely settled into a new stable state for that fishing level and thus the result for this specific fishing level is only approximate. But approximate values are good enough for our purpose. Often we find that it is the more extreme values of F where we do not get convergence.\n\n\nWe jump to the first low resilience species in our model: perch. As a low resilience species it should have an F_{MSY} below 0.25.\n\nplotYieldCurve(cm_generic_gear, species = \"perch\", F_max = 1)\n\n\n\n\nThe graph shows that the F_{MSY} is closer to 0.7. So we have reason to reduce the reproduction level for perch to make it less resilient. Its current reproduction level is\n\ngetReproductionLevel(cm_generic_gear)[\"perch\"]\n\n    perch \n0.8232825 \n\n\nWe do not know how much we need to reduce the reproduction level to get a sufficiently low F_{MSY}. We just try some values. Let’s try 0.3.\n\n# First we save current reproduction level into a vector \nrep_level <- getReproductionLevel(cm_generic_gear)\n# then we replace our species' reproduction level with a new value \nrep_level[\"perch\"] <- 0.3\n# and asign it back to the model \ncm_generic_gear <- setBevertonHolt(cm_generic_gear, \n                                   reproduction_level = rep_level)\n\n# and plot F curves again\nplotYieldCurve(cm_generic_gear, species = \"perch\", F_max = 1)\n\n\n\n\nWith that reproduction level of 0.3 for perch, its F_{MSY} is just below 0.5. So still too high for a low resilience species. But before we try to reduce the reproduction level further, let’s move on to the next species, pikeperch.\n\nplotYieldCurve(cm_generic_gear, species = \"pikeperch\", F_max = 1)\n\n\n\n\nIts F_{MSY} is also too high. So we also reduce the reproduction level of pikeperch.\n\nrep_level[\"pikeperch\"] <- 0.3\ncm_generic_gear <- setBevertonHolt(cm_generic_gear, \n                                   reproduction_level = rep_level)\nplotYieldCurve(cm_generic_gear, species = \"pikeperch\", F_max = 1)\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, :\npikeperch are going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, :\npikeperch are going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, :\npikeperch are going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, :\npikeperch are going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, :\npikeperch are going extinct.\n\n\n\n\n\nThe new F_{MSY} is at the upper end of what we would expect for a low-resilience species, but we judge this to be o.k.\n\n\n\n\n\n\nNote\n\n\n\nNotice that for high values of the fishing mortality plotYieldCurve() issues a warning to let us know that pikeperch will go extinct under this fishing mortality. That is fine.\n\n\nSo let’s return to perch. We previously saw that even with its reduced reproduction level it was still too resilient. Let’s look at its yield curve again:\n\nplotYieldCurve(cm_generic_gear, species = \"perch\", F_max = 1)\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : perch\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : perch\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : perch\nare going extinct.\n\nWarning in projectToSteady(params, t_max = t_max, progress_bar = FALSE, : perch\nare going extinct.\n\n\n\n\n\nAre you surprised? Compare this yield curve for perch with the one we plotted above. The F_{MSY} has dropped from close to 0.5 to closer to 0.15 even though we have not changed the reproduction level of perch. The reduction in the resilience of perch has been caused solely by the reduction in resilience of pikeperch.\n\n\n\n\n\n\nImportant\n\n\n\nWe have discovered above that the resilience of a species is influenced by the resilience of the other species. So resilience is a true multi-species effect.\n\n\nWe decide to increase the reproduction level for perch a bit again to make it slightly more resilient.\n\nrep_level[\"perch\"] <- 0.4\ncm_generic_gear <- setBevertonHolt(cm_generic_gear, reproduction_level = rep_level)\n\nBut we don’t have hard data on the resilience of our species, so these are judgement calls and we will be interested to see what choices you will make.\nYou are encouraged to go through all the species and check that their resilience looks o.k.\nSet new reproduction levels\nAbove we studied the resilience of species to changes in their mortality imposed by an artificial fishing gear. We used guidance from a classification of species into resilience classes and the expected F_{MSY} derived from very simple single-species models to adjust the reproduction levels for our species. Now we will use those reproduction levels in our model with the original gear parameters.\n\ncm <- setBevertonHolt(cm, reproduction_level = rep_level)\n\nLet’s plot the yield curve for one of the species that is caught commercially: breams. On the left we show the yield curve for the commercial yield, on the right the yield curve for our generic gear that we used for tuning the reproduction level.\n\n# Yield curve with the commercial gear\nplotYieldCurve(cm, species = \"breams\", F_max = 1)\n# Yield curve with generic gear\nplotYieldCurve(cm_generic_gear, species = \"breams\", F_max = 1)\n\n\n\n\n\nCommercial\n\n\n\n\n\n\nGeneric\n\n\n\n\n\n\nWhy the difference? Let’s look how the original gear parameters differ from our generic set\n\nc(l_mat = l_mat[3], \n  l50_commercial = gear_params(cm)$l50[3],\n  l50_generic = gear_params(cm_generic_gear)$l50[3])\n\n         l_mat l50_commercial    l50_generic \n      21.98905       35.70000       10.99453 \n\n\nWe can see that with the commercial gear parameters, selectivity starts much later, so we are only catching the largest individuals. Therefore the species can sustain a much higher fishing mortality for those selected individuals, because the population can sustain itself even if these large individuals are fished away.\nYou are encouraged to look at the yield curves for other species when using the commercial gear.\nFinally we save our model with tuned resilience to disk for use in the next tutorial.\n\nsaveParams(cm, \"cur_model_resilient.rds\")\n\nExercise 1\nLook at the yield curves in the model we just saved (in the worksheet for this tutorial you can either reproduce the tuning steps above or you can take the shortcut and load our saved model). What approximately is the value of F_{MSY} for pikeperch?\nExercise 2\nNow tune the reproduction levels for your version of the Curonian lagoon model that you built last week. Don’t be surprised if things work out very differently for your model."
  },
  {
    "objectID": "use/tune-resilience.html#summary",
    "href": "use/tune-resilience.html#summary",
    "title": "Tune resilience",
    "section": "Summary",
    "text": "Summary\n\nIdentifying an appropriate reproduction level for our model species is very important, because the reproduction level will determine a species’ resilience to fishing.\nTo judge whether a reproduction level is appropriate, we estimate the fishing mortality that will give maximum sustainable yield (F_{MSY}). We use general fisheries and size ecology theory to get expected F_{MSY} values for species with different life history parameters. Naturally, these are just approximate estimates, but they might be good enough for our purposes. Nevertheless, it is important to explore how our study conclusions might be affected by changes in species reproduction level.\nWhen we explore F_{MSY} for a species it is important to think about the gear selectivity that is used to impose fishing. If selectivity is such that small and large individuals are captured, resulting F_{MSY} will be lower.\nSpecies resilience to fishing is a true multi-species phenomenon. If we change the reproduction level of one species it can affect the resilience of other species. So when we have chosen a set of reproduction levels, we need to run again through all species to check that their resilience is as expected."
  },
  {
    "objectID": "use/change-resources.html",
    "href": "use/change-resources.html",
    "title": "Change resources",
    "section": "",
    "text": "Mizer can be used to explore the consequences of climate change on aquatic ecosystems and fisheries. One of the major effects that climate change is having on aquatic ecosystems is a change in plankton and benthos abundance and size structure. However, responses in resources are highly uncertain and variable and predictions are difficult. For plankton we can use satellite observations of chlorophyll A and earth system models to assess past changes and aim to predict the future. Benthos changes also are likely having large impacts on shallow water ecosystems, but in many cases we have almost no empirical data on how much change is happening. Nevertheless we might want to explore the potential effect of these changes on the rest of aquatic food webs and on our fisheries. This is what we are going to do in this tutorial.\nAs usual we install and load libraries and also load the parameter file from the first tutorial, where we tuned the reproduction parameters.\n\nremotes::install_github(\"sizespectrum/mizerExperimental\", ref = \"tuneMR\")\nlibrary(mizerExperimental)\nremotes::install_github(\"sizespectrum/mizerMR\")\nlibrary(mizerMR)\nlibrary(tidyverse)\n\n# Load tuned model with original selectivity\ncm <- readParams(\"cur_model_resilient.rds\")"
  },
  {
    "objectID": "use/change-resources.html#resource-dynamics",
    "href": "use/change-resources.html#resource-dynamics",
    "title": "Change resources",
    "section": "Resource dynamics",
    "text": "Resource dynamics\nLet’s look at the resource parameters once again\n\nresource_params(cm)\n\n\n\n  \n\n\n\nWe see four main resource parameters that we already met in the tutorial on multiple resources: we already know kappa, which defines the overall abundance of the resource, and lambda, which is the slope of the resource spectrum. We also know w_min and w_max, which set minimum and maximum resource sizes.\n\n\n\n\n\n\nBreaking change\n\n\n\nFor people who have already been using mizer to build or tune models in the past we need to draw attention to a change in the meaning of these resource parameters.\nIn the past, the parameters were used to set the resource carrying capacity, i.e., the hypothetical resource abundance that would be realised if there was no consumption by fish. In the new version, the parameters are used to set the actual observed resource abundance, in the presence of consumption by fish.\nIn the old version of steady(), the resource abundance would change during the tuning of the model. This made tuning of the model more difficult, especially if one wanted to reproduce observed resource abundances. The new version of the steady() that we used while tuning the model is keeping the resource abundance fixed and then adjusts the resource carrying capacity. So now the hypothetical carrying capacity is the emergent quantity and the observed abundance is specified by the resource parameters.\nSheldon’s spectra in natural ecosystems reflect abundances in natural systems and not a hypothetical carrying capacity that would emerge if there was no feeding on the resource. It makes sense to use the resource parameters to specify an observable quantity rather than a hypothetical one.\nThis is not really a breaking change, because all existing mizer models will continue to work in the same way as in the past. The change only affects the tuning of a model with the steady() function.\n\n\nWe will now explain the parameters r_pp and n.\nNote that the resource dynamics are very different from the size-spectrum dynamics for fish because there is no growth between sizes classes. There is only birth and death, independently in each size class. The abundance in a size class is the result of the balance between the birth and death rates in that size class. So we can understand the dynamics for each size class separately. We just have to understand how the birth and death rates are determined.\nSemi-chemostat resource dynamics means that the total birth rate decreases as the resource number density N_R(w) gets closer to its carrying capacity c_R(w), in such a way that the total birth rate at size w is given as (c_R(w) - N_R(w))r_R(w). We refer to r_R(w) as the intrinsic replenishment rate or just the resource rate. Stated the other way around: as the resource abundance drops, its birth rate increases. This is essential for the resilience of the system to perturbations as we will explain below.\nThe parameters r_pp and n are used to set the intrinsic replenishment rate r_R(w) of the resource to an allometric power law\nr_R(w) = r_{pp}w^{n-1}.\nThe default choice for the exponent n is 3/4, so that the replenishment rate decreases with size. Smaller resource size classes can replenish faster than larger size classes.\nThe resource is consumed by fish in proportion to its abundance. So the total death rate at size w is \\mu_R(w)N_R(w) where \\mu_R(w) is the per-capita mortality rate. This mortality rate on resource is determined by predation by fish in the same way as the mortality rate on other fish. So a higher abundance of fish leads to a higher mortality of resource.\nIn the steady state, the birth and death rates are in perfect balance. But if the fish abundance increases and thus the resource mortality rate increases, the resource abundance goes down. However, because the resource birth rate increases as the resource abundance goes down, a new steady state is soon established. The semi-chemostat dynamics are stable.\nBy definition, the steady state resource number density N_R will always be below the resource carrying capacity c_R. We refer to the ratio N_R / c_R as the the resource level. This has to be a number between 0 and 1. This is similar to the feeding level and the reproduction level.\nHow much the steady state resource abundance N_R changes when the predation mortality from fish increases depends on the resource level. This is best illustrated by a diagram.\n\n\n\n\n\nThe black dot represents the steady state situation, the one we have tuned our model to. The solid lines show how the resource abundance on the y axis will change as the resource mortality on the x axis changes away from the steady state value. The blue line gives the relationship for a higher carrying capacity, the black line gives it for a lower carrying capacity. We see that for a given change in the resource mortality, the change in resource abundance is larger along the blue curve than along the black curve. So the blue curve corresponds to more sensitivity of the resource to changes in the fish abundance and the black curve corresponds to more resilience of the resource. The blue curve is for a resource level of 1/3 and the black line for a resource level of 1/2. The closer the resource level is to 1 the shallower the curve and the more resilient the resource.\nJust like with reproduction level, we did not need to worry about resource level while we were tuning the steady state because the steady state does not change as the resource level changes. But the resource level becomes important when we investigate perturbations away from the steady state.\nWe do not set the resource level directly. We set the replenishment rate r_R and this determines the resource level:\n{\\tt resource\\ level}(w) = \\frac{r_R(w)}{r_R(w) + \\mu_R(w)}.\nSo the resource level depends both on the replenishment rate and on the predation mortality that the fish exert on the resource.\nLet’s look at the resource level in our model.\n\nplotResourceLevel(cm)\n\n\n\n\nThe resource level is close to one for the smaller resource because almost no fish consume it, but the resource level drops for larger resource."
  },
  {
    "objectID": "use/change-resources.html#scenario-1-changes-in-resource-replenishment-rate",
    "href": "use/change-resources.html#scenario-1-changes-in-resource-replenishment-rate",
    "title": "Change resources",
    "section": "Scenario 1: Changes in resource replenishment rate",
    "text": "Scenario 1: Changes in resource replenishment rate\nWe will now change the resource replenishment rate for plankton to see how that affects the resource level for plankton and how that affects the system’s response to changes in fishing. We change the value of the r_pp for the plankton resource and choose the two values 10 and 1 for the high and the low replenishment rate.\n\n# Create new data frame for high and low plankton replenishment\nrp <- resource_params(cm)\nrp_Pl_high <- rp\nrp_Pl_high[\"pl\", \"r_pp\"] <- 10\n\nrp_Pl_low <- rp\nrp_Pl_low[\"pl\", \"r_pp\"] <- 1\n\nWe will use a new function setResourceSemichemostat() to update resource parameters.\n\ncm_Pl_high <- setResourceSemichemostat(cm, rp_Pl_high)\n\ncm_Pl_low <- setResourceSemichemostat(cm, rp_Pl_low)\n\n\n\n\n\n\n\nPreserving the steady state\n\n\n\nThe setResourceSemichemostat sets the resource carrying capacity so that the resource abundance is at steady state with the given replenishment rate and the mortality rate exerted by the current fish abundances. This means that if we start with a steady state of the whole system and only change the replenishment rate by changing the r_pp and/or n parameters, then the steady state is preserved. However, if we change the resource abundance by changing the kappa, lambda, min_w or max_w parameters, this changes the food available for the fish and thus their growth rates. This means that the fish spectra will change over time and thus the resource mortality rate will change and the resource will no longer be at steady state. We’ll see an example of that in the next scenario.\n\n\nLet us look at the changed reproduction levels:\n\nplotResourceLevel(cm_Pl_low)\nplotResourceLevel(cm_Pl_high)\n\n\n\n\n\nlow plankton replenishment\n\n\n\n\n\n\nhigh plankton replenishment\n\n\n\n\n\n\nThe changed resource level should lead to differences when we perturb the system away from its steady state. We will perturb the system by imposing a higher fishing effort.We will run simulations with the reduced and the increased replenishment rate with a fishing effort of 0.7. As a result of that higher fishing effort, the fish biomasses will change and hence resource consumption will change. The resource level will determine how sensitive the system is to that change.\n\n# Lower replenishment, higher effort \nsim_lower <- project(cm_Pl_low, effort = 0.7, t_max = 50)\nplotlyBiomassRelative(sim_lower)\n# Higher replenishment, higher effort \nsim_higher <- project(cm_Pl_high, effort = 0.7, t_max = 50)\nplotlyBiomassRelative(sim_higher)\n\n\n\n\n\n\n\nlow plankton replenishment\n\n\n\n\n\n\n\n\nhigh plankton replenishment\n\n\n\n\nThe differences in the response of the system to the higher fishing effort are not very different for the two different resource replenishment rates. To see the differences better we plot their relative difference.\n\nplotlyBiomassRelative(sim_lower, sim_higher)\n\n\n\n\n\nWe can see that in this case the differences are never much more than 4%, which is very little considering all the uncertainties in the model. We conclude that for our model, when we want to explore increases in fishing effort, the choice of value for r_pp may not be so important, as the model is not very sensitive to it. However, that may be an artefact of how we have set up external mortality in our model. In our model, mortalities on small individuals are very low and we didn’t bother to fix them with additional mortality to get the allometric mortality rates observed in nature. Had we done that, even small changes in the resource and hence in the larval feeding levels might be important. This is because lower feeding by larvae will make them grow slower, they will spend more time in smallest size classes with very high mortality, and this will affect the entire ecosystem. You can read about it, in this study. And if you want to explore it further and implement it to your model, the mizer code is here.\nExercise\nNow reduce the replenishment rate coefficient r_ppon both plankton and benthos to just 0.01. In addition, increase the fishing effort from 0.3 to 0.4 and project the model far enough to reach a new steady state. By how many percent approximately is the biomass of roach higher in this new steady state than in the original one?\nThere will be no further formal exercises for you to complete, but of course we hope that you will feel the urge to do your own explorations of other scenarios."
  },
  {
    "objectID": "use/change-resources.html#scenario-2-changes-in-total-plankton-abundance",
    "href": "use/change-resources.html#scenario-2-changes-in-total-plankton-abundance",
    "title": "Change resources",
    "section": "Scenario 2: Changes in total plankton abundance",
    "text": "Scenario 2: Changes in total plankton abundance\nNow we want to explore how our ecosystem might respond to the overall changes in resource abundance. Perhaps due to climate change the overall resource abundance will increase or decrease. We can explore this in a simple way by changing the kappa parameter.\nNow we will change plankton kappa in the same way as we changed r_pp in the previous scenario. Just to make sure we see some impact, let’s increase or decrease kappa by 50% and project to a new state.\n\n# Create new resource parameter data frames for more and less plankton \nrp_more_be <- rp\nrp_less_be <- rp\n\n# Increase kappa by 50%\nrp_more_be[\"pl\", \"kappa\"] <- rp_more_be[\"pl\", \"kappa\"] * 1.5\n\n# Decrease kappa by 50% \nrp_less_be[\"pl\", \"kappa\"] <- rp_less_be[\"pl\", \"kappa\"] / 1.5\n\n# Put new the resource parameters into the models \ncm_more_be <- setResourceSemichemostat(cm, rp_more_be)\n\ncm_less_be <- setResourceSemichemostat(cm, rp_less_be)\n\nLet’s check that resource abundances really changed by plotting the spectra\n\nplotSpectra2(cm_more_be, \"More\", cm_less_be, \"Less\", power = 2)\n\n\n\n\nAs we discussed before, while the setResourceSemichemostat() has set the resource carrying capacity so that initially the new resource abundance is steady, the fish abundances will change over time in response to the changed resource abundance and as a result also the resource abundance will start to change. Let us investigate that by projecting for 50 years with the new level and compare to the unchanged conditions.\n\nsim_more_plankton <- project(cm_more_be, t_max = 50)\nplotlyBiomassRelative(sim_more_plankton)\nsim_less_plankton <- project(cm_less_be, t_max = 50)\nplotlyBiomassRelative(sim_less_plankton)\n\n\n\n\n\n\n\nmore plankton\n\n\n\n\n\n\n\n\nless plankton\n\n\n\n\nThese results are quite expected. As plankton abundance increased, biomasses and yields for all species also increased. Roach benefited most, but pikeperch was also affected positively. Predator_fish also increased. The effect of decreasing plankton abundance is strongest on roach, pikeperch and predator_fish. So the overall effects of 50% increase and decrease in plankton kappa are rather symmetrical and expected.\nLet us also look at the feeding levels in the new steady states\n\nplotlyFeedingLevel(sim_more_plankton)\nplotlyFeedingLevel(sim_less_plankton)\n\n\n\n\n\n\n\nmore plankton\n\n\n\n\n\n\n\n\nless plankton\n\n\n\n\nAs expected, the feeding level for small individuals, which rely most on plankton for their food, are lower for lower plankton abundance."
  },
  {
    "objectID": "use/change-resources.html#scenario-3-changes-in-total-benthos-abundance",
    "href": "use/change-resources.html#scenario-3-changes-in-total-benthos-abundance",
    "title": "Change resources",
    "section": "Scenario 3: Changes in total benthos abundance",
    "text": "Scenario 3: Changes in total benthos abundance\nFrom the plankton exercise we might expect that changing benthos will lead to similar ecosystem change. But this is not necessarily the case, because all species feed on plankton, yet only some species feed on benthos. Without exploring this question in a multi-species context, we cannot really predict. We will follow exactly the same steps as in the previous scenario.\n\n# Create new resource parameter data frames for more and less plankton \nrp_more_be <- rp\nrp_less_be <- rp\n\n# Increase kappa by 50%\nrp_more_be[\"bb\", \"kappa\"] <- rp_more_be[\"bb\", \"kappa\"] * 1.5\n\n# Decrease kappa by 50% \nrp_less_be[\"bb\", \"kappa\"] <- rp_less_be[\"bb\", \"kappa\"] / 1.5\n\n# Put the new resource parameters into the models\ncm_more_be <- setResourceSemichemostat(cm, rp_more_be)\n\ncm_less_be <- setResourceSemichemostat(cm, rp_less_be)\n\n# Check on the spectra plot that the changes have taken place\nplotSpectra2(cm_more_be, \"More\", cm_less_be, \"Less\", power = 2)\n\n\n\n\nNow we will project for 50 years with the new level and see how the biomasses are changed\n\nsim_more_be <- project(cm_more_be, t_max = 50)\nplotlyBiomassRelative(sim_more_be)\nsim_less_be <- project(cm_less_be, t_max = 50)\nplotlyBiomassRelative(sim_less_be)\n\n\n\n\n\n\n\nmore benthos\n\n\n\n\n\n\n\n\nless benthos\n\n\n\n\nSurprisingly, the effects of decreasing benthos are far less pronounced on benthivorous fish, like roach, carrasius and breams. And it is perch and pikeperch that increased most, when benthos increased. It appears that benthivorous species were affected by changes in their predators and this counteracted the changes in their growth rate that are caused by the changes in their benthic resource.\nThis is just a simple exploration, but it demonstrates that in a multi-species system that consists of different trophic groups (planktivores, benthivores, predators), changes in plankton and benthos resource levels can have different and sometimes unexpected effects on species and yields. Also, different resources are likely to respond to climate change differently, and mizerMR provides an opportunity to explore it. Remember, you can set more than two resources in mizerMR. In fact, every species could have its own resource, although this would be a pretty boring model. But if you have a good reason to set 3 or 4 separate resources, this can be easily done."
  },
  {
    "objectID": "use/change-resources.html#scenario-4-changes-in-resource-size-structure-and-replenishment-rate",
    "href": "use/change-resources.html#scenario-4-changes-in-resource-size-structure-and-replenishment-rate",
    "title": "Change resources",
    "section": "Scenario 4: changes in resource size structure and replenishment rate",
    "text": "Scenario 4: changes in resource size structure and replenishment rate\nIt has also been suggested that climate change is changing the size structure of aquatic organisms, from plankton to fishes. We can attempt to model such changes in resource size structure by changing the lambda parameter. Mostly, it is expected that organisms will get smaller, so we expect lambda to become steeper (have larger values). But at the same time benthic organisms might have faster growth rates, so their sizes might increase. These are just entirely hypothetical scenarios, but we can explore how potentially different responses in plankton and benthos will affect the ecosystem. But unlike with kappa we change lambda just by a small amount, because even small changes in allometric exponents will have large effects on the size spectrum.\nWe will repeat the steps from above - save the dataframe, update it with new parameters, check, put it back into params objects:\n\n# Create new resource parameter data frames for more and less plankton \nrp_steeperPl <- rp\nrp_shallowBe <- rp\nrp_Both <- rp\n\n# Increase plankton lambda by 0.1, setting it to 2.15 instead of 2.05\nrp_steeperPl[\"pl\", \"lambda\"] <- 2.15\n# Decrease benthos slope by 0.1, setting it to 1.8\nrp_shallowBe[\"bb\", \"lambda\"] <- 1.8\n# And now make both changes\nrp_Both[\"pl\", \"lambda\"] <- 2.15\nrp_Both[\"bb\", \"lambda\"] <- 1.8\n\n# Put the new resource parameters into the models\ncm_steeperPl <- setResourceSemichemostat(cm, rp_steeperPl)\ncm_shallowBe <- setResourceSemichemostat(cm, rp_shallowBe)\ncm_Both <- setResourceSemichemostat(cm, rp_Both)\n\nNow we project with steeper plankton slope for 50 years and look at the relative changes in the biomasses.\n\nsim_steeperPl <- project(cm_steeperPl, t_max = 50)\nplotlyBiomassRelative(sim_steeperPl)\n\n\n\n\n\nHere changes are more dramatic, with all species increasing their biomases with steeper plankton slopes. This might sound strange and counter intuitive, but we must realise that slope only affects the steepness of the resource, keeping abundance at 1g constant. So steeper slopes mean less plankton larger than 1 g, but more plankton small than 1 g. And since our maximum plankton size is only 1g, we only increased its abundance!\nNow let’s look at the effect of changes in the benthos slope.\n\nsim_shallowBe <- project(cm_shallowBe, t_max = 50)\nplotlyBiomassRelative(sim_shallowBe)\n\n\n\n\n\nWith more shallow benthos slopes, roach and pikeperch are affected badly and other benthivores decrease slighly, but are probably benefiting from reduced predation due to reduced predator biomass. We can compare feeding level changes and see that large predators have largest decreases in feeding level.\n\nplotlyFeedingLevel(sim_steeperPl)\nplotlyFeedingLevel(sim_shallowBe)\n\n\n\n\n\n\n\nsteeper plankton\n\n\n\n\n\n\n\n\nshallower benthos\n\n\n\n\nAnd what happens if both plankton and benthos slopes change?\n\nsim_Both <- project(cm_Both, t_max = 50)\nplotlyBiomassRelative(sim_Both)\n\n\n\n\n\nNow effects partly balance each other out, but to understand this better we will compare to simulations where, for example, only plankton slope changed. This can help isolate the interacting effects.\n\nplotlyBiomassRelative(sim_Both, sim_steeperPl)\nplotlyYieldRelative(sim_Both, sim_steeperPl)\n\n\n\n\n\n\n\nBiomass\n\n\n\n\n\n\n\n\nYield\n\n\n\n\nYou can also try to combine these changes in lambda with changes in the resource replenishment rate (which can either go up or down due to climate change) and see how many options we already have. And then these lambda changes will probably also interact with changes in kappa, and feed back into the ecosystem through species interactions. Moreover, our system response to these changes will depend on reproduction level and resource resilience parameters (replenishment rate), and it will depend on other parameters for our species. This gets complicated very quickly. On top of that we probably want to explore how fishing might interact with changes in the resource abundance, so that gets even more complicated. This is not to discourage you, but to show that there are plenty of opportunities for exploration and interesting publications. We are still very uncertain on how resources will respond to changes in climate and will probably learn a lot more in the future."
  },
  {
    "objectID": "use/change-resources.html#scenario-5-changes-through-time",
    "href": "use/change-resources.html#scenario-5-changes-through-time",
    "title": "Change resources",
    "section": "Scenario 5: Changes through time",
    "text": "Scenario 5: Changes through time\nThe scenario explorations above were very simple, because we changed one or several of resource parameters and projected the system to a new steady state. While the mechanics of setting such scenarios is straightforward, examples above show that understanding all the complex ways how simple changes can affect the ecosystem may be harder.\nHowever, many researchers do not want to explore such hypothetical resource changes, but instead use independently derived time series of resource abundance provided by e.g. satellite observations and earth system models. This is important and useful, although we do encourage you to play with simple changes first to gain understanding about your system and its sensitivity to resource changes. Just like with fishing mortality scenarios, ecosystem response will depend strongly on our model calibration. This means that before we go into complex scenarios we need to be satisfied with the parameters we provided and know limitations of our simulations. For example, alternative, equally possible model calibrations may provide different quantitative change (i.e. how much the biomasses or yields change), but similar qualitative response in the ecosystem. If quantitative differences are very large, perhaps it would be best to focus on more general qualitative responses.\nBut let’s look at how we can implement multiple drivers under climate change by coupling mizer to outputs of earth system models such as temperature, abundance of different size classes of plankton or detrital “marine snow” that reaches the sea floor through time. This example is provided by Julia Blanchard and it demonstrates how to implement changes in resource abundance and size structure through time, by working with pre-made resource size spectra files that were estimated from two climate change scenarios from earth system model output.\nThese resource spectra files were derived from small and large phytoplankton biomasses predicted by the Fisheries and Marine Ecosystems Model Intercomparison Project (FishMIP). There are a lot of steps in processing these data, but we won’t go in to that here. The main goal is to demonstrate how to use these scenario forcings to create changes in your mizer resources through time. This example will use another model - Patagonian toothfish fishery ecosystem. We will explore how the marine demersal fish community changes under this forcing through time. The two model scenarios are ssp585 (highest emissions or “worst”) and ssp126 (mitigation to cut emissions or “best”). Note: this new model does NOT use multiple resources\nRead in the model and the resource abundances provided by the earth system model.\n\nparams <- readParams(\"toothfish_model.rds\")\nresource_best <- readRDS(\"resource_scenario_126.rds\")\nresource_worst <- readRDS(\"resource_scenario_585.rds\")\n\nThe data files provide arrays with dimensions time x size with the resource number density in the years from 2021 to 2070 for all size classes in the model, as predicted by the earth system model.\n\nstr(resource_best)\n\n num [1:50, 1:209] 7.34e+31 7.98e+31 7.90e+31 7.53e+31 7.65e+31 ...\n - attr(*, \"dimnames\")=List of 2\n  ..$ : chr [1:50] \"2021\" \"2022\" \"2023\" \"2024\" ...\n  ..$ : chr [1:209] \"9.42976673097891e-13\" \"1.14104741933864e-12\" \"1.38072260992634e-12\" \"1.67074119204156e-12\" ...\n\n\nWe now create new mizer models that contain this information about the plankton abundance. Mizer allows us to add an arbitrary number of other parameters to the model. We decide to call our new parameter resource_array.\n\n#create new params files\nparams_worst <- params\nparams_best <- params\n\n# Add extra `resource_array` parameter to these model\nother_params(params_best)$resource_array <- resource_best\nother_params(params_worst)$resource_array <- resource_worst\n\nInstead of running mizer’s standard resource dynamics we want the resource abundance to be taken from these arrays. To achieve this we will use a handy mizer feature that allows us to provide our own resource dynamics function. That function just needs to return the value for the resource at the next time step. So in our case it just needs to look up the correct value in an array.\n\nplankton_forcing <- function(params, t, ...) {\n    # The time `t` will run from 2021 to 2070 whereas the time index in the\n    # array runs from 1 to 50. Hence we need to index by t - 2020.\n    # In fact `t` will take on fractional values like 2021.1 after the first\n    # time step, but R conveniently rounds them down automatically.\n    other_params(params)$resource_array[t - 2020, ]\n}\n\nNow we just have to register this new function as the resource dynamics function in the models:\n\nparams_best <- setResource(params_best, resource_dynamics = \"plankton_forcing\")\nparams_worst <- setResource(params_worst, resource_dynamics = \"plankton_forcing\")\n\nThis means that in each time step the resource abundance (only plankton in this case, as this is the only resource in this model) will be determined not by the semi-chemostat dynamics, but by the externally provided values.\nNow we will project these new models forward for 50 years from 2021 to 2070 without fishing.\n\nsim_best <- project(params_best, effort = 0, t_start = 2021, t_max = 50)\n\nsim_worst <- project(params_worst, effort = 0, t_start = 2021, t_max = 50)\n\nLet’s look at how the biomasses evolve in these models:\n\nplotlyBiomassRelative(sim_best)\nplotlyBiomassRelative(sim_worst)\n\n\n\n\n\n\n\nBest\n\n\n\n\n\n\n\n\nWorst\n\n\n\n\nThis shows how the effects of plankton changing alone can have a big effects on the model.\n\nanimateSpectra(sim_worst, power = 2)\n\n\n\n\n\nThis example has shown how you can directly use outputs of earth system models for projections (GFDL inputs - FishMIP)."
  },
  {
    "objectID": "use/change-resources.html#summary",
    "href": "use/change-resources.html#summary",
    "title": "Change resources",
    "section": "Summary",
    "text": "Summary\n\nThe resource replenishment rate coefficient r_pp will determine the resilience of the resource spectrum to mortality imposed by fish. In many scenarios, the choice of replenishment rate may not make a big impact, but in others it will be important. Therefore we should explore how this parameter might affect our model dynamics (together with other parameters, of course).\nClimate change is likely to impact resource abundance, size structure and productivity. Mizer allows you to explore how these changes might impact aquatic ecosystems and yields.\nBy separating plankton and benthos resource mizerMR allows us to model separate resource responses to climate, which are likely to lead to different responses in different trophic groups of fish. There are many potential ways how these resources can change, so one needs to carefully consider how best to select scenarios.\nWe can change resource dynamics to functions other than semi-chemostat. Mizer allows you to force models with externally obtained resource time series. This way we can explore gradual ecosystem changes through time."
  },
  {
    "objectID": "use/change-resources.html#further-explorations-and-climate-change-effects",
    "href": "use/change-resources.html#further-explorations-and-climate-change-effects",
    "title": "Change resources",
    "section": "Further explorations and climate change effects",
    "text": "Further explorations and climate change effects\nIf you want to explore how changes in the resource due to climate change can affect ecosystems with multiple resources you can look at two recent model applications. One example is a recently published Baltic Sea mizer model where authors explored how changes in resource total abundance (kappa) and replenishment rate (r_pp) might affect the ecosystem.\nAnother example in the Tasmanian rocky reef model (a preprint can be found here), where authors used multiple parameter combinations to assess how changes in kappa and lambda for plankton and benthos might affect the ecosystem. The Tasmanian model has a supporting R Shiny application that allows you explore your own resource change scenarios, using one parameterisation. Here you can change kappa and lambda of either plankton or benthos resource and combine resource changes with physiological responses to temperature change, by also changing model temperatures. This will display changes in biomass, yields and mean sizes for the modeled fish species.\nDespite all the complexities above, we barely scratched the surface about the possible ways how climate change might affect our ecosystems. For example, so far we did not include any direct temperature effects. Even though we modeled resource change, this was imposed externally and did not combine with possible effects of temperature on physiology. If you want to also include temperature effects on fish physiological rates, take a look at the excellent blog post by Phoebe Woodworth-Jefcoats in the mizer blog. She describes how you can replace rate functions in mizer with your own set functions and she uses this to account for dome-shaped species responses to temperature - increased rates up to a certain temperature and decreases after that.\nOf course climate change will also affect the composition of species, because with warming new species will enter the ecosystem. This is an important aspect to address, but has not been thoroughly explored yet. Mizer allows you to add new species into ecosystem with the addSpecies() function. However, it is not necessarily clear how we tune parameters of new species for which we don’t yet have data (in that ecosystem at least), so exploring climate heating driven species composition change is not straightforward."
  },
  {
    "objectID": "use/further-scenarios.html",
    "href": "use/further-scenarios.html",
    "title": "Explore further scenarios",
    "section": "",
    "text": "This final tutorial gives some examples from another mizer model, tuned to a different system and used to explore different questions. It is always useful to see alternative ways of using mizer and get examples of code to setup different analyses. This tutorial is contributed by Julia Blanchard. Here we will explore an example model of longline fishery that consists of targeting a single species, Patagonian toothfish."
  },
  {
    "objectID": "use/further-scenarios.html#a-look-at-the-model",
    "href": "use/further-scenarios.html#a-look-at-the-model",
    "title": "Explore further scenarios",
    "section": "A look at the model",
    "text": "A look at the model\nAs usual, we need to have some packages installed.\n\nremotes::install_github(\"sizespectrum/mizerExperimental\", ref = \"tuneMR\")\nlibrary(mizerExperimental)\nlibrary(tidyverse)\n\nThen we load the model and explore its various properties.\n\nparams <- readParams(\"toothfish_model.rds\")\n\nWe look at the growth curves,\n\nplotGrowthCurves(params, species_panel = TRUE)\n\n\n\n\nthe spectra,\n\nplotlySpectra(params, power = 2, total = TRUE)\n\n\n\n\n\nthe feeding levels,\n\nplotFeedingLevel(params)\n\n\n\n\nand toothfish diet.\n\nplotDiet(params, species = \"D.ele\")\n\n\n\n\nFor this model, we had the following main criteria for our project:\n\nModelled biomasses were within +/- 10-20% of the observed biomasses.\nUnfished normalised biomass size spectrum slope that is negative and close to -1.\nGrowth curves approximated the von Bertalanffy growth curves for each species.\nToothfish diet captured dietary changes with body size and became more piscivorous at larger sizes.\nRecruitment parameters ensured single-species yield curves were dome-shaped, as expected by theory.\nThe modeled catches through time captured the trends in the reported catches through time.\n\nWe can see from these plots that we still have more work to do with refining the model. The size at age for some species seem much higher than the empirical parameters, feeding level of near satiation for all species and the biomass of some species is much higher than the data. However size-at-age data are typically highly variable. So, let’s set some of those issues aside for now.\nLet’s take a look at how fishing is set up in this model.\n\ngear_params(params)\n\n\n\n  \n\n\n\nCurrently we can see there is one gear - longline - which has a knife_edge selectivity function that starts fishing at very large sizes of toothfish only (knife_edge_size = 2722 g). The size selectivity was derived from the length distribution of catches from the long-line fisheries data. To explore further how to setup your fishing parameters and use gear_params() function you can look at the example here. The catchability has been set to a very low number: 7e-07. The initial effort is:\n\ninitial_effort(params)\n\nlongline \n6787.953 \n\n\nThis shows that the model has been calibrated with a very low level of fishing mortality (multiply effort by catchability).\nLet’s look at the reproduction levels and the yield curve for toothfish:\n\ngetReproductionLevel(params)\n\n    D.ele     C.gun     C.rhi     L.squ     M.cam     B.eat     B.irr     G.acu \n0.9998035 0.9994817 0.9991013 0.9426729 0.8279399 0.9999131 0.9996038 0.9996273 \n    B.mur \n0.9777815 \n\nplotYieldCurve(params, species = \"D.ele\", no_steps = 30, F_max = 2)\n\n\n\n\nThey generally look good and the curve is dome-shaped."
  },
  {
    "objectID": "use/further-scenarios.html#comparing-ecosystem-states-effects-of-fishing-relative-to-an-unfished-state",
    "href": "use/further-scenarios.html#comparing-ecosystem-states-effects-of-fishing-relative-to-an-unfished-state",
    "title": "Explore further scenarios",
    "section": "Comparing ecosystem states: effects of fishing relative to an unfished state",
    "text": "Comparing ecosystem states: effects of fishing relative to an unfished state\nTo be able to assess the wider ecosystem impacts of fishing in the community we need to understand how changes compare to an unfished state. We can use the above model to simulate an unfished steady state with effort = 0 and then explore this state using some ecological indicators.\nLet’s compare the current size spectra (with fishing) to the unfished size spectra to assess whether there is any evidence of a size-structured trophic cascade due to fishing.\n\nsim0 <- project(params, effort = 0, t_max = 20)\nplotSpectraRelative(sim0, params)\n\n\n\n\nHere we can see the effect of the reduction in large sized individuals of heavily fished species on the other sizes and species in the model, relative to the unfished steady state.\nThe abundance of some (but not all) of the smaller to medium sizes of prey are a lot higher when their larger predators are removed (note the logarithmic scale). This is because when toothfish are removed via fishing, they have less predation mortality and no fishing inflicted upon them."
  },
  {
    "objectID": "use/further-scenarios.html#fishing-through-time-past-time-series",
    "href": "use/further-scenarios.html#fishing-through-time-past-time-series",
    "title": "Explore further scenarios",
    "section": "Fishing through time: past time series",
    "text": "Fishing through time: past time series\nMizer can also be used to carry out projections with changes in fishing effort. We will start by reading in a time series of catch and effort. We will read in the effort data for this fishery. Note: these are not the correct effort values, they are only for illustration in this example. Then we plot effort and catch through time.\n\ndat <- readRDS(\"toothfish/longline.rds\")\nplot_dat <- melt(dat, \"Year\")\n\nggplot(plot_dat, aes(x = Year, y = value)) +\n    geom_point() +\n    facet_wrap(~variable, nrow = 2, scales = \"free\")\n\n\n\n\nWe can see from the data that there have been big changes in effort and catches through time. The first plot shows relative effort per area (please note that these data are not correct and are only being used for illustration in this example). Catches are in tonnes per square km fished. They have changed a lot over the years.\nPreviously we assumed effort was 1 and we worked with catchability as the variable. Real effort data can come in all sorts of different units (hours or days fished, kilowatt days, number of vessels all per unit time). The key to using this in our model is that the catchability is the fraction of the available (that is also selected by the gear) stock caught per unit of any effort that is included.\nOften, we have used fishing mortality rates from stock assessment to drive changes in effort through time, assuming Q*E = F at maximally selected sizes (as in this paper and others). But in many cases this information is not available. It also could be misleading as those fishing mortality rates are estimated using very different single-species models (but sometimes that is the best we have to work with, and as with all of the assumptions we make the limitations just need to be clear).\nHow do we incorporate the effort data into the model? First, we have to re-arrange the data so it can be read into the params object.\n\neffort_time <- array(c(rep(0,13), dat$EffortPerArea), \n                     dim = c(length(1990:2020), 1),\n                     dimnames = list(\"time\" = 1990:2020, \n                                     \"gear\" = params@gear_params$gear[1]))\n\nNext we use the effort data to project the model forwards from it’s steady state. But wait - we did not set up the model for the first year of the data, when fishing only just began. It may make more sense to use a steady state without fishing as the initial values for our projection.\n\n#project to zero fishing rate \nparams <- projectToSteady(params, effort = 0)\n\nConvergence was achieved in 1.5 years.\n\n#project with fishing effort\nsimf <- project(params, effort = effort_time)\n\nplotYieldGear(simf) + \n    geom_point(data = dat, shape = 1, size = 1, \n               mapping = aes(x = Year, y = CatchPerArea))\n\n\n\n\nHere we can see that the modeled catch time series fall within the scatter of the observed catch data (reassuring), but the trends are different. It seems there is a sharp decline in modeled catches towards the end of the time series. While we should not expect the exact up and down fluctuations to be captured by our model (we don’t have anything forcing the changes through time other than fishing!), we could examine further how changing the reproduction parameters affects how well the model captures stock decline (and later, recovery), relative to the trends in the data. It may also be that our estimates of catchability and effort are way off (they are). And that other factors could be influencing observed changes not accounted for by our model."
  },
  {
    "objectID": "use/further-scenarios.html#what-if-we-only-have-catch-data",
    "href": "use/further-scenarios.html#what-if-we-only-have-catch-data",
    "title": "Explore further scenarios",
    "section": "What if we only have catch data?",
    "text": "What if we only have catch data?\nWhat if there was no effort data and only catch data? This is the case for many data-poor fisheries or for fisheries where there is only restricted access to effort data.\nMany fisheries develop through time according to phases: an exponential growth period, following either a peak and subsequent decline and a plateau, if stocks drop below sustainable levels and management kicks in (see here for example). These different types of development can be represented by a function, logistic_effort(), and can be used to help estimate the fishing parameters given the the model parameters and data you may have. This is the approach used here. Here, we will use this function to explore effort through time.\n\nlogistic_effort <- function(effort_array,\n                            gear = \"longline\",\n                            time = 1990:2020,\n                            Fmax = 1.5,\n                            steepness = 0.2,\n                            midpoint = 2005) {\n    effort_array[, gear] <- Fmax / (1 + exp(-steepness*(time - midpoint)))\n    return(effort_array)\n}\n\nAfter using the above function we can scale the effort up to the effort units we used in our base model. We do this by setting the Fmax in the logistic equation to the desired level of fishing mortality rate (e.g. 0.005 was used above but for this example we will plug in a different value to explore heavier fishing). We then divide Fmax by our estimated catchability coefficient (which was estimated to be a very small number) to get effort in the correct ballpark and units as the data we used above. If you want to run the model directly with fishing mortality rate as the “effort” driver, you would need to set the catchability coefficient to 1 in this example. If no effort exists for your system, we would need to estimate the catchability coefficient (either by hand tuning or statistical time-series fitting).\n\nneweffort <- logistic_effort(effort_time, time = 1990:2020, Fmax = 0.5,\n                             steepness = 0.9, midpoint = 2005)\n\n#rescale to get effort in same units as our example\nneweffort <- neweffort / gear_params(params)$catchability[1]\n\n# or if you want to just use fishing mortality only in your model, \n# overwrite the catchability to 1:\n# gear_params(params)$catchability[1] <- 1\n\nyear = 1990:2020\nqplot(year, neweffort, ylab = \"effort\", xlab = \"\")\n\n\n\n\nNow you can run the same model above using this effort and then plot effort and biomass dynamics through time.\n\nparams3 <- setInitialValues(params, sim0)\nsimf3 <- project(params3, effort = neweffort)\n\nplotYieldGear(simf3) + \n    geom_point(data = dat, shape = 1, size = 1, \n               mapping = aes(x = Year, y = CatchPerArea)) + \n    xlim(2000, 2020)\n\nWarning: Removed 10 row(s) containing missing values (geom_path).\n\n\n\n\nplotBiomass(simf3)\n\n\n\n# If you like you can save the output for further analyses \n#saveRDS(simf3,\"simf3.rds\")\n\nWe can see here as effort develops towards a plateau of Fmax = 0.5 through time, catches initially increase, reach a peak around 2006, and then decline. The biomass trajectories also show that toothfish starts declining slightly before this."
  },
  {
    "objectID": "use/further-scenarios.html#fishing-through-time-projecting-into-the-future",
    "href": "use/further-scenarios.html#fishing-through-time-projecting-into-the-future",
    "title": "Explore further scenarios",
    "section": "Fishing through time: projecting into the future",
    "text": "Fishing through time: projecting into the future\nNow let’s see what happens if we change fishing in the future. To do this we set up two scenarios, one where the model starts with the last time step of the fished scenario and continues into the future (the “status quo”). The other will be designed to explore a “more sustainable” scenario.\n\n# Use the parameters from the last simulation\nparams <- getParams(simf3)\nparams <- setInitialValues(params, simf3)\n\nThe setInitialValues() function has set the initial spectra and the initial effort in the params object to the final values from simf3, i.e., to the values from 2020. The effort was\n\ninitial_effort(params)\n\nlongline \n714284.7 \n\n\nLet’s start a new simulation that begins with the effort from 2020 and projects forward for 50 years. We will apply a linear decrease in effort for toothfish to a target value (here assumed for simplicity to be F = 0.2). To do this we need to work the effort array again (time x gear) to enable changes in effort through time.\n\nproj_effort_scen1 <- matrix(initial_effort(params), nrow = 50, ncol = 1, byrow = TRUE)\ndimnames(proj_effort_scen1) <- \n    list(time = 2021:2070, gear = unique(gear_params(params)$gear))\n# check it\nqplot(x = 2021:2070, y = proj_effort_scen1, ylab = \"effort\", xlab = \"\")\n\n\n\n\nThat was Scenario 1 (“status quo”), now let’s set up Scenario 2, the “more sustainable” option we wish to explore. Again, if we are working in the same units as the effort above we can change the F below to scale effort to be consistent with a value of F=0.2. So we need to set effort= catchability/targetF. Otherwise if you assume targetF= catchability*E, and set catchability to 1, you can just use targetF=0.2 directly for Scenario 2.\n\nproj_effort_scen2 <- proj_effort_scen1\ntargetF <- 0.2 / gear_params(params)$catchability[1]\nselect_gear = \"longline\"\n# reach target by 10 years\nproj_effort_scen2[1:10,select_gear] <- \n    seq(from = proj_effort_scen2[1], to = targetF, length = 10)\n# then hold at target\nproj_effort_scen2[11:50, select_gear] <- targetF\n# check it\nqplot(x = 2021:2070, y = proj_effort_scen2, ylab = \"effort\", xlab = \"\")\n\n\n\n\nNow we want to run the simulation forward using the project() function.\n\n# run the simulations forward, both using the 2020 abundances as initial values\nsim_scen1 <- project(params, effort = proj_effort_scen1, t_max = 50)\nsim_scen2 <- project(params, effort = proj_effort_scen2, t_max = 50)\n\nHow has this affected the catches and the biomass of other species in the system relative to fishing levels in 2020?\n\n#set the scenario to examine relative to 2020 levels\nscen <- sim_scen2\nplotYield(scen)\n\n\n\n# plot change in biomass under each scenario relative to current values\nB_current <- getBiomass(scen)[1, ]\nBrel_scen <- melt(sweep(getBiomass(scen), 2, B_current, \"/\"))\ncolnames(Brel_scen)[2] <- \"Species\"\nlegend_levels <- intersect(names(scen@params@linecolour), Brel_scen$Species)\nggplot(Brel_scen) + \n  geom_line(aes(x = time,y = value,color = Species), size = 1) + \n  geom_hline(yintercept = 1, linetype = 1, colour = \"grey\", size = 0.75) +\n  scale_y_continuous(name = \"Relative biomass\") +\n  scale_color_manual(values = params@linecolour[legend_levels]) +\n  theme(legend.key = element_rect(fill = \"white\")) \n\n\n\n\nRelative to 2020 values, reducing Fmsy to 0.2 has increased toothfish biomass and has affected the other species in the system too.\nTo compare the status of the stock across the two scenarios we need to express the changes relative to the unfished state according to the model. This will provide us with a rough indicator of the level of depletion. Generally, we would consider a stock to be collapsed if biomass was <0.1 of the unfished levels. Some data-poor single species fisheries management strategies seek for depletion to be around or above 0.5 of unfished levels.\nLet’s take a look at the relative exploitation status of the stocks using the projected values for 2050. We will put the y-axis scale is log10 to better visualise the differences across species.\n\n# plot change in biomass under each scenario relative to unfished values\n# get saved values from steady state without fishing that we generated earlier \nsim0<-readRDS(\"sim0.rds\")\n# get the unfished biomasses\nB_unfished <- getBiomass(sim0)[1, ]\n#scen 1\nBrel_scen1_2050 <- getBiomass(sim_scen1)[\"2050\",]/B_unfished\n\n#scen 2\nBrel_scen2_2050 <- getBiomass(sim_scen2)[\"2050\",]/B_unfished\n\nBrel_scens <- rbind(data.frame(species=names(Brel_scen1_2050),value=Brel_scen1_2050,scen=\"scen1\"),data.frame(species=names(Brel_scen2_2050),value=Brel_scen2_2050,scen=\"scen2\"))\n\n# barplot comparing the 2 scenarios by 2050\nggplot(Brel_scens, aes(fill=scen, y=value, x=species)) + \n    geom_bar(position=\"dodge\", stat=\"identity\") + \n     geom_hline(yintercept = 0.1, linetype = 2, colour = \"red\", size = 0.5)  + scale_y_log10(name = \"log10(Biomass/Biomass Unfished)\")\n\n\n\n# to save:\n#saveRDS(sim_scen2,\"sim_scen2.rds\")\n\nSpecies with B/B_unfished values that are below the red dashed line imply the stock is still collapsed.\nWe can see that when we decrease fishing to the targetF under scenario 2 this greatly improves the relative biomass compared to the status quo. This is consistent with our expectations from the equilibrium Fmsy that we tuned. Another thing to note is that, relative to the unfished community, there are several species that increase less under this fishing scenario - this is what happens when account for food web interactions in models!"
  },
  {
    "objectID": "use/further-scenarios.html#set-up-your-own-fishing-scenario-simpler-comparison-of-steady-states",
    "href": "use/further-scenarios.html#set-up-your-own-fishing-scenario-simpler-comparison-of-steady-states",
    "title": "Explore further scenarios",
    "section": "Set up your own fishing scenario: simpler comparison of steady states",
    "text": "Set up your own fishing scenario: simpler comparison of steady states\nRather than an entire time-series, we can also simply examine differences between two time-averaged states under different fishing regimes.\nWe can alter the fishing parameters using a function called gear_params() and by changing the effort input.\nLet’s take a look at the fishing parameters.\nWe can group species together according to the gears they are caught by. Initially let’s just add another gear - a trawler targeting icefish (C.gun).\n\n# allocate species to gear types\ngear_params(params) <- data.frame(\n    gear = c(\"longline\", \"trawler\"),\n    species = c(\"D.ele\", \"C.gun\"),\n    catchability = c(1, 1),\n    sel_fun = c(\"knife_edge\", \"knife_edge\"),\n    knife_edge_size = c(2722, 52)\n    )\n#check it\ngear_params(params)\n\n\n\n  \n\n\n\nNote that catchability is set to 1. This is because the fishing “effort” was here assumed to be the fishing mortality rate of fully selected sizes (see here setFishing).\n\nparams <- setFishing(params, initial_effort = 0.1)\n\nNow let’s run two simulations, one with light fishing mortality (F = 0.2) and one heavy fishing (F = 1.5).\n\nsim_unfished <- projectToSteady(params, effort = 0, t_max = 500)\n\nConvergence was achieved in 69 years.\n\nplot(sim_unfished)\n\n\n\nparams_longline_trawl<-params\nsim_longline_trawl <- projectToSteady(params_longline_trawl, effort = 0.1, t_max = 500)\n\nConvergence was achieved in 34.5 years.\n\nparams_longline<-params\ngear_params(params_longline)$catchability[2]=0\nsim_longline <- projectToSteady(params_longline, effort = 0.1, t_max = 500)\n\nConvergence was achieved in 34.5 years.\n\n\n\n# plot change in biomass under each scenario relative to unfished values\n# get the unfished biomasses\nB_unfished <- getBiomass(sim_unfished)\n#scen 1\nBrel_longline <- getBiomass(sim_longline)/B_unfished\n\n#scen 2\nBrel_longline_trawl <- getBiomass(sim_longline_trawl)/B_unfished\n\nBrel_scens <- rbind(data.frame(species=names(Brel_longline),value=Brel_longline,scen=\"longline\"),data.frame(species=names(Brel_longline_trawl),value=Brel_longline_trawl,scen=\"longline_trawl\"))\n\n# barplot comparing the 2 scenarios by 2050\nggplot(Brel_scens, aes(fill=scen, y=value, x=species)) + \n    geom_bar(position=\"dodge\", stat=\"identity\") + \n    geom_hline(yintercept = 0.1, linetype = 2, colour = \"red\", size = 0.5)  + \n    scale_y_log10(name = \"log10(Biomass/Biomass Unfished)\")\n\n\n\n\nThe impact of the combined trawl and longline appears to have more of an effect on C.gun and the biomass of D.ele is slightly more depleted relative to the unfished state."
  },
  {
    "objectID": "use/further-scenarios.html#further-exploration",
    "href": "use/further-scenarios.html#further-exploration",
    "title": "Explore further scenarios",
    "section": "Further Exploration",
    "text": "Further Exploration\nThe above plots provide you with a way to compare different modelling scenarios. You may wish to explore different levels of fishing mortality in the above example or add completely different gears to the fishery."
  },
  {
    "objectID": "prepare/use-git-and-github.html",
    "href": "prepare/use-git-and-github.html",
    "title": "Use Git and GitHub",
    "section": "",
    "text": "In this course we will collaborate via Git and GitHub. This means that if you have not used these tools before, then you will have to learn some new concepts and get used to a particular workflow. The investment of your time will more than pay off. Developing your research code with Git and GitHub has great advantages, and it’ll be great if this course gets you hooked on these tools. The use we make of Git and GitHub in this course is relatively simple, so it may be the perfect gateway drug.\nWe’ll start by first introducing some of the ideas theoretically, but then we will also show what the workflow looks like in practice. We will only scratch the surface, if you want to go deeper then Happy Git and GitHub for the useR is a useful resource."
  },
  {
    "objectID": "prepare/use-git-and-github.html#theory",
    "href": "prepare/use-git-and-github.html#theory",
    "title": "Use Git and GitHub",
    "section": "Theory",
    "text": "Theory\nGit\nGit is a distributed version control system. So we will start by explaining the “version control” and the “distributed”. We’ll typeset typical Git terminology in bold.\nVersion control means that while you are working on your code or data files you can keep track of all the changes you are making. You can then later review the history of changes and, if necessary, revert to earlier versions. You may say that any cloud storage service like Google Drive or Dropbox does that as well, but there are important differences that we will now discuss.\n\nGit keeps the repository with all your changes on your local computer. The version control does not rely on an internet connection.\nYou explicitly say when you want a batch of changes to be stored in the repository. Saving changes to the files in your local file area does not yet modify the repository. You have to make a so-called commit to commit the changes you want to the repository.\nTypically you will add a commit message that summarises briefly what the changes are about. This makes it much easier to understand the development of your code later on.\n\nSo Git provides you a full control of creating points at which you want to save your code and documents to your repository. The commit messages you add can be very detailed or short. Their goal is for you and your collaborators to know what has been changed between different commit steps.\nDistributed means that the repository typically does not reside only on a single computer. There can be clones of the repository on many other computers. For example, you might want your collaborators to have a copy of the repository for a common project that you are working on jointly. They can make commits to their clone of the repository in the same way you can make commits to yours.\nEven if you only intend to work on your code alone, you may want to have copies of it on all the computers you occasionally work at and you will then want to be able to commit changes from any of those computers and pick up those changes from any other computer. So below when we speak of your “collaborator”, that collaborator could be yourself on another computer.\nFrom time to time you will want to merge the changes from one clone to another to have a new common version that incorporates changes by all collaborators. For that there needs to be some communication via the internet, facilitated by a Git server.\nGitHub\nGitHub is a service that hosts a clone of your repository on your account and runs a Git server, so that you and your collaborators do not have to run your own Git servers. Instead you can push any commits that you made into your local Git repository to the GitHub clone and then your collaborators can pull those changes to their clone.\nSo with Git and GitHub we have a very different workflow than what you get when you collaborate using for example a Google Drive folder. There are more steps before your collaborator sees your changes, namely:\n\nyou save your code changes on your computer to the directory that is associated with the git repository,\nyou select or stage which of your changed code files you want to commit to your local repository,\nyou commit those selected changes to your repository with a commit message,\nyou push your commits to your online GitHub repository,\nyour collaborators pull your commits from GitHub,\nthese commits automatically get merged into their clone,\nthe changed files are checked out from their clone into the corresponding directory on their local computer drive.\n\nThere are circumstances where the standard workflow fails. If you attempt to pull commits from GitHub that change files that you have also modified locally but not yet committed, then the pull will fail with an error message. If you and a collaborator independently made commits to your respective clones that touched the same lines of code then there may be merge conflicts that need to be resolved. If something like this happens to you then congratulations: you have arrived in more advanced Git territory than we will discuss in this tutorial. If at some point during the course something like this happens to you, let us know by posting a comment and we or some git-savy participant will give advice.\nThis more involved workflow takes a bit of getting used to, but is definitely the best way to work on code and data. If you follow the guidelines about committing your code changes regularly you will easily go back to earlier versions of your code if you need to, work with multiple people on the same code development, return to old coding projects that need reviewing, and be a part of open and reproducible science. So next you will get to try this out in practice."
  },
  {
    "objectID": "prepare/use-git-and-github.html#practice",
    "href": "prepare/use-git-and-github.html#practice",
    "title": "Use Git and GitHub",
    "section": "Practice",
    "text": "Practice\nFor each week of this course you will get a Git repository with worksheets for you to complete. This repository will be set up for you on GitHub by GitHub classroom. You will clone that repository to your computer and then commit your work to that repository and push it back to GitHub. This gives the course leaders a chance to see your work and to comment on it. These repositories will be private repositories, visible only to you and the course leaders Asta and Gustav and to Romain who provides technological support for the course. Below you will get a preparatory repository (also private) on which you can practice the workflow.\nIf you do not yet have an account on GitHub, please go there now and sign up. If you do have an account, please also go there and sign in.\nConnect RStudio to GitHub\nWe will be interacting with Git and GitHub via RStudio. This just requires some initial setup but will be very convenient from then on. Of course, if you are already using GitHub from within RStudio, then you can skip the steps below that you have gone through on your computer in the past.\nRStudio needs a personal access token for accessing GitHub. The following command will bring you to the GitHub webpage that creates that personal access token:\n\nusethis::create_github_token()\n\n\n\n\n\nYou can edit the Note to something like “mizer course” or whatever will remind you later what this was for. You can leave the rest of the form as it is and scroll down to the bottom and press the “Generate token” button. That will lead you to a page that displays your new token:\n\n\n\n\nLeave this page open for now and return to RStudio and issue the command\n\ngitcreds::gitcreds_set()\n\nThis will prompt you to enter your token. Go back to the webpage with your token and copy the token to your clipboard. Go back to RStudio and paste in that token and press Enter. That completes the setup. You will not have to do this again on this computer, but if you switch to a new computer, you will repeat the above. It is a good idea to save this token somewhere safe, in case you get prompted to enter it again.\nIf you run into difficulties with the above, please post about it in the comments section at the bottom of this page. If you want to dig in deeper yourself, you can take a look at the troubleshooting section in “Happy Git and GitHub for the useR”. But even if you manage to solve some problem yourself, please let us know about it in the comments.\nCreate repository\nTo create your practice repository, please follow the following link:\nhttps://classroom.github.com/a/Fc-YtAIb\nOnce you are logged into GitHub, this should bring you to a screen asking you to accept an assignment.\n\n\n\n\nPlease click on “Accept the assignment”. This will first tell you that your repository is being prepared and that you should refresh the page in your browser.\n\n\n\n\nWhen you hit the refresh button on your browser after just a short moment, you should see a page with a URL for your new repository on GitHub.\n\n\n\n\nPlease follow that URL to your repository’s home page. This page displays the README at the bottom. There you for example find a points bar where you accumulate points as you complete the exercises in the worksheet. We are now interested in the big green “Code” button which, when clicked, will give a popup with the URL for cloning your repository.\n\n\n\n\nClone repository\nNow we can use RStudio to clone this repository to your computer. For this you create a new RStudio project by clicking on the project drop-down menu at the top-right of the RStudio window and selecting “New Project…”.\n\n\n\n\nThat will open a dialog where you first choose “Version Control” and then choose “Git”.\n\n\n\n\n\n\n\n\n\n\nIn the resulting dialog window you paste in the repository URL that you copied from GitHub. You also specify the directory in your file area where you want the project directory to be saved. To do that click the “Browse…” button and find a location that is convenient for you. You may want to create a dedicated directory for this mizer course and then select that. But avoid creating a directory path that is too long. We have seen problems arise for people who used pathnames longer than 100 characters.\n\n\n\n\nThen click “Create Project”. RStudio now communicates with GitHub to download a clone of the repository and it also checks out all the files contained in the repository to the newly created directory. You can see them in the “Files” tab in RStudio.\n\n\n\n\nContinue in worksheet\nIn the Files tab you will in particular see a file called “worksheet-use-git-and-github.Rmd”. That is the worksheet for this tutorial. Please click on the file name in the Files tab of RStudio to open this worksheet in the RStudio editor. The editor has a “Source” mode and a “Visual” mode. Try out both and see which one you prefer.\n\n\n\n\n\n\n\n\n\n\nNow just follow the instructions in that worksheet. This will guide you through the process of performing your first commits to your repository and pushes to GitHub.\nAs you work through the exercises, you will get some automatic feedback. You can also always ask for personal feedback from us. The details are described in the worksheet. But if you run into a problem that you think might be of interest to others as well, please post in the comments below."
  },
  {
    "objectID": "prepare/index.html",
    "href": "prepare/index.html",
    "title": "Prepare for the mizer course",
    "section": "",
    "text": "While the course only starts on Monday the 8th of August, if you like you can already start preparations:\n1) You can introduce yourself and your interests to your fellow participants.\n2) You can install the tools that we will use in the course.\n3) You can familiarise yourself with how we will be using Git and GitHub in this course for collaboration and feedback on your coursework.\n4) We assume that you are familiar with the basics of R programming. There are plenty of free resources to learn R. You can look through R studio resources, go through R for Data Science or explore multiple other tools. You can also share your favourite tutorials or resources in the comments below.\nThat will allow for a flying start to the course. You won’t believe how much we are looking forward to meeting you all on the 8th of August"
  },
  {
    "objectID": "prepare/install-tools.html",
    "href": "prepare/install-tools.html",
    "title": "Install tools",
    "section": "",
    "text": "For this course you will need access to a machine with an installation of R, Git, RStudio and some important R packages, including, of course, mizer itself and mizerExperimental. Below we give the necessary information to allow you to install these tools.\nIf you run into difficulties, please make a post in the Comments section below. It is quite likely that someone else on the course has encountered similar difficulties and that someone has ideas on how to solve them.\nIf you already have some of these tools installed, please make sure that the version you have is recent."
  },
  {
    "objectID": "prepare/install-tools.html#r",
    "href": "prepare/install-tools.html#r",
    "title": "Install tools",
    "section": "R",
    "text": "R\nMizer is compatible with R versions 3.1 and later. However in this course we will assume that you have a version newer than 4.0. So if you are still using 3.x, now is the time to upgrade. You can install or upgrade R on your computer by following the instructions at https://cran.r-project.org/ for your particular platform. In fact, upgrading follows the same procedure as installing from scratch.\nAlternatively, if you can not or do not want to install R on your computer, you can also work with R and RStudio in your internet browser by creating yourself a free account at https://rstudio.cloud. There you can then install mizer as described above. Running mizer in the RStudio Cloud may be slightly slower than running it locally on your machine, but the speed is usually quite acceptable."
  },
  {
    "objectID": "prepare/install-tools.html#rstudio",
    "href": "prepare/install-tools.html#rstudio",
    "title": "Install tools",
    "section": "RStudio",
    "text": "RStudio\nThis course assumes that you will be using RStudio to work with R. There is really no reason not to use RStudio and it makes a lot of things much easier.\nRStudio develops rapidly and adds useful features all the time and so it is best if you install the latest version. This course was written with version 2022.07.0+548. If you already have RStudio installed but it is an older version, the way to upgrade is to just install the newest version. The old version will automatically be replaced by the new.\nIf you are new to RStudio, the video on the RStudio IDE homepage is well worth watching."
  },
  {
    "objectID": "prepare/install-tools.html#r-packages",
    "href": "prepare/install-tools.html#r-packages",
    "title": "Install tools",
    "section": "R Packages",
    "text": "R Packages\nR packages extend the functionality of R. mizer itself is such an R package. There is a central repository for R packages called CRAN which hosts all of the packages needed for this course, except for the mizerExperimental and mizerMR packages. To install them on your computer just start RStudio and then in the console issue the command\n\ninstall.packages(c(\"mizer\", \"tidyverse\", \"plotly\", \"remotes\", \"usethis\",\n                   \"rmarkdown\", \"rstudioapi\"))\n\nThe mizerExperimental package is for code that is still experimental and thus changes frequently. Therefore it is hosted in a GitHub repository. You install it with\n\nremotes::install_github(\"sizespectrum/mizerExperimental\")\n\nThe mizerMR package that extends mizer to work with multiple resources has not been released to CRAN because the plan is to incorporate it into core mizer in the future, so this too you need to install directly from GitHub.\n\nremotes::install_github(\"sizespectrum/mizerMR\")"
  },
  {
    "objectID": "prepare/install-tools.html#git",
    "href": "prepare/install-tools.html#git",
    "title": "Install tools",
    "section": "Git",
    "text": "Git\nGit is a distributed version control system that we will use in this course. We will discuss that more on the page Use Git and GitHub.\nGit may already be installed on your system. If you are in RStudio, then you can issue the following command in the “Terminal” tab:\ngit --version\nIf that comes back with a version number, then git is already installed. The current Git version is 2.25.1. If you have an older version then keep this in mind and if you should at some point notice that Git is not behaving the same for you as for others, then you might want to install the latest version. Or simply install the latest version now to be on the safe side.\nTo install Git follow the links at https://git-scm.com/downloads for your operating system. You do not need a GUI client for Git because you will be using Git from within RStudio. After you have installed Git, you may want to restart RStudio.\nFinally, you should tell Git about yourself by running the following command in the RStudio Console, where of course you change the name and email address to your own:\n\nusethis::use_git_config(user.name = \"Jane Doe\", \n                        user.email = \"jane@example.org\")"
  },
  {
    "objectID": "prepare/install-tools.html#issues",
    "href": "prepare/install-tools.html#issues",
    "title": "Install tools",
    "section": "Issues",
    "text": "Issues\nAs with all computer-related things, unexpected problems are likely to crop up. Be sure to post about them below. Alternatively you can also report issues by clicking on the “Report an issue” link that you find at the bottom of the right side-bar. That will create an entry in the GitHub issue tracker.\nIf you have a correction to this page or want to suggest an edit, use the “Edit this page” link. Don’t worry: we will need to approve your edits before they go live, so you can feel free to edit as much as you like.\nThis course should be a collaborative experience. You will find the “Edit this page” and “Report an issue” links on every tutorial page and you will find a comments section on every page of the course website. Never hesitate to use them."
  },
  {
    "objectID": "prepare/introduce-yourself.html",
    "href": "prepare/introduce-yourself.html",
    "title": "Introduce yourself",
    "section": "",
    "text": "When you post a comment you will be asked to log in to GitHub. You will probably already have an account on GitHub. If not, please create one for yourself. You will need it to participate in this course. The page Use Git and GitHub explains how we will use GitHub in this course.\nYou can use Markdown syntax in your post. For example to see how to include a link to your homepage, see the section on Links.\nThe comments you post on this course website will also appear in the Comments section of the GitHub discussions for the course repository. Even after posting a comment you can go and edit the post on GitHub and it will be updated on this website as well.\nThe comments are threaded discussions. Please post your introduction as a new comment rather than as a reply to someone else’s introduction. You can use the replies if you want to respond to someone’s introduction for follow-ups."
  },
  {
    "objectID": "prepare/watch-introduction.html",
    "href": "prepare/watch-introduction.html",
    "title": "Introduction to the mizer model",
    "section": "",
    "text": "Ken Andersen talks about the basic ideas underlying dynamic size-spectrum modelling with mizer."
  },
  {
    "objectID": "prepare/watch-introduction.html#in-preparation",
    "href": "prepare/watch-introduction.html#in-preparation",
    "title": "Introduction to the mizer model",
    "section": "In preparation",
    "text": "In preparation"
  }
]