---
title: "Using a model to explore fishing scenarios"
---

## Introduction

Mizer is a tool that can be used to simulate a dynamic size spectrum in a marine ecosystem, subject to changes through time, such as fishing pressure. It is a dynamic multi species model with emergent growth, reproduction and biomass, so it allows us to better understand how changes in fishing mortality can affect the entire ecosystem. Mizer allows complicated setup of multiple fishing gears and selectivities, but we will start with a few simple explorations and give references for further reading to users who want to explore more.

Let's explore some examples of what can be done using a previously calibrated mizer model for the Curonian lagoon. We will load the model from our previous tutorial where we tuned reproduction level of each species and returned gear selectivity to the original Curonian lagoon gear.

```{r set-up}
#| message: false
#| warning: false
remotes::install_github("sizespectrum/mizerExperimental", ref = "tuneMR")
library(mizerExperimental)
remotes::install_github("sizespectrum/mizerMR")
library(mizerMR)
library(tidyverse)

# Load tuned model with original selectivity
cur_model <- readParams("cmg_Tuned.rds")
```

In the previous tutorials we have been focused on the steady state. Now we are ready to make changes through time, which means that the ecosystem will move away from the tuned steady state.

Note!

There are two ways how we could explore scenarios. The first one is to use our existing calibrated model as a starting point, impose new conditions, run to equilibrium and compare the new equilibrium state to the previous equilibrium state. This is how many modelling studies are done. The second way is to impose time series of changes, when change in conditions happens slowly over a certain time. In this second case we would be interested in transient dynamics, or time series of change. So we would analyse how conditions change through time. The first way is easier and more common in modelling studies, because it is more defensible to compare to steady states of a system. But both can be applied and have been used in various examples, as you have heard in Julia Blanchard's lecture.

## Option 1: Change fishing effort

The first option most users want to explore is to see what happens if we start fishing more or if we reduce fishing mortality. We will use our Curonian model with tuned reproduction and change total effort. We will run both models (same effort and increased effort) to steady state and compare. Whenever we are saving simulations (with time dimension) we will use sim_ in object names, to separate them from params objects


```{r, code_folding=TRUE}
#remind ourselves of the initial effort 
initial_effort(cur_model)

#run to steady with same effort - it should not take any time, because the model is already at steady, but just in case
sim_cur_model_sameFishing <- projectToSteady(cur_model, effort = 0.3, return_sim = T, t_max = 100, dt = 0.1)

#double the effort, which will double fishing mortality on all species 
sim_cur_model_doubleEffort <- projectToSteady(cur_model, effort = 0.6, return_sim = T, t_max = 100, dt = 0.1)
```

Alternatively we could have used project() and tell mizer for how many years we want to run it, usually 20-50 years to ensure the system settles into a new equilibrium. 

```{r}
sim_cur_model_doubleEffort2 <- project(cur_model, effort = 0.6, t_max = 100, dt = 0.1)

```

But you will notice that this takes longer, since we really only needed to run for 16.5 years and we didn't know that in advance. This is why projectToSteady() is very useful. 

Now we want to check what happened when we doubled the effort. We can simply plot the main diagnostic plot

```{r}

plot(sim_cur_model_doubleEffort)
```

This shows some changes in species biomasses in the first year, once new effort was applied. It also shows that fishing mortality on fully recruited individuals of roach (pink lines) is very high, but remember due to the selectivity and maturity parameters for this species, we are only fishing largest individuals from this population. 

We can also just calculate the ratio of relative biomases and yields in equilibrium conditions. 

```{r}
#compare final biomasses 
getBiomass(sim_cur_model_doubleEffort)[idxFinalT(sim_cur_model_doubleEffort), ] / getBiomass(sim_cur_model_sameFishing)[idxFinalT(sim_cur_model_sameFishing), ]
#here the subscript [idxFinalT(cur_model_doubleEffort), ] just tells to use the last value in the time x species biomass data frame 

#compare final yield - are we actually getting more catch? 
getYield(sim_cur_model_doubleEffort)[idxFinalT(sim_cur_model_doubleEffort), ] / getYield(sim_cur_model_sameFishing)[idxFinalT(sim_cur_model_sameFishing), ]
```

We can see that, surprisingly, after doubling fishing effort on all species biomasses of breams, roach, perch and carassius increased rather than decreased! And yields for most species increased, when effort was doubled. We get NaN for small fish, because its catchability is set to 0, so clearly we don't get any yield. 

The predator_fish is not doing well. Let's see how the spectra have changed, after all mizer is all about changes at different sizes. We will first save the last timestep of each simulation run as a params object and use plotSpectra2() function

```{r}

p_doubleEffort <- setInitialValues(sim_cur_model_doubleEffort@params, sim_cur_model_doubleEffort)
p_sameFishing <- setInitialValues(sim_cur_model_sameFishing@params, sim_cur_model_sameFishing)

plotSpectra2(p_doubleEffort, 'double', p_sameFishing, 'same')

```

We can see that doubling fishing mortality on all species, decreased predator_fish abundance at all sizes, but for pikeperch only the largest sizes are affected. 

Let's see what happens if we triple the effort on all species. 

```{r}
#increase the fishing even more 
sim_cur_model_tripleEffort <- projectToSteady(cur_model, effort = 0.9, return_sim = T, t_max = 100, dt = 0.1)

#compare final biomasses 
getBiomass(sim_cur_model_tripleEffort)[idxFinalT(sim_cur_model_tripleEffort), ] / getBiomass(sim_cur_model_sameFishing)[idxFinalT(sim_cur_model_sameFishing), ]

#compare final yield - are we actually getting more catch? 
getYield(sim_cur_model_tripleEffort)[idxFinalT(sim_cur_model_tripleEffort), ] / getYield(sim_cur_model_sameFishing)[idxFinalT(sim_cur_model_sameFishing), ]

p_tripleEffort <- setInitialValues(sim_cur_model_tripleEffort@params, sim_cur_model_tripleEffort)

plotSpectra2(p_tripleEffort, 'triple', p_sameFishing, 'same')

```

Now the change is even more evident. And by tripling the effort on all species we greatly increased the yield of perch and even pikeperch, but almost completely crashed the predato_fish. 

Exercise 1 - TODO - finalise setting it up. 
Use your calibrated parameter file, double and then triple fishing effort on all species, save results and commit the file 


## Option 2: change fishing on one species only 

Previously we saw that when effort changed on all species it was impossible to know what is driving change in total biomasses and yields - fishing or species interactions. Clearly, it was both, since in a single species model we would not get more biomass with increased fishing mortality. But to separate this effect better, let's now try to change fishing on one species only and we will do that on pikeperch. Let's increase its fishing mortality and see that affects the ecosystems. We will do that by changing the catchability parameter in the gear_params dataframe. 

```{r}
#save gear params with a new name
fishMorePikeprech <- gear_params(cur_model)

#check catchability of pikeperch (species 8)
fishMorePikeprech$catchability[8]

#and replace it with higher value. Let's triple the mortality to really see the change
fishMorePikeprech$catchability[8] <- 3

#assign our main cur_model params object to a new one 
cur_model_fishPikeperch <- cur_model
#update its gear parameters 
gear_params(cur_model_fishPikeperch) <- fishMorePikeprech
#check 
gear_params(cur_model_fishPikeperch) 

```

Now let's project with same overall effort and see what happens. We will run it with the same overall effort of 0.3, but since pikeperch catchability has changed it will be fished more 

```{r}
#increase the fishing even more 
sim_cur_model_Pikeperch <- projectToSteady(cur_model_fishPikeperch, effort = 0.3, return_sim = T, t_max = 100, dt = 0.1)

#check the biomass change
plotlyBiomass(sim_cur_model_Pikeperch)

#compare final biomasses 
getBiomass(sim_cur_model_Pikeperch)[idxFinalT(sim_cur_model_Pikeperch), ] / getBiomass(sim_cur_model_sameFishing)[idxFinalT(sim_cur_model_sameFishing), ]

#compare final yield
getYield(sim_cur_model_Pikeperch)[idxFinalT(sim_cur_model_Pikeperch), ] / getYield(sim_cur_model_sameFishing)[idxFinalT(sim_cur_model_sameFishing), ]

```

We can see that just by changing fishing mortality on one important species, we have triggered a trophic cascade and changed biomases and yields of all other species. In fact by fishing pikeperch more intensively, we increased yields on all other species (for the same fishing mortality). Even other predatory species (predator_fish, burbot) increased, when pikeperch decreased. 

Exercice 2
Now use your calibrated model and increase triple fishing mortality on pikeperch. Save and commit the result. 
Do the same but now triple fishing mortality on perch. Save and comit the result. 

## Option 3: Increase gear mesh size

One common policy in fisheries management is to increase mesh sizes of commercial gears, with the goal of protecting young fish and decreasing overall impact on the stock. Let's see how this can work in a multi-species ecosystem. Our fisheries managers are concerned about predator_fish and increased minimum size limit for this species. This we can achieve by changing it's gear selectivity and projecting with the same effort 

```{r}

#make a new params object 
cur_model_sel <- cur_model
#check current gear selecitvity for predator_fish 
gear_params(cur_model_sel)[10, ]
#or if we don't want to remember species numbers we can use 
gear_params(cur_model_sel)["predator_fish, Main", ]
#here "Main" means the main gear, because mizer can have multiple gears

#We will increase L50 for this species from 30 to 40 and keep the slope of size selectivity same (3 cm difference betweet L50 and L25)
gear_params(cur_model_sel)["predator_fish, Main", "l50"] <- 40
gear_params(cur_model_sel)["predator_fish, Main", "l25"] <- 37

#now we will project with the same fishing effort 
sim_cur_model_largerMesh <- projectToSteady(cur_model_sel, effort = 0.3, return_sim = T, t_max = 100, dt = 0.1)

#compare final biomasses and yields 
getBiomass(sim_cur_model_largerMesh)[idxFinalT(sim_cur_model_largerMesh), ] / getBiomass(sim_cur_model_sameFishing)[idxFinalT(sim_cur_model_sameFishing), ]
getYield(sim_cur_model_largerMesh)[idxFinalT(sim_cur_model_largerMesh), ] / getYield(sim_cur_model_sameFishing)[idxFinalT(sim_cur_model_sameFishing), ]

# TODO we need a function to plot proportional change in yield
#plotYield(sim)

```

We can see that by increasing gear selectivity but keeping the same effort, we increased biomasss and yields. So both managers and fishers should be happy. Effect on other species yield is negligible (and mostly positive), but pikeperch biomass decreased. You can now also play with changing size selectivities in your model and see which species react strongly, and which don't. How does it affect other species in the ecosystem? 

## Option 4: Protecting large fish 

Another management option that we often hear about is protecting largest fish from fishing. We can implement it in our model by changing selectivity curves from logistic to dome-shaped or double_sigmoid. This will reduce selectivity on largest individuals and will only select intermediate sized fish (if we set selectivity parameters properly). We will do that for all species, but this could also be set for one species. 

```{r}
#save new dataframe for gear parameters 
(gear_double_sigmoid <- gear_params(cur_model))

# change all selectivity curves to double sigmoid (changing trawling to gillneting)
gear_double_sigmoid$sel_func <- "double_sigmoid_length"

#set the right side of selectivity - i.e. midpoint of decreasing selectivity part, curve to 1.5 of the size at the left side
gear_double_sigmoid$l50_right <- gear_double_sigmoid$l50 * 1.5
#and the slope at 2cm difference
gear_double_sigmoid$l25_right <- gear_double_sigmoid$l50_right + 2

#check 
gear_double_sigmoid
```

Now we will save a new parameter object and assign the newly made gear params to it

```{r}
#create new params object
cur_model_gillnet <- cur_model

gear_params(cur_model_gillnet) <- gear_double_sigmoid

#check how the selectivity curves look 
plotFMort(cur_model_gillnet)
```


#now we will project with the same fishing effort 
```{r}
sim_cur_model_gillnet <- projectToSteady(cur_model_gillnet, effort = 0.3, return_sim = T, t_max = 100, dt = 0.1)
```

```{r}
sim_cur_model_gillnet <- project(cur_model_gillnet, effort = 0.3, t_max = 100, dt = 0.1)
plot(sim_cur_model_gillnet)


#compare final biomasses and yields 
getBiomass(sim_cur_model_largerMesh)[idxFinalT(sim_cur_model_largerMesh), ] / getBiomass(sim_cur_model_sameFishing)[idxFinalT(sim_cur_model_sameFishing), ]
getYield(sim_cur_model_largerMesh)[idxFinalT(sim_cur_model_largerMesh), ] / getYield(sim_cur_model_sameFishing)[idxFinalT(sim_cur_model_sameFishing), ]

```

Gustav, I am not sure I follow these Julia's examples below. The data and model do not seem to match and I am not sure what we are supposed to learn. It would be good to include effort or catch time series, but I am not entirely sure how to do it. I do have catch series for the Curonian lagoon, so we could use that. But what do we get from it? Can we have an option of projecting with effort decreasing every year. This is what management often does. We want to see how quickly biomases and yields will recover. 

###


For this example, will start with the toothfish model but as always you can you your own model or the curonian lagoon for the exercises.

## Fishing through time

In the previous tutorial, we examined a simple longline fishery that consists of targeting a single species (toothfish, here referred to as *D.ele*). However, all of the parameters for fishing were fixed through time. Mizer can also be used to carry out projections with changes in fishing effort.

We will start by reading in a time series of catch and effort.

```{r, code_folding=TRUE}
# read in model sim object
sim <- readRDS("toothfish/params10.RDS")
params <- sim@params

# read in fishing data (note: these are not really correct values, they are only for illustration in this example) 

dat<-readRDS("toothfish/longline.rds")

plot_dat <- reshape2::melt(dat, "Year")
ggplot(plot_dat, aes(x = Year, y = value)) +
  geom_point() +
  facet_wrap(~variable, nrow = 2, scales = "free")


```

We can see from the data that there have been big changes in effort and catches through time. The first plot shows relative effort per area (note: these data are not correct and are only being used for illustration in this example). Catches are in tonnes per square km fished.

Previously we assumed effort was 1 and we worked with catchability as the variable. Real effort data can come in all sorts of different units (hours or days fished, kilowatt days, number of vessels all per unit time). The key to using this in our model is that the catchability is the fraction of the available (that is also selected by the gear) stock caught per unit of any effort that is included.

Often, we have used fishing mortality rates from stock assessment to drive changes in effort through time, assuming Q\*E = F at maximally selected sizes (as in [this](https://besjournals.onlinelibrary.wiley.com/doi/10.1111/1365-2664.12238) paper and others). But in many cases this information is not available. It also could be misleading as those fishing mortality rates are estimated using very different single-species models (but sometimes that is the best we have to work with, and as with all of the assumptions we make the limitations just need to be clear).

How do we incorporate the effort data into the model? First, we have to re-arrange the data so it can be read into the *param* object.

```{r, code_folding=TRUE}
species_params(params)

effort_time <-array(c(rep(0,13),dat$EffortPerArea), dim = c(length(1990:2020),1),dimnames = list("time" = 1990:2020, "gear" = params@gear_params$gear[1]))

```

Next we use the effort data to project the model forwards from it's steady state. But wait - we did not set up the model for the first year of the data, when fishing only just began. It may make more sense to use a steady state without fishing as the initial values for our projection.

```{r, code_folding=TRUE}
sim0 <- projectToSteady(params, effort = 0, return_sim = TRUE, t_max = 200)
params<-setInitialValues(params,sim0)


simf <- project(params, effort = effort_time)

yieldplot<-plotYieldGear(simf)

yieldcompare<-yieldplot+ geom_point(data = dat, shape = 1, size = 1, mapping = aes(x=Year, y= CatchPerArea))
yieldcompare


```

Here we can see that the modeled catch time series fall within the scatter of the observed catch data (reassuring), but the trends are different. It seems there is a sharp decline in modeled catches towards the end of the time series. While we should not expect the exact up and down fluctuations to be captured by our model (we don't have anything forcing the changes through time other than fishing!), we can examine how changing the reproduction parameters affects how well the model captures stock decline (and later, recovery), relative to the trends in the data.

We can look at this below by changing the reproduction level and seeing what the levels of sustainable fishing mortality the equilibrium yield vs F curves suggest for different assumptions (where the peak occurs we could consider a proxy for single-species *Fmsy*) .

```{r,code_folding=T, echo=F,warning=FALSE}
params2<- setBevertonHolt(params, reproduction_level = 0.2)

sim02 <- projectToSteady(params2, effort = 0, return_sim = TRUE, t_max = 200)

plotYieldVsF(params2,species="D.ele")
plotYieldVsF(params,species="D.ele")
```

Next, let's compare what happens when when use these new parameter in our dynamical fishing runs.

```{r}
params2<-setInitialValues(params2,sim02)
simf2 <- project(params2, effort = effort_time)

yieldplot2<-plotYieldGear(simf2)

yieldcompare2<-yieldplot2+ geom_point(data = dat, shape = 1, size = 1, mapping = aes(x=Year, y= CatchPerArea))
yieldcompare2


```

These two plots look almost exactly the same. How do you interpret this? Remember think about the relationship between the fishing parameters in the model (e.g. F = Q\*E). We didn't change these parameters, so they should be the same in both simulations and we can check them below:

```{r}
plotFMort(simf2)
```

### Exercise:

Examine how catch time series changes relative to the data if the reproduction parameters change. Is this consistent with what you expected from the steady state yield curves? How do the biomasses change under these different scenarios?

## Catch only exploration

What if there was no effort data only catch ? This is the case for many data-poor fisheries or for fisheries where there is only restricted access to effort data.

Many fisheries develop through time according to phases: an exponential growth period, following either a peak and subsequent decline and a plateau, if stocks drop below sustainable levels and management kicks in (see [here](https://www.pnas.org/doi/abs/10.1073/pnas.1820344116) for example). These different types of development can be represented by a function, *effort_dynamics*(), and can be used to help estimate the fishing parameters given the the model parameters and data you may have. This is the approach used [here](https://www.pnas.org/doi/full/10.1073/pnas.1612722114). Here, we will use this function to explore effort through time.

```{r,code_folding=TRUE}
# should I move to helper_functions or leave it in?

effort_dynamics<-function(effort_array, gear="longline",time=1990:2020,Fmax=1.5,steepness=0.2,midpoint=2005){

effort_array[,gear]<-Fmax/(1+ exp(-steepness*(time - midpoint)))

return(effort_array)
}


```

After using the above function we can scale the effort up to the effort units we used in our base model. We do this by setting the Fmax in the logistic equation to the desired level of Fishing Mortality Rate (e.g. 0.005 was used above but for this example we will plug in a different value here to explore heavier fishing). We then divide Fmax by our estimated catchability coefficient (which was estimated to be a very small number) to get effort in the correct ballpark and units as the data we used above. If you want to run the model directly with fishing mortality rate as the "effort" driver you would need to set the catchability coefficient to 1 in this example. If no effort exists for your system, we would need to estimate the catchability coefficient (either by hand tuning or statistical time-series fitting. We discuss the latter in the mizerHowTo package, and this \[*blog* JULIA TO ADD\], if you are interested in taking this further).

```{r}
neweffort<-effort_dynamics(effort_time,time=1990:2020,Fmax=0.5,steepness=0.9,midpoint=2005)

#rescale to get effort in same units as our example
neweffort<-neweffort/gear_params(params)$catchability[1]

# or if you want to just use fishing mortality only in your model, overwrite the catchability to 1:
# gear_params(params)$catchability[1]<-1

year=1990:2020
plot(year,neweffort,typ="l")
```

Now you can run the same model above using this effort.

```{r}
params3<-setInitialValues(params2,sim02)
simf3 <- project(params3, effort = neweffort)

yieldplot3<-plotYieldGear(simf3)

yieldcompare3<-yieldplot3+ geom_point(data = dat, shape = 1, size = 1, mapping = aes(x=Year, y= CatchPerArea)) + xlim(2000,2020) 
yieldcompare3


plotBiomass(simf3)

# let's save the output for our next tutorial

saveRDS(simf3,"simf3.rds")


```

We can see here at a fixed level of Fmax=0.5 through time catches initially increase, reach a peak around 2006 and then decline. The biomass trajectories also show that toothfish starts declining slightly before this.

### Exercise

What is the lowest level of Fmax you can find that causes toothfish catches to decline? Use the code above to change Fmax to determine this. Is this consistent with the knowledge from the equilibrium yield curves (sensitivity to fishing tutorial)?

### Exercise

Set up a bycatch on another the other species in the model. This can be done using the same gear (and effort) but changing the catchability of some of the other species (currently everything is set to zero except for toothfish). Hint: you can use the ?gear_params function to modify these values.

## Summary

\[in prep\]

If you are interested in how to statistically fit models to time series data the mizerHowTo package discusses this (still in preparation).

Next we will investigate dynamical changes in environment, with a focus on changes in resource abundance and size structure.
