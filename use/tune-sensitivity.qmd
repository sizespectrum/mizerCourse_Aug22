---
title: "Tune reproduction sensitivity"
---

## Introduction

In the tutorial x of week 1 we briefly looked at how density dependence of reproduction, or the so called reproduction level, can influence how species react to changes in mortality, such as from fishing. It might be good if you go back to this tutorial and remind yourself about two parameters that will affect reproduction level. They are $R_max$ and $erepro$. $R_max$ sets the maximum amount of eggs or larvae (individuals in the first size class) that can recruit in the system, where $erepro$ defines the slope of how egg production scales with the energy invested in reproduction (which depends on the spawning stock biomass and their energy intake).

**Important! What is recruitment?**

In fisheries, the term 'recruitment' usually refers to the numbers of fish that recruit into fishery, which will depend on egg production, early density dependence, growth, early mortality and gear selectivity. In mizer we often use the term 'recruitment' to describe the number of individuals that enter the first size class in the model. This number will depend on the energy invested into reproduction and density dependence parameters $R_max$ and $erepro$. So please be aware of this difference, and remember that here recruitment means numbers in the first size class.

When we built our models in week 2 we were not concerned about the reproduction level and we kept the recruitment independent from energy invested into reproduction. The steady() function used in week 2 didn't care about setting realistic reproduction levels for the species. It is important to understand that by modifying $R_max$ and $erepro$ we can change the reproduction level - point along the density dependence curve that the species is - without changing biomass at steady state.

But because reproduction level will affect how species react to fishing, we now need to work on this aspect of the model. So let's look first at the reproduction levels of our species. As usual we load mizerExperimental, mizerMR and get additional code for improved yield curve functions.

```{r}
#| message: false
remotes::install_github("sizespectrum/mizerExperimental", ref = "tuneMR")
remotes::install_github("sizespectrum/mizerMR")
# TODO: move this to mizerExperimental
source("../experiment/getFCurves.R")
library(mizerExperimental)
library(mizerMR)
library(tidyverse)
```

### Steady state models will not be steady once conditions change

We load our final steady state model that we saved after playing with the tuneParams() gadget. We will run this model to steady() just to make sure resources are as expected (you don't need to get into details of this). We will use two models that Asta and Gustav independently tuned with the tuneParams() gadget.

```{r}
cur_model_asta <- readParams("../use/cur_model_asta.rds")
cur_model_gustav <- readParams("../build/cur_model_refined.rds")

#run to new steady level. We will abbreviate the two models as cma (curronian model asta) and cmg 
cma <- cur_model_asta |> steady()
cmg <- cur_model_gustav |> steady()

```

Let's first check that steady state models are indeed steady under same conditions. If we run project() with exactly same conditions biomasses should stay stable.

```{r}
initial_effort(cma)
initial_effort(cmg)
```

During the tuning we might have adjusted the overall effort, so when projecting we will use this effort. Then we will project both models for 50 years using the same effort and plot their biomasses

```{r}
sim_cma <- project(cma, effort = 0.5, t_max = 50, dt = 0.1)
plotBiomass(sim_cma)
#everything looks reasonably stable

sim_cmg <- project(cmg, effort = 0.3, t_max = 50, dt = 0.1)
plotBiomass(sim_cmg)
```

Let's check how different the biomases are in the two calibrations (how closely they were matched to observed biomasses)

```{r}
getBiomass(sim_cmg)[51,]/getBiomass(sim_cma)[51,]

```

However, steady state models are not necessarily steady if conditions change. This will depend on how we set up reproduction level and density dependence of recruitment. Let's look at reproduction levels of our steady state models.

```{r}
getReproductionLevel(cma)
getReproductionLevel(cmg)

```

For some species these reproduction levels don't look reasonable at all. They are extremely low, suggesting that recruitment will completely depend on species biomass. If there is small change in biomass, recruitment will decrease, that will lead to less biomass, less recruitment and so on. We want that when we change fishign effort in our models, species should settle into a new equilibrium. If this does not happen, the density dependence does not work very well. To test it we will change the effort and run the models for a little longer

```{r}
#decrease effort from 0.5 to 0.3 and run for a little longer
sim_cma <- project(cma, effort = 0.3, t_max = 100, dt = 0.1)
plotBiomass(sim_cma)

#increase effort from 0.3 to 0.5
sim_cmg <- project(cmg, effort = 0.5, t_max = 100, dt = 0.1)
plotBiomass(sim_cmg)

```

Yes, as expected biomasses keep changing over time and do not settle into a new equilibrium. Let's try to fix it.

## What should the sensitivity to fishing be?

We will need to tune reproduction level of each species to make sure that their response to fishing is reasonable. How do we know what is reasonable? It is not a straightforward question. We can start by consulting general fisheries models. You can read about the principles of basic fisheries surplus production models in this excellent book by Malcolm Haddon "[Using R for Modelling and Quantitative Methods in Fisheries](https://haddonm.github.io/URMQMF/surplus-production-models.html)". In these models population resilience is defined by the maximum population growth rate ***r*** (which is NOT the same as r_max used in mizer). Under the standard assumptions about density dependence (Schaeffer models) maximum sustainable yield (MSY) is expected at 0.5 of unfished stock biomass and it can be estimated as r/4 proportion of of unfished biomass. For example, if r =0.5 and unfished biomass is 1000 tons, MSY is 125 tons. Similarly, proportional harvest rate (proportion of population that can be removed each year) to give MSY is estimated as r/2, which for the case of r= 0.5, would be at 0.25. Note, that this is a proportional harvest rate which is not the same as instantaneous harvest rate in fisheries models and not the same as instantaneous mortality rate used in mizer, but is close enough for values \<0.5). We usually do not know population growth rates (r) for our species, but we can also look up expectations and estimates in FishBase life-history tool section. Or we can use [generic estimates](https://studylib.net/doc/5888624/doc---fishbase) which suggest r of 0.6-1.5 for high resilience species (Von Bertalanffy growth rate K\>0.3, maturation age \< 1, high fecundity) and r of 0.2-1 for medium resilience species (see below).

![](/images/PopGrowthRates.png)

Of course these values are derived from single species models with very different assumptions to those of ours, so they can only be used as very general guides. Also remember again that proportional fishing mortality rates are NOT the same as mizer rates in a steady state population, especially when they are \> 0.7 or more.

Alternatively, we can also use Ken Andersen's book and expectations for species with different w_inf values, as estimated from trait-based models (all species parameters, except for w_inf) are identical) and when all species are fished with 50% selectivity at 5% of their w_inf. The panels below represents species with different asymptotic sizes: 333 g (top), 10 g (bottom left), and 10 kg (bottom right). The lines show yield (black lines), yield per recruit (dashed lines), spawning stock biomass (dark gray lines), and recruitment (light gray lines), all scaled by their maximum value. We will not deal with yield per recruit, so ignore the dashed lines. This figure shows that highest yields are expected at instantaneous fishing mortality of about 0.3-0.5/year.

![](/images/ReferencePointCurves.png)

We can aim to achieve that in our models.

## Tuning sensitivity to fishing

Let's explore how changing reproduction levels will change our species sensitivity to fishing. But for this exploration we will set gear parameters in such a way that all species are fished similarly. This is because our current gear parameters are set for a specific commerical fishery, which selects some species, but does not catch smallfish or almost no ruffe, for smaller fish they target only adults and for largest fish they also target juveniles. Catchabilities also differ a lot.

```{r}
gear_params(cmg)
```

To tune sensitivity of each species to extra mortality we will set catchability of all species to 1, so that effort values directly reflect fishing mortality. We will also set gear 50% selectivity to maturation length of each species and 25% selection to 25% maturation length.

If you do have system specific data on how changes in fishing under system specific gear parameters change species biomasses, you should use these system specific details. We do not have such data for Curonian Lagoon, so we will explore species responses in general.

### Setting gear selectivity

Gear selectivity parameters are defined by length, so we will first convert w_mat and w_mat25 to length values.

```{r}
#calculate L_mat for all species
(L_mat = (species_params(cma)$w_mat/species_params(cma)$a)^(1/species_params(cma)$b))
#calculate L_mat25 for all species
(L_25mat = (species_params(cma)$w_mat25/species_params(cma)$a)^(1/species_params(cma)$b))

#Mizer is set in such way that we need to provide all gear parameters at once, so we first set a gear dataframe and then give it to mizer. 
#take gear parameters from the current model
(gp <- gear_params(cma))
#update L50 selectivity with new values
gp$l50 <- L_mat
#update L25 selectivity with new values
gp$l25 <- L_25mat
#set all catchability to 1
gp$catchability <-1
```

We will assign these gear parameters for our parameterised model, but for simplicity we will use only one model.

```{r}

#assign the model to a new variable, so that we can keep both
cmg_newGear <- cmg
#set new gear parameters for the new model 
(gear_params(cmg_newGear) <- gp)

#as we change gear parameters we need to bring the model to steady again 
cmg_newGear <- steady(cmg_newGear)

#assess whether the model with new gear params is stable and not in fluctuating dynamics
sim_cmg_NewGear <- project(cmg_newGear, effort = 0.3, t_max = 100, dt = 0.1)
plotBiomass(sim_cmg_NewGear)
#good enough 

```

We saw previously that reproduction levels in our species were not very sensible. So we need to decide what reproduction level we should set to start our tuning. Remember when we change species reproduction level we do not change the overall biomass in the steady state (black circle in the figure below), but only the shape of recruitment curves and how quickly they reach the maximum.

TODO: add that plot

For now we will follow [Jacobsen et al. 2016](https://onlinelibrary.wiley.com/doi/full/10.1111/faf.12171) approach and assume the $erepro$ parameter for all species is the same. Once we modify erepro for all species, the reproduction level and Rmax will be adjusted to keep the steady state biomass the same. We can do that with setBevertonHolt() function as we briefly learned in week 1. After some experimentation we found that erepro of 0.002 gives reasonable reproduction levels. You can play with different erepro values for your models.

```{r}
cmg_newGear <- setBevertonHolt(cmg_newGear, erepro = 0.002)
#let's check what reproduction was set
getReproductionLevel(cmg_newGear)
#and look at species reproduction parameters 
species_params(cmg_newGear)[, c("erepro", "R_max")]

```

Remember, reproduction level is the ratio between RDD and Rmax and can vary between 0 and 1. It tells us how close the actual reproduction (after applying density dependence) is to the theoretical maximum, set by R_max. We can check this ratio

```{r}
#how close the RDD (actual recruitment, after applying density dependence) is to Rmax? This is the same as reproduction level 
getRDD(cmg_newGear)/species_params(cmg_newGear)$R_max
```

We can also look how close the actual reproduction is to the physiological reproduction - reproduction level produced by the model species, after accounting for the food intake and growth rates, but before applying density dependence (RDI)

```{r}
getRDD(cmg_newGear)/getRDI(cmg_newGear)

```

This tells us that most species can produce a huge amount more, but this reproduction is strongly capped by the R_max parameter we have (maximum recruitment possible in the system).

## Exploring F curves: one species at a time

To set reproduction level to the reasonable levels and get reasonable response to fishing, we will apply a range of fishing mortalities to one species at a time and check how their yields, biomasses (SSB), RDD and RDI will change. We can use a handy function plotFCurves(). If you want to save the resulting dataframe you can use getFCurves(). Let's start with breams

```{r}
#get the list of species to remind ourselves
species_params(cmg_newGear)$species

#what is the reproduction level of breams
getReproductionLevel(cmg_newGear)[3]

#plot F curves for this species. We will project with different fishing mortalities, up to a maximum of 1. 
plotFCurves(cmg_newGear, species = "breams", F_max = 1, no_steps = 20)
```

The yield curve (dashed line) does not taper down even at fishing mortality as high as 1, so we want to decrease reproduction level 

```{r}
#first we save current reproduction level into a vector 
rep_level <- getReproductionLevel(cmg_newGear)

#replace our species reproduction level with a new value 
rep_level[3] <- 0.85

#asign it back to the model 
cmg_newGear <- setBevertonHolt(cmg_newGear, reproduction_level = rep_level)

#check that it worked 
getReproductionLevel(cmg_newGear)

#and plot F curves again
plotFCurves(cmg_newGear, species = "breams", F_max = 1, no_steps = 20)
```

Now we repeat the same for another species. Let's take pikeperch (it is species 8)

```{r}
#check its reproduction level, plot yield curve, adjust, check, plot again. Repeat until the yield curves look reasonable
getReproductionLevel(cmg_newGear)[8]
plotFCurves(cmg_newGear, species = "pikeperch", F_max = 1, no_steps = 20)
rep_level[8] <- 0.75
cmg_newGear <- setBevertonHolt(cmg_newGear, reproduction_level = rep_level)
getReproductionLevel(cmg_newGear)
plotFCurves(cmg_newGear, species = "pikeperch", F_max = 1, no_steps = 20)

```

Once we are happy with all the species, we save the parameter file

```{r}
#we can assign it to a new name (tuned), so it is easier to remember
cmg_newGearTuned <- cmg_newGear
saveParams(cmg_newGearTuned, "cmg_newGearTuned.rds")
```

Exercise 1 
Now you do the same with your model

Important! 

You might notice that in some cases plotFCurves() gives a warning that convergence was not reached. This means that species didn't settle into a new stable state with a new fishing level and we should not trust result for this specific fishing level. When we call plotFCurves() mizer will start with the initial effort and will go up all the way to the maximum value and then go down from the initial to 0. Often we find that it is the most extreme values that do not settle into an equilibrium. We can see that in an example with cma model (curonian model asta) - shoudl we show this example? If yes, we should use pikeperch


## Going back to the original gear parameters

Now we wonder what will happen to species sensitivity to fishing once we go back to the original gear parameters. Afterall, we used those parameters to tune our model using the tuneParams() gadget. Will they still work? Let's explore it. 


```{r}
#these were the original gear parameters
gear_params(cmg)
#we will assign them back to the tuned model 
gear_params(cmg_newGearTuned) <-gear_params(cmg)
#and check that it worked 
gear_params(cmg_newGearTuned)
#and check that reproduction levels are as we want (after all the tuning)
getReproductionLevel(cmg_newGearTuned)
```

Let's plot F curves for small fish

```{r}
plotFCurves(cmg_newGearTuned, species = "smallfish", F_max = 3, no_steps = 20)
```

This does not really make sense, because catchability of smallfish is set to 0, so we are actually not catching it all. Let's better look at ruffe. It is caught, with this the given selectivity we are only catching a few largest individuals 

```{r}
plotFCurves(cmg_newGearTuned, species = "ruffe", F_max = 10, no_steps = 20)
```

So, of course as we expect, even very high effort values (10) will see increasing yield, as we are really not catching much of this species.  

Let's better look at a species that is caught commercially - roach 

```{r}
#F curves with our system specific gear
plotFCurves(cmg_newGearTuned, species = "roach", F_max = 1, no_steps = 20)
#F curves with generic gear that was used for tuning 
plotFCurves(cmg_newGear, species = "roach", F_max = 1, no_steps = 20)
```

Why the difference? Let's look how the original gear parameters differ from our generic set 

```{r}

gear_params(cmg_newGear)[3,]
gear_params(cmg_newGearTuned)[3,]
```

We can see that with the system specific parameters, selectivity starts much later, so again we are only catching largest individuals. Therefore the species can sustain a lot more fishing. Note, however, that catchability was set to 2, so the x axis on the F curve plot should be multiplied by two (in reality we were applying fishign mortality from 0 to 2). You can do the same for other species. 

##Project with a new model 

Now that we calibrated reproduction level let's see how the model responds to changes in overall effort. 

```{r}
#cmg_newGearTuned <- readParams("use/cmg_newGearTuned.rds")

#remind ourselves about the effort that was set
initial_effort(cmg_newGearTuned)
getReproductionLevel(cmg_newGearTuned)
gear_params(cmg_newGearTuned)

#double the effort and see if the model stabilises
sim_cmgTuned06 <- project(cmg_newGearTuned, effort = 0.6, t_max = 100, dt = 0.1)
plotlyBiomass(sim_cmgTuned06)
```   

Generally yes, but one species crashes. What should we do, after all this effort. There are several options: 
1) use steady again and adjust reproduction levels a bit; 
2) adjust reproduction level only for a species that crashed; 
3) go into more complex optimisation of reproduction levels using time series data; 
4) run iterative tuning to adjust sensitivity to fishing in small steps automatically.

We will try the first option, let's adjust it with steady()

```{r}
test <- steady(cmg_newGearTuned)
#what has changed when using steady?
getReproductionLevel(test)/getReproductionLevel(cmg_newGearTuned)

#try to run simulations and vary effort 
sim_test <- project(test, effort = 0.8, t_max = 100, dt = 0.1)
plotBiomass(sim_test)
# it worked, species stabilise
```

TODO: give reference to the tuning with time series using optim (mizerHowTo)

## How do we decide that our model is now properly tuned? 

Here is a list of criteria that could be used for models that were not calibrated to time series data: 

-   Modelled biomasses were within +/- 20% (or some other proportion) of the observed biomasses.
-   Growth curves approximated the von Bertalanffy growth curves for each species.
-   Species diet capture dietary changes with body size, with predators becoming more piscivorous at larger sizes.
-   Recruitment parameters ensured single-species yield curves were dome-shaped, as expected by theory.
-   Modelled catches are similar to the observed catches
-   If available, catch size distributions approximately match, while accounting for gear selectivity in the model and observations 

If time series data of F, species abundance and catches is available we also will look at: 
-   Species recruitment parameters ensure that time series of fishing mortalities produced approximately expected catches and biomases. Some discrepancies are expected due to uncertainty in estimates and stochasticity 

##Other resources 

Some references to more advanced tuning and work in progress 



