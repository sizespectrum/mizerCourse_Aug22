---
title: "Tune reproduction sensitivity"
---

## Introduction

In the tutorial x of week 1 we briefly looked at how density dependence of reproduction, or the so called reproduction level, can influence how species react to changes in mortality, such as from fishing. It might be good if you go back to this tutorial and remind yourself about two parameters that will affect reproduction level. They are $R_max$ and $erepro$. $R_max$ sets the maximum amount of eggs or larvae (individuals in the first size class) that can recruit in the system, where $erepro$ defines the slope of how egg production scales with the energy invested in reproduction (which depends on the spawning stock biomass and their energy intake).

**Important! What is recruitment?**

In fisheries, the term 'recruitment' usually refers to the numbers of fish that recruit into fishery, which will depend on egg production, early density dependence, growth, early mortality and gear selectivity. In mizer we often use the term 'recruitment' to describe the number of individuals that enter the first size class in the model. This number will depend on the energy invested into reproduction and density dependence parameters $R_max$ and $erepro$. So please be aware of this difference, and remember that here recruitment means numbers in the first size class.

When we built our models in week 2 we were not concerned about the reproduction level and we kept the recruitment independent from energy invested into reproduction. The steady() function used in week 2 didn't care about setting realistic reproduction levels for the species. It is important to understand that by modifying $R_max$ and $erepro$ we can change the reproduction level - point along the density dependence curve that the species is - without changing biomass at steady state.

But because reproduction level will affect how species react to fishing, we now need to work on this aspect of the model. So let's look first at the reproduction levels of our species. As usual we load mizerExperimental, mizerMR and get additional code for improved yield curve functions.

```{r}
#| message: false
remotes::install_github("sizespectrum/mizerExperimental", ref = "tuneMR")
remotes::install_github("sizespectrum/mizerMR")
source("experiment/getFCurves.R")
library(mizerExperimental)
library(mizerMR)
library(tidyverse)
```

### Steady state models will not be steady once conditions change

We load our final steady state model that we saved after playing with the tuneParams() gadget. We will run this model to steady() just to make sure resources are as expected (you don't need to get into details of this). We will use two models that Asta and Gustav independently tuned with the tuneParams() gadget.

```{r}
cur_model_asta <- readParams("use/cur_model_asta.rds")
cur_model_gustav <- readParams("build/cur_model_refined.rds")

#run to new steady level. We will abbreviate the two models as cma (curronian model asta) and cmg 
cma <- cur_model_asta |> steady()
cmg <- cur_model_gustav |> steady()

```

Let's first check that steady state models are indeed steady under same conditions. If we run project() with exactly same conditions biomasses should stay stable.

```{r}
initial_effort(cma)
initial_effort(cmg)
```

During the tuning we might have adjusted the overall effort, so when projecting we will use this effort. Then we will project both models for 50 years using the same effort and plot their biomasses

```{r}
sim_cma <- project(cma, effort = 0.5, t_max = 50, dt = 0.1)
plotBiomass(sim_cma)
#everything looks reasonably stable

sim_cmg <- project(cmg, effort = 0.3, t_max = 50, dt = 0.1)
plotBiomass(sim_cmg)
```

Let's check how different the biomases are in the two calibrations (how closely they were matched to observed biomasses)

```{r}
getBiomass(sim_cmg)[51,]/getBiomass(sim_cma)[51,]

```

However, steady state models are not necessarily steady if conditions change. This will depend on how we set up reproduction level and density dependence of recruitment. Let's look at reproduction levels of our steady state models.

```{r}
getReproductionLevel(cma)
getReproductionLevel(cmg)

```

For some species these reproduction levels don't look reasonable at all. They are extremely low, suggesting that recruitment will completely depend on species biomass. If there is small change in biomass, recruitment will decrease, that will lead to less biomass, less recruitment and so on. We want that when we change fishign effort in our models, species should settle into a new equilibrium. If this does not happen, the density dependence does not work very well. To test it we will change the effort and run the models for a little longer

```{r}
#decrease effort from 0.5 to 0.3 and run for a little longer
sim_cma <- project(cma, effort = 0.3, t_max = 100, dt = 0.1)
plotBiomass(sim_cma)

#increase effort from 0.3 to 0.5
sim_cmg <- project(cmg, effort = 0.5, t_max = 100, dt = 0.1)
plotBiomass(sim_cmg)

```

Yes, as expected biomasses keep changing over time and do not settle into a new equilibrium. Let's try to fix it.

## What should the sensitivity to fishing be?

We will need to tune reproduction level of each species to make sure that their response to fishing is reasonable. How do we know what is reasonable? It is not a straightforward question. We can start by consulting general fisheries models. You can read about the principles of basic fisheries surplus production models in this excellent book by Malcolm Haddon "[Using R for Modelling and Quantitative Methods in Fisheries](https://haddonm.github.io/URMQMF/surplus-production-models.html)". In these models population resilience is defined by the maximum population growth rate ***r*** (which is NOT the same as r_max used in mizer). Under the standard assumptions about density dependence (Schaeffer models) maximum sustainable yield (MSY) is expected at 0.5 of unfished stock biomass and it can be estimated as r/4 proportion of of unfished biomass. For example, if r =0.5 and unfished biomass is 1000 tons, MSY is 125 tons. Similarly, proportional harvest rate (proportion of population that can be removed each year) to give MSY is estimated as r/2, which for the case of r= 0.5, would be at 0.25. Note, that this is a proportional harvest rate which is not the same as instantaneous harvest rate in fisheries models and not the same as instantaneous mortality rate used in mizer, but is close enough for values \<0.5). We usually do not know population growth rates (r) for our species, but we can also look up expectations and estimates in FishBase life-history tool section. Or we can use [generic estimates](https://studylib.net/doc/5888624/doc---fishbase) which suggest r of 0.6-1.5 for high resilience species (Von Bertalanffy growth rate K\>0.3, maturation age \< 1, high fecundity) and r of 0.2-1 for medium resilience species (see below).

![](/images/PopGrowthRates.png)

Of course these values are derived from single species models with very different assumptions to those of ours, so they can only be used as very general guides. Also remember again that proportional fishing mortality rates are NOT the same as mizer rates in a steady state population, especially when they are \> 0.7 or more.

Alternatively, we can also use Ken Andersen's book and expectations for species with different w_inf values, as estimated from trait-based models (all species parameters, except for w_inf) are identical) and when all species are fished with 50% selectivity at 5% of their w_inf. The panels below represents species with different asymptotic sizes: 333 g (top), 10 g (bottom left), and 10 kg (bottom right). The lines show yield (black lines), yield per recruit (dashed lines), spawning stock biomass (dark gray lines), and recruitment (light gray lines), all scaled by their maximum value. We will not deal with yield per recruit, so ignore the dashed lines. This figure shows that highest yields are expected at instantaneous fishing mortality of about 0.3-0.5/year.

![](/images/ReferencePointCurves.png)

We can aim to achieve that in our models.

## Tuning sensitivity to fishing

Let's explore how changing reproduction levels will change our species sensitivity to fishing. But for this exploration we will set gear parameters in such a way that all species are fished similarly. This is because our current gear parameters are set for a specific commerical fishery, which selects some species, but does not catch smallfish or almost no ruffe, for smaller fish they target only adults and for largest fish they also target juveniles. Catchabilities also differ a lot.

```{r}
gear_params(cmg)
```

To tune sensitivity of each species to extra mortality we will set catchability of all species to 1, so that effort values directly reflect fishing mortality. We will also set gear 50% selectivity to maturation length of each species and 25% selection to 25% maturation length.

If you do have system specific data on how changes in fishing under system specific gear parameters change species biomasses, you should use these system specific details. We do not have such data for Curonian Lagoon, so we will explore species responses in general.

### Setting gear selectivity

Gear selectivity parameters are defined by length, so we will first convert w_mat and w_mat25 to length values.

```{r}
#calculate L_mat for all species
(L_mat = (species_params(cma)$w_mat/species_params(cma)$a)^(1/species_params(cma)$b))
#calculate L_mat25 for all species
(L_25mat = (species_params(cma)$w_mat25/species_params(cma)$a)^(1/species_params(cma)$b))

#Mizer is set in such way that we need to provide all gear parameters at once, so we first set a gear dataframe and then give it to mizer. 
#take gear parameters from the current model
(gp <- gear_params(cma))
#update L50 selectivity with new values
gp$l50 <- L_mat
#update L25 selectivity with new values
gp$l25 <- L_25mat
#set all catchability to 1
gp$catchability <-1
```

We will assign these gear parameters for our parameterised model, but for simplicity we will use only one model.

```{r}

#assign the model to a new variable, so that we can keep both
cmg_newGear <- cmg
#set new gear parameters for the new model 
(gear_params(cmg_newGear) <- gp)

#as we change gear parameters we need to bring the model to steady again 
cmg_newGear <- steady(cmg_newGear)

#assess whether the model with new gear params is stable and not in fluctuating dynamics
sim_cmg_NewGear <- project(cmg_newGear, effort = 0.3, t_max = 100, dt = 0.1)
plotBiomass(sim_cmg_NewGear)
#good enough 

```

We saw previously that reproduction levels in our species were not very sensible. So we need to decide what reproduction level we should set to start our tuning. Remember when we change species reproduction level we do not change the overall biomass in the steady state (black circle in the figure below), but only the shape of recruitment curves and how quickly they reach the maximum.

TODO: add that plot

For now we will follow [Jacobsen et al. 2016](https://onlinelibrary.wiley.com/doi/full/10.1111/faf.12171) approach and assume the $erepro$ parameter for all species is the same. Once we modify erepro for all species, the reproduction level and Rmax will be adjusted to keep the steady state biomass the same. We can do that with setBevertonHolt() function as we briefly learned in week 1. After some experimentation we found that erepro of 0.002 gives reasonable reproduction levels. You can play with different erepro values for your models.

```{r}
cmg_newGear <- setBevertonHolt(cmg_newGear, erepro = 0.002)
#let's check what reproduction was set
getReproductionLevel(cmg_newGear)
#and look at species reproduction parameters 
species_params(cma_newGear)[, c("erepro", "R_max")]

```

Remember, reproduction level is the ratio between RDD and Rmax and can vary between 0 and 1. It tells us how close the actual reproduction (after applying density dependence) is to the theoretical maximum, set by R_max. We can check this ratio

```{r}
#how close the RDD (actual recruitment, after applying density dependence) is to Rmax? This is the same as reproduction level 
getRDD(cmg_newGear)/species_params(cmg_newGear)$R_max
```

We can also look how close the actual reproduction is to the physiological reproduction - reproduction level produced by the model species, after accounting for the food intake and growth rates, but before applying density dependence (RDI)

```{r}
getRDD(cma_newGear)/getRDI(cma_newGear)

```

This tells us that most species can produce a huge amount more, but this reproduction is strongly capped by the R_max parameter we have (maximum recruitment possible in the system).

## Exploring F curves: breams

To set reproduction level to the reasonable levels and get reasonable response to fishing, we will apply a range of fishing mortalities to one species at a time and check how their yields, biomasses (SSB), RDD and RDI will change. We can use a handy function plotFCurves() or getFCurves() for this purpose. Let's concentrate on breams, or the third species

### doing it only for cmg model

```{r}
species_params(cmg_newGear)$species
getReproductionLevel(cmg_newGear)[2]
plotFCurves(cmg_newGear, species = "ruffe", F_max = 3, no_steps = 20)

rep_level <- getReproductionLevel(cmg_newGear)
rep_level[1] <- 0.90
cmg_newGear <- setBevertonHolt(cmg_newGear, reproduction_level = rep_level)
getReproductionLevel(cmg_newGear)
plotFCurves(cmg_newGear, species = "smallfish", F_max = 3, no_steps = 20)

#smallfish 0.9
#ruffe 0.865 ok as set 
#bream 0.85 - converges ok
#roach 0.6766 fine as set
#vimba 0.80 
#carassius 0.75
#perch 0.5
#pikeperch 0.75
#burbot 0.8
#predator_fish 0.85

cmg_newGearTuned <- cmg_newGear
saveParams(cmg_newGearTuned, "cmg_newGearTuned.rds")


#return original gear params 
gear_params(cmg)
gear_params(cmg_newGearTuned) <-gear_params(cmg)
gear_params(cmg_newGearTuned)
getReproductionLevel(cmg_newGearTuned)

plotFCurves(cmg_newGearTuned, species = "smallfish", F_max = 3, no_steps = 20)
plotFCurves(cmg_newGearTuned, species = "ruffe", F_max = 3, no_steps = 20)


plotFCurves(cmg_newGearTuned, species = "breams", F_max = 1, no_steps = 20)
plotFCurves(cmg_newGear, species = "breams", F_max = 1, no_steps = 20)
gear_params(cmg_newGear)[3,]
gear_params(cmg_newGearTuned)[3,]


plotFCurves(cmg_newGearTuned, species = "roach", F_max = 1, no_steps = 20)
plotFCurves(cmg_newGear, species = "roach", F_max = 1, no_steps = 20)
gear_params(cmg_newGear)[4,]
gear_params(cmg_newGearTuned)[4,]

plotFCurves(cmg_newGearTuned, species = "vimba", F_max = 1, no_steps = 20)
plotFCurves(cmg_newGear, species = "vimba", F_max = 1, no_steps = 20)
gear_params(cmg_newGear)[4,]
gear_params(cmg_newGearTuned)[4,]

plotFCurves(cmg_newGearTuned, species = "perch", F_max = 1, no_steps = 20)
plotFCurves(cmg_newGear, species = "perch", F_max = 1, no_steps = 20)
gear_params(cmg_newGear)[6,]
gear_params(cmg_newGearTuned)[6,]

plotFCurves(cmg_newGearTuned, species = "pikeperch", F_max = 1, no_steps = 20)
plotFCurves(cmg_newGear, species = "pikeperch", F_max = 1, no_steps = 20)
gear_params(cmg_newGear)[8,]
gear_params(cmg_newGearTuned)[8,]

plotFCurves(cmg_newGearTuned, species = "burbot", F_max = 1, no_steps = 20)
plotFCurves(cmg_newGear, species = "burbot", F_max = 1, no_steps = 20)
gear_params(cmg_newGear)[9,]
gear_params(cmg_newGearTuned)[9,]

```

```{r}
#check its reproduction level 
getReproductionLevel(cma_newGear)[3]

#get F curves 
plotFCurves(cma_newGear, species = "breams", F_max = 1, no_steps = 20)
#TODO: explain what this does 

getReproductionLevel(cmg_newGear)[3]
plotFCurves(cmg_newGear, species = "breams", F_max = 1, no_steps = 20)

#now we want to know how these curves look in two differnet models. Do they depend only on bream reproduction parameters alone, or also on species interactions? We will set reproduction level to the same value in two models (cma and cmg) and run the same function 

#model that Asta tuned (but with updated gear parameters)
rep_level <- getReproductionLevel(cma_newGear)
rep_level[3] <- 0.90
cma_newGear <- setBevertonHolt(cma_newGear, reproduction_level = rep_level)
getReproductionLevel(cma_newGear)

#model that Gustav tuned (but with updated gear parameters)
rep_level <- getReproductionLevel(cmg_newGear)
rep_level[3] <- 0.90
cmg_newGear <- setBevertonHolt(cmg_newGear, reproduction_level = rep_level)
getReproductionLevel(cmg_newGear)
```

plot curves from the two calibration sets again, reproduction level for bream is the same now

```{r}
plotFCurves(cma_newGear, species = "breams", F_max = 1, no_steps = 20)

plotFCurves(cmg_newGear, species = "breams", F_max = 1, no_steps = 20)
```

How will these calibration sets respond to changes in reproduction level? We can see that the first model yield curve peaks at 0.1 and then drops fast, so we probably need higher reproduction level. For the second model we may want to reduce reproduction level, as the yield curve does not drop even with very high fishing mortality.

```{r}
rep_level <- getReproductionLevel(cma_newGear)
rep_level[3] <- 0.99
cma_newGear <- setBevertonHolt(cma_newGear, reproduction_level = rep_level)
getReproductionLevel(cma_newGear)
plotFCurves(cma_newGear, species = "breams", F_max = 1, no_steps = 20)

(rep_level <- getReproductionLevel(cmg_newGear))
rep_level[3] <- 0.8
cmg_newGear <- setBevertonHolt(cmg_newGear, reproduction_level = rep_level)
getReproductionLevel(cmg_newGear)
plotFCurves(cmg_newGear, species = "breams", F_max = 1, no_steps = 20)

#the second model curve looks more reasonable now

```

## Exploring F curves: pikeperch

Now let's look at another species - pikeperch

```{r}
getReproductionLevel(cma_newGear)
getReproductionLevel(cmg_newGear)

plotFCurves(cma_newGear, species = "pikeperch", F_max = 1, no_steps = 20)

plotFCurves(cmg_newGear, species = "pikeperch", F_max = 1, no_steps = 20)
```

TODO: explain issues with non-convergence and how the plotFCurves first goes to the right and then to the left.

The second model looks much better, and it also converges nicely. However, yield curves does not go down, so we will reduce the reproduction level from a very high value of 0.99 to 0.9

```{r}
(rep_level <- getReproductionLevel(cmg_newGear))
rep_level[8] <- 0.90
cmg_newGear <- setBevertonHolt(cmg_newGear, reproduction_level = rep_level)
getReproductionLevel(cmg_newGear)

plotFCurves(cmg_newGear, species = "pikeperch", F_max = 1, no_steps = 20)

#we can expand the maximum range until which we explore these curves to see if the yield curve starts to go down 
plotFCurves(cmg_newGear, species = "pikeperch", F_max = 1.5, no_steps = 20)

#this is looking reasonably well, but we might want to decrease the reproduction level further down if we have evidende that maximum yield is achieved at lower values. 

rep_level[8] <- 0.85
cmg_newGear <- setBevertonHolt(cmg_newGear, reproduction_level = rep_level)
getReproductionLevel(cmg_newGear)

plotFCurves(cmg_newGear, species = "pikeperch", F_max = 1, no_steps = 20)

#But now that we changed the pikeperch, has this affected yield curves for breams?
plotFCurves(cmg_newGear, species = "breams", F_max = 1, no_steps = 20)
#not really
```

Do that for other species

Run project Set original gear parameters to the new models and explore fishing impacts

Remind participants again what the stock recruitment curve means and what we do by changing reproduction level (use a figure from Ken perhaps)

TODO - Jacobsen et al. Fish Fish paper on LME and tuning appendix - suggest physiological recruitment versus actual recruitment (RDI/RDD) = 100 for many species

Now we project with same effort level

```{r}

#and now run the simulation with higher effort 
sim_cmg <- project(cmg_newGear, effort = 0.6, t_max = 200, dt = 0.1)
plot(sim_cmg)
#now species are more resilient to fishing. Can they sustain much higher fishing levels?     
    
sim_cma <- project(cma_newGear, effort = 0.6, t_max = 200, dt = 0.1)
plot(sim_cma)

#compare biomassed at same fishing level from two different model parameterisations
getBiomass(sim_cmg)[201,]/getBiomass(sim_cma)[201,]
```

# END OF ASTA's attempts for now. I am work on details below

```{r,echo=FALSE,message=FALSE}
remotes::install_github("sizespectrum/mizerExperimental")
library(mizerExperimental)
remotes::install_github("sizespectrum/mizerMR")
library(mizerMR)
remotes::install_github("sizespectrum/mizerHowTo")
library(mizerHowTo)
library(tidyverse)
source("use/helper_functions.R")
```

We will start with a new example model, a preliminary model for the Heard and McDonald Islands Patagonian toothfish longline fishery. While this is not a coastal or inland fishery, it is relatively data poor.

The model has been calibrated using time-averaged data to achieve coexistence and a steady state. This followed a similar approach as the one you used last week. Feel free to use this model, the Curonian Lagoon model, or your own model in the scenarios you develop later on.

First, let's read in the param object for this model, which contains the steady state information. The file is called *params10.rmd*, showing there was already an iterative process involved with checking, refining , re-calibrating and re-checking the model, using time-averaged biomass data and the diagnostic plots below.

```{r,message=FALSE}
sim <- readRDS("use/toothfish/params10.RDS")
params <- sim@params
plotBiomassObservedVsModelCustom(params,ratio = T)
plotGrowthCurves(sim,species_panel = T)
plotlySpectra(sim, power = 2, total = TRUE)
plotDiet2(sim)
```

This model is focussed on Patagonian toothfish and key prey species in the longline fishery.

For this model, we had the following main criteria for our project:

-   Modelled biomasses were within +/- 10-20% of the observed biomasses.

-   Unfished normalised biomass size spectrum slope that is negative and close to -1

-   Growth curves approximated the von Bertalanffy growth curves for each species.

-   Toothfish diet captured dietary changes with body size and became more piscivorous at larger sizes.

-   Recruitment parameters ensured single-species yield curves were dome-shaped, as expected by theory.

-   The modeled catches through time captured the trends in the reported catches through time.

We can see from these plots that we still have more work to do with refining the model. The size at age for some species seem much higher than the empirical parameters, feeding level of near satiation for all species and the biomass of some species is much higher than the data. However size-at-age data are typically highly variable. So, let's set some of those issues aside for now.

The last two of the criteria above require examining how the system reacts to changes in fishing. In the next tutorial we will look at changes though time. Here, we will examine how the reproduction parameters produce reasonable yield curves. How do we do this?

First, let's take a look at how fishing is set up in this model.

```{r}
gear_params(params)
```

Currently we can see there is one gear - *longline* - which has a knife_edge selectivity function that starts fishing at very large sizes of toothfish only (*knife_edge_size*=2722 g). The size selectivity was derived from the length distribution of catches from the long-line fisheries data. If your model does not yet include fishing, you can set up your own fishing gear using the *gear_params()* function and by following the example [here](https://sizespectrum.org/mizer/reference/setFishing.html).

We can see that the *initial_effort* has been set to 1 and the *catchability* has been set to a very low number: 7e-07. This shows the model has been calibrated with a very low level of fishing mortality.

### Tuning fishing

As mentioned before the calibrated reproduction parameters affect how species respond to fishing intensity. To get an idea on how the model has been calibrated in terms of reproduction, let's check the reproduction level.

```{r,message=FALSE}
reproduction_level <- getReproductionLevel(params)
reproduction_level

species_params(params)[, c("erepro", "R_max")]

```

We can see that the erepro and R_max values have been estimated. Let's see how close the model catches are form the observed.

```{r,message=FALSE}
plotYieldObservedVsModel(params, ratio=T)
```

The modeled yields looks pretty close to the observed.

Now, let's take a look at how this combination of parameters influences how toothfish respond to different levels of fishing. These are not temporal dynamics with fishing changing through time yet, each level run at steady state.

```{r,message=FALSE}
plotYieldVsF(params,species="D.ele",no_steps=50,F_max=2)
# Fmsy around 0.4 for toothfish

```

Next let's see what happens if we adjust the reproduction parameters. If you would like to read further about this step see Gustav's blogpost [here](https://blog.mizer.sizespectrum.org/posts/2021-08-03-density-dependence-in-reproduction/).

```{r}
params2 <- setBevertonHolt(params, reproduction_level = 0.85)

plotBevertonHolt2(params, params2, "D.ele")

sim2 <- project(params2, t_max = 20)
plotBiomass(sim2)


plotYieldVsF(params,species="D.ele",no_steps=50,F_max=2)
plotYieldVsF(params2,species="D.ele",no_steps=50,F_max=2)


```

This shows that altering the level of density-dependence in recruitment affects how sensitive toothfish (D.ele for short) are to fishing. The first model would enable toothfish to sustain (at equilbrium) much higher levels of fishing before it collapses.

### Exercise

Explore changes in reproduction level using your model (or the curonian lagoon model). How does changing the reproduction level affect how closely your modeled biomasses and catches match the observations?

## Comparing ecosystem states: effects of fishing relative to an unfished state

To be able to assess the wider ecosystem impacts of fishing in the community we need to understand how changes compare to an unfished state. We can use the above model unfished steady state with effort = 0 to do this combined with some functions to calculate ecological indicators.

Let's compare the current size spectra (with fishing) to the unfished size spectra to assess whether there is any evidence of a size-structured trophic cascade due to fishing.

```{r , code_folding=TRUE, eval = T, echo = T, warning=F}
sim0 <- projectToSteady(params, effort = 0, return_sim = TRUE, t_max = 200)
sim <- projectToSteady(params, effort = 1, return_sim = TRUE, t_max = 200)
plot_relative_biomass(sim0, sim)
```

Here we can see the effect of the reduction in large sized individuals of heavily fished species on the other sizes and species in the model, relative to the unfished steady state.

The abundance of some (but not all) of the smaller to medium sizes of prey are a lot higher when their larger predators are removed (note the logarithmic scale). Sprat looks to be much lower.

We can do the same with Biomass to see when, if any, of the species collapse. For simplicity, we use \< 0.1 of B/B_unfished as a proxy for a reference point for population collapse. We can add other reference points to this kind of plot, for example a simple rule of thumb for B_msy could be 0.5\*B_unfished.

```{r,code_folding=TRUE, eval = T, echo = F, warning=F}
# collect the biomasses from unfish and calcualte the relative change
B0 <- getBiomass(sim0)[2,]
Brel <- melt(sweep(getBiomass(sim), 2, B0, "/")[2,])
ggplot(log10(Brel), aes(x = row.names(Brel), y = value)) +
  geom_bar(stat = "identity",
           show.legend = FALSE) + # Remove the legend
  xlab("Group") +
  ylab("Proportion of Unfished Biomass") 

B0 <- getBiomass(sim0)
Brel <- melt(sweep(getBiomass(sim), 2, B0, "/"))
```

We can see there is very low impact on the biomass of each group, due to the very small rates of fishing mortality being inflicted on toothfish.

#### Exercise

How do the biomasses change under your scenarios of fishing mortality when the reproduction level is lowered?

### Summary
